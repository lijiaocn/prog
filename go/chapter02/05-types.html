<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>类型</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <div style="width:100%;text-align:center">
                  <h2 style="color:#afa790">编程基础</h2>
                  <p style="font-weight:bold"><a style="color:lightgray;" href="https://www.lijiaocn.com">www.lijiaocn.com</a></p>
                </div>
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> 笔记说明</a></li><li class="chapter-item expanded "><a href="../../shell/index.html"><strong aria-hidden="true">2.</strong> Shell 脚本</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../shell/struct.html"><strong aria-hidden="true">2.1.</strong> 变量与数据结构</a></li><li class="chapter-item expanded "><a href="../../shell/cmd.html"><strong aria-hidden="true">2.2.</strong> 内置命令用法</a></li></ol></li><li class="chapter-item expanded "><a href="../../c/index.html"><strong aria-hidden="true">3.</strong> C 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../c/strings.html"><strong aria-hidden="true">3.1.</strong> 字符串处理</a></li><li class="chapter-item expanded "><a href="../../c/time.html"><strong aria-hidden="true">3.2.</strong> 时间操作</a></li><li class="chapter-item expanded "><a href="../../c/dynamiclib.html"><strong aria-hidden="true">3.3.</strong> 动态链接库</a></li><li class="chapter-item expanded "><a href="../../c/signal.html"><strong aria-hidden="true">3.4.</strong> 信号量操作</a></li><li class="chapter-item expanded "><a href="../../c/memory.html"><strong aria-hidden="true">3.5.</strong> 内存管理操作</a></li><li class="chapter-item expanded "><a href="../../c/print.html"><strong aria-hidden="true">3.6.</strong> 格式化打印输出</a></li><li class="chapter-item expanded "><a href="../../c/file.html"><strong aria-hidden="true">3.7.</strong> 文件&设备操作</a></li><li class="chapter-item expanded "><a href="../../c/process.html"><strong aria-hidden="true">3.8.</strong> 进程管理操作</a></li><li class="chapter-item expanded "><a href="../../c/concurrent.html"><strong aria-hidden="true">3.9.</strong> 并发编程</a></li><li class="chapter-item expanded "><a href="../../c/socket.html"><strong aria-hidden="true">3.10.</strong> socket通信</a></li><li class="chapter-item expanded "><a href="../../c/filesystem.html"><strong aria-hidden="true">3.11.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="../../c/sysconfig.html"><strong aria-hidden="true">3.12.</strong> 系统配置</a></li><li class="chapter-item expanded "><a href="../../c/namespace.html"><strong aria-hidden="true">3.13.</strong> Namespace操作</a></li><li class="chapter-item expanded "><a href="../../c/hardware.html"><strong aria-hidden="true">3.14.</strong> 硬件信息读取</a></li></ol></li><li class="chapter-item expanded "><a href="../../go/index.html"><strong aria-hidden="true">4.</strong> Go 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../go/chapter01/01-install.html"><strong aria-hidden="true">4.1.</strong> 安装和文档</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/00-about.html"><strong aria-hidden="true">4.2.</strong> 基础语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../go/chapter02/02-lexical-elements.html"><strong aria-hidden="true">4.2.1.</strong> 词法</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/03-constants.html"><strong aria-hidden="true">4.2.2.</strong> 常量</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/04-variables.html"><strong aria-hidden="true">4.2.3.</strong> 变量</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/05-types.html" class="active"><strong aria-hidden="true">4.2.4.</strong> 类型</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/06-declarations.html"><strong aria-hidden="true">4.2.5.</strong> 声明</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/07-expressions.html"><strong aria-hidden="true">4.2.6.</strong> 表达式</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/08-statements.html"><strong aria-hidden="true">4.2.7.</strong> 语句</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/10-package.html"><strong aria-hidden="true">4.2.8.</strong> 包声明</a></li></ol></li><li class="chapter-item expanded "><a href="../../go/chapter02/09-builtin.html"><strong aria-hidden="true">4.3.</strong> 内置函数</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/11-initialization.html"><strong aria-hidden="true">4.4.</strong> 初始化</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/12-errors.html"><strong aria-hidden="true">4.5.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/13-system.html"><strong aria-hidden="true">4.6.</strong> 系统相关</a></li><li class="chapter-item expanded "><a href="../../go/chapter03/01-cmdline.html"><strong aria-hidden="true">4.7.</strong> 命令行参数</a></li><li class="chapter-item expanded "><a href="../../go/chapter03/02-log.html"><strong aria-hidden="true">4.8.</strong> 日志打印</a></li><li class="chapter-item expanded "><a href="../../go/chapter03/convert.html"><strong aria-hidden="true">4.9.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="../../go/chapter04/01-dependency.html"><strong aria-hidden="true">4.10.</strong> 代码管理</a></li><li class="chapter-item expanded "><a href="../../go/template/index.html"><strong aria-hidden="true">4.11.</strong> Go Tempalte</a></li><li class="chapter-item expanded "><a href="../../go/chapter02/99-examples.html"><strong aria-hidden="true">4.12.</strong> 遗留代码片段</a></li><li class="chapter-item expanded "><a href="../../testframe/ginkgo.html"><strong aria-hidden="true">4.13.</strong> Go 测试框架 GinkGo</a></li></ol></li><li class="chapter-item expanded "><a href="../../go/article/index.html"><strong aria-hidden="true">5.</strong> Go 语言深入</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../go/article/pkg.html"><strong aria-hidden="true">5.1.</strong> 代码要如何组织?</a></li><li class="chapter-item expanded "><a href="../../go/article/create_mod.html"><strong aria-hidden="true">5.2.</strong> 多版本依赖功能验证</a></li><li class="chapter-item expanded "><a href="../../go/article/testcase.html"><strong aria-hidden="true">5.3.</strong> 测试用例的覆盖率</a></li><li class="chapter-item expanded "><a href="../../go/article/varcopy.html"><strong aria-hidden="true">5.4.</strong> 按值传递的开销很大</a></li><li class="chapter-item expanded "><a href="../../go/article/waitgroup.html"><strong aria-hidden="true">5.5.</strong> 并发与按值传递血案</a></li><li class="chapter-item expanded "><a href="../../go/article/debug.html"><strong aria-hidden="true">5.6.</strong> 程序运行时跟踪调试</a></li><li class="chapter-item expanded "><a href="../../go/article/pprof.html"><strong aria-hidden="true">5.7.</strong> 程序运行时状态查看</a></li><li class="chapter-item expanded "><a href="../../go/article/unmarshal.html"><strong aria-hidden="true">5.8.</strong> 大量反序列化用指针</a></li></ol></li><li class="chapter-item expanded "><a href="../../go/gin/index.html"><strong aria-hidden="true">6.</strong> Gin 的原理与学习资料</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../go/gin/quickstart.html"><strong aria-hidden="true">6.1.</strong> 快速开始</a></li><li class="chapter-item expanded "><a href="../../go/gin/router.html"><strong aria-hidden="true">6.2.</strong> 路由管理</a></li><li class="chapter-item expanded "><a href="../../go/gin/param.html"><strong aria-hidden="true">6.3.</strong> 参数读取</a></li><li class="chapter-item expanded "><a href="../../go/gin/response.html"><strong aria-hidden="true">6.4.</strong> 响应数据</a></li></ol></li><li class="chapter-item expanded "><a href="../../lua/index.html"><strong aria-hidden="true">7.</strong> Lua 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../lua/basic_type.html"><strong aria-hidden="true">7.1.</strong> 基本数据类型</a></li><li class="chapter-item expanded "><a href="../../lua/keywords_operator.html"><strong aria-hidden="true">7.2.</strong> 关键字与操作符</a></li><li class="chapter-item expanded "><a href="../../lua/control_flow.html"><strong aria-hidden="true">7.3.</strong> 条件语句与循环</a></li><li class="chapter-item expanded "><a href="../../lua/function.html"><strong aria-hidden="true">7.4.</strong> 函数定义使用</a></li><li class="chapter-item expanded "><a href="../../lua/module.html"><strong aria-hidden="true">7.5.</strong> 模块定义使用</a></li><li class="chapter-item expanded "><a href="../../lua/metatable.html"><strong aria-hidden="true">7.6.</strong> 元表定义设置</a></li><li class="chapter-item expanded "><a href="../../lua/object_oriented.html"><strong aria-hidden="true">7.7.</strong> 面向对象设计</a></li><li class="chapter-item expanded "><a href="../../lua/01-standard-output.html"><strong aria-hidden="true">7.8.</strong> 标准输出打印</a></li><li class="chapter-item expanded "><a href="../../lua/02-string-operation.html"><strong aria-hidden="true">7.9.</strong> 字符串操作</a></li><li class="chapter-item expanded "><a href="../../lua/03-lua-performance.html"><strong aria-hidden="true">7.10.</strong> 性能相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../lua/03-lua-performance-local-var.html"><strong aria-hidden="true">7.10.1.</strong> 局部变量比全局变量快30%</a></li><li class="chapter-item expanded "><a href="../../lua/03-lua-performance-load-dynamic.html"><strong aria-hidden="true">7.10.2.</strong> 动态加载代码非常慢</a></li><li class="chapter-item expanded "><a href="../../lua/03-lua-performance-table-space.html"><strong aria-hidden="true">7.10.3.</strong> table自动扩容代价很高</a></li><li class="chapter-item expanded "><a href="../../lua/03-lua-performance-table-space-1.html"><strong aria-hidden="true">7.10.4.</strong> 清理table成员不会触发rehash</a></li><li class="chapter-item expanded "><a href="../../lua/03-lua-performance-string.html"><strong aria-hidden="true">7.10.5.</strong> 慎用字符串拼接</a></li><li class="chapter-item expanded "><a href="../../lua/03-lua-performance-less-var.html"><strong aria-hidden="true">7.10.6.</strong> 尽量少创建变量</a></li><li class="chapter-item expanded "><a href="../../lua/03-lua-performance-cache-result.html"><strong aria-hidden="true">7.10.7.</strong> 缓存运算结果</a></li><li class="chapter-item expanded "><a href="../../lua/03-lua-performance-garbage-collect.html"><strong aria-hidden="true">7.10.8.</strong> 主动控制垃圾回收</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../python3/index.html"><strong aria-hidden="true">8.</strong> Python3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../python3/2to3.html"><strong aria-hidden="true">8.1.</strong> python2 代码转换成 python3</a></li><li class="chapter-item expanded "><a href="../../python3/project.html"><strong aria-hidden="true">8.2.</strong> 运行环境与依赖管理</a></li><li class="chapter-item expanded "><a href="../../python3/syntax.html"><strong aria-hidden="true">8.3.</strong> 代码文件</a></li><li class="chapter-item expanded "><a href="../../python3/struct.html"><strong aria-hidden="true">8.4.</strong> 基本类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../python3/list.html"><strong aria-hidden="true">8.4.1.</strong> list</a></li><li class="chapter-item expanded "><a href="../../python3/tuple.html"><strong aria-hidden="true">8.4.2.</strong> tuple</a></li><li class="chapter-item expanded "><a href="../../python3/set.html"><strong aria-hidden="true">8.4.3.</strong> set</a></li><li class="chapter-item expanded "><a href="../../python3/dictionary.html"><strong aria-hidden="true">8.4.4.</strong> dictionary</a></li></ol></li><li class="chapter-item expanded "><a href="../../python3/string.html"><strong aria-hidden="true">8.5.</strong> 字符串处理</a></li><li class="chapter-item expanded "><a href="../../python3/time.html"><strong aria-hidden="true">8.6.</strong> 时间处理</a></li><li class="chapter-item expanded "><a href="../../python3/num.html"><strong aria-hidden="true">8.7.</strong> 数值处理</a></li><li class="chapter-item expanded "><a href="../../python3/builtin.html"><strong aria-hidden="true">8.8.</strong> 内置函数</a></li><li class="chapter-item expanded "><a href="../../python3/scope.html"><strong aria-hidden="true">8.9.</strong> 变量作用域</a></li><li class="chapter-item expanded "><a href="../../python3/params.html"><strong aria-hidden="true">8.10.</strong> 参数读取</a></li><li class="chapter-item expanded "><a href="../../python3/module.html"><strong aria-hidden="true">8.11.</strong> 模块用法</a></li><li class="chapter-item expanded "><a href="../../python3/package.html"><strong aria-hidden="true">8.12.</strong> 包用法</a></li><li class="chapter-item expanded "><a href="../../python3/format.html"><strong aria-hidden="true">8.13.</strong> 格式化输出</a></li><li class="chapter-item expanded "><a href="../../python3/file.html"><strong aria-hidden="true">8.14.</strong> 文件读写</a></li><li class="chapter-item expanded "><a href="../../python3/error.html"><strong aria-hidden="true">8.15.</strong> 错误和异常</a></li><li class="chapter-item expanded "><a href="../../python3/class.html"><strong aria-hidden="true">8.16.</strong> 类</a></li><li class="chapter-item expanded "><a href="../../python3/generator.html"><strong aria-hidden="true">8.17.</strong> 生成器</a></li></ol></li><li class="chapter-item expanded "><a href="../../py3spider/index.html"><strong aria-hidden="true">9.</strong> Python3 爬虫开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../py3spider/request.html"><strong aria-hidden="true">9.1.</strong> Python3 请求库</a></li><li class="chapter-item expanded "><a href="../../py3spider/parse.html"><strong aria-hidden="true">9.2.</strong> Python3 解析库</a></li><li class="chapter-item expanded "><a href="../../py3spider/mobile.html"><strong aria-hidden="true">9.3.</strong> 移动 APP 工具</a></li><li class="chapter-item expanded "><a href="../../py3spider/framework.html"><strong aria-hidden="true">9.4.</strong> Python3 爬虫框架</a></li></ol></li><li class="chapter-item expanded "><a href="../../django/index.html"><strong aria-hidden="true">10.</strong> Django 开发手册</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../django/install.html"><strong aria-hidden="true">10.1.</strong> 环境安装</a></li><li class="chapter-item expanded "><a href="../../django/first-project.html"><strong aria-hidden="true">10.2.</strong> 项目的创建</a></li><li class="chapter-item expanded "><a href="../../django/first-app.html"><strong aria-hidden="true">10.3.</strong> 应用的创建</a></li><li class="chapter-item expanded "><a href="../../django/database.html"><strong aria-hidden="true">10.4.</strong> 对接数据库</a></li><li class="chapter-item expanded "><a href="../../django/database-init.html"><strong aria-hidden="true">10.5.</strong> 数据库初始化</a></li><li class="chapter-item expanded "><a href="../../django/database-usage.html"><strong aria-hidden="true">10.6.</strong> 数据库查询写入</a></li><li class="chapter-item expanded "><a href="../../django/database-shell.html"><strong aria-hidden="true">10.7.</strong> 命令行操作数据库</a></li><li class="chapter-item expanded "><a href="../../django/admin.html"><strong aria-hidden="true">10.8.</strong> 使用后台管理页面</a></li><li class="chapter-item expanded "><a href="../../django/views.html"><strong aria-hidden="true">10.9.</strong> views 的开发</a></li><li class="chapter-item expanded "><a href="../../django/generic_views.html"><strong aria-hidden="true">10.10.</strong> 使用 Generic Views</a></li><li class="chapter-item expanded "><a href="../../django/test.html"><strong aria-hidden="true">10.11.</strong> 编写测试代码</a></li><li class="chapter-item expanded "><a href="../../django/static.html"><strong aria-hidden="true">10.12.</strong> 页面模版中引入静态资源</a></li><li class="chapter-item expanded "><a href="../../django/input.html"><strong aria-hidden="true">10.13.</strong> 传入参数的获取</a></li><li class="chapter-item expanded "><a href="../../django/log.html"><strong aria-hidden="true">10.14.</strong> 日志管理</a></li><li class="chapter-item expanded "><a href="../../django/global_setting.html"><strong aria-hidden="true">10.15.</strong> 项目的全局设置</a></li><li class="chapter-item expanded "><a href="../../django/problems.html"><strong aria-hidden="true">10.16.</strong> 问题记录</a></li><li class="chapter-item expanded "><a href="../../django/idea_usage.html"><strong aria-hidden="true">10.17.</strong> IDEA 远程调试 python</a></li><li class="chapter-item expanded "><a href="../../django/package.html"><strong aria-hidden="true">10.18.</strong> 使用自定义的 Package</a></li><li class="chapter-item expanded "><a href="../../django/deploy.html"><strong aria-hidden="true">10.19.</strong> 用WSGI方式部署Django服务</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../django/deploy_apache.html"><strong aria-hidden="true">10.19.1.</strong> 在Apache中部署Django应用</a></li></ol></li><li class="chapter-item expanded "><a href="../../django/redis_cache.html"><strong aria-hidden="true">10.20.</strong> 引入redis缓存</a></li><li class="chapter-item expanded "><a href="../../django/import-django.html"><strong aria-hidden="true">10.21.</strong> 导入django环境</a></li></ol></li><li class="chapter-item expanded "><a href="../../android/start.html"><strong aria-hidden="true">11.</strong> Android</a></li><li class="chapter-item expanded "><a href="../../vue/start.html"><strong aria-hidden="true">12.</strong> Vue</a></li><li class="chapter-item expanded "><a href="../../wechat/index.html"><strong aria-hidden="true">13.</strong> 微信公众号 API 使用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../wechat/shezhi.html"><strong aria-hidden="true">13.1.</strong> 设置方法</a></li><li class="chapter-item expanded "><a href="../../wechat/message.html"><strong aria-hidden="true">13.2.</strong> 消息格式</a></li><li class="chapter-item expanded "><a href="../../wechat/debug.html"><strong aria-hidden="true">13.3.</strong> 接口调试</a></li></ol></li><li class="chapter-item expanded "><a href="../../taobaoke/index.html"><strong aria-hidden="true">14.</strong> 淘宝客 API 使用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../taobaoke/kaitong.html"><strong aria-hidden="true">14.1.</strong> 开通方法</a></li><li class="chapter-item expanded "><a href="../../taobaoke/sdk.html"><strong aria-hidden="true">14.2.</strong> SDK下载</a></li><li class="chapter-item expanded "><a href="../../taobaoke/api.html"><strong aria-hidden="true">14.3.</strong> 接口梳理</a></li><li class="chapter-item expanded "><a href="../../taobaoke/api_call.html"><strong aria-hidden="true">14.4.</strong> 接口调用</a></li></ol></li></ol>
               <div style="width:100%;text-align:center">
                  <img style="width:100%" src="https://www.lijiaocn.com/img/ercode/cur.jpg"/>
               </div>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div style="text-align:center;width:100%">
                    <!--h1>顶部条幅广告</h1-->
                    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8176866190626448"
                     crossorigin="anonymous"></script>
                     <!-- 顶部条幅广告 -->
                    <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-8176866190626448"
                     data-ad-slot="1000173679"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
                     <script>
                     (adsbygoogle = window.adsbygoogle || []).push({});
                     </script>
                </div>

                <div id="content" class="content">
                    <main>
                        <!-- toc -->
<h1 id="go的类型"><a class="header" href="#go的类型">go的类型</a></h1>
<p>类型是用来诠释如何解读指定位置中存放的数据，以及约定操作符的含义的。</p>
<h2 id="类型的属性"><a class="header" href="#类型的属性">类型的属性</a></h2>
<h3 id="内置类型predeclared"><a class="header" href="#内置类型predeclared">内置类型(predeclared)</a></h3>
<p>go语言内置了下面的类型：</p>
<pre><code>bool byte complex64 complex128 error float32 float64
int int8 int16 int32 int64 rune string
uint uint8 uint16 uint32 uint64 uintptr
</code></pre>
<h3 id="命名类型named"><a class="header" href="#命名类型named">命名类型(named)</a></h3>
<p>类型可以是命名的(named)，也可以是未命名的(unnamed)。</p>
<pre><code>Type      = TypeName | TypeLit | &quot;(&quot; Type &quot;)&quot; .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
            SliceType | MapType | ChannelType .
</code></pre>
<p>使用<code>type</code>指定了名字的类型是命名的，例如下面的类型的名字为Student</p>
<pre><code>type Student struct {
	Name string
	age int
}
</code></pre>
<p>由其它类型组合成的新类型，可以不被命名，例如下面的类型是没有名字的：</p>
<pre><code>[] string
[] int
</code></pre>
<p>无类型的名字，通用用于定义其它类型:</p>
<pre><code>type Array []int
</code></pre>
<p>或者在函数定义中使用：</p>
<pre><code>func Display(s struct {
    name string
    age  int
}) {
    println(s.name)
    println(s.age)
}
</code></pre>
<h3 id="实际类型underlying-type"><a class="header" href="#实际类型underlying-type">实际类型(underlying type)</a></h3>
<p>类型是可以用来定义其它类型的，例如：</p>
<pre><code>type T1 string 
type T2 T1
</code></pre>
<p>这里定义了一个类型T1，然后又用T1定义了类型T2。</p>
<p>T1的实际类型(underlying type)是string，T2的实际类型不是T1，而是T1的实际类型string。</p>
<p>实际类型必须是go的内置类型或者类型的组合。</p>
<p>例如，string、T1、T2的实际类型是string。</p>
<pre><code>type T1 string
type T2 T1
</code></pre>
<p>[]T1、T3、T4的实际类型是[]T1。</p>
<pre><code>type T3 []T1
type T4 T3
</code></pre>
<h3 id="类型的方法method-sets"><a class="header" href="#类型的方法method-sets">类型的方法(method sets)</a></h3>
<p>类型可以有自己的方法(Method)，也就是其它语言中的函数。</p>
<p>一个非接口类型的方法集就所有接受者(receiver)为改类型的方法，接口类型的方法集就是接口定义中包含的方法。</p>
<p>需要注意的是指针类型类型（例如 * T)，它的方法集是所有接受者为所指类型(T)和指针类型( * T)的方法集。</p>
<p>例如下面的代码中，方法的Show的Receiver是Str，但是类型为 * Str的pstr也可以调用。</p>
<pre><code>package main

type Str string

func (s Str) Show() {
	println(s)
}

func main() {
	str := Str(&quot;Hello World!&quot;)
	pstr := &amp;str
	pstr.Show()
}
</code></pre>
<p>方法集中的方法不能重名、且必须有名字。</p>
<h3 id="类型的等同性identical"><a class="header" href="#类型的等同性identical">类型的等同性(identical)</a></h3>
<p>命名语句不同的两个命名类型，是不等同的。例如下面的T1和T2，虽然实际类型都是string，但它们是两个类型。</p>
<pre><code>type T1 string
type T2 string
</code></pre>
<p>命名类型与未命名类型是不等同的，例如下面的T1与[]string是两个类型。</p>
<pre><code>type T1 []string
[]string
</code></pre>
<p>命名语句和定义语句<code>完全相同</code>的两个命名类型是才等同的，例如下面的T1。</p>
<pre><code>type T1 string
type T1 string
</code></pre>
<p>定义语句<code>完全相同</code>的两个未命名类型才是等同的，例如下面的[]string。</p>
<pre><code>[5]string
[5]string
</code></pre>
<p>在编程时，同一个类型只会定义一次。</p>
<p>在代码中定义<code>两个</code>等同的类型其是做不到的，因为它们如果等同，那么其实就是一个。例如下面的代码。</p>
<pre><code>package main

type T string
type T string

func main() {
}
</code></pre>
<p>编译时会报错。</p>
<pre><code>./main.go:5: T redeclared in this block
    previous declaration at ./main.go:4
</code></pre>
<p>两个类型等同是一个用来解释类型不等同的规则，即如果不符合遵守等同的规则，那么就是不等同的。</p>
<p>对于未命名类型需要特别注意，只要不满足下面的条件，那么就是两个不同的类型：</p>
<pre><code>两个数组类型要等同，不仅数组中成员的类型要相同，而且数组的长度也要相同。
两个分片类型等同，只需要分片的成员类型相同。
两个结构体等同，结构体成员的顺序、名称、标签(tag)都必须相同。
两个指针类型，所指向的类型相同。
两个函数类型，要有相同的数量的参数和返回值，参数和返回值的类型要相同，参数名和返回值的名字可以不同。
两个接口类型，要有相同的方法，方法的顺序可以不同。
两个字典类型，key的类型和value的类型必须相同。
两个通道(channel)类型，通道的方向和传递的类型必须相同。
</code></pre>
<p>例如下面两个函数类型符合上面的条件，所以是相同的：</p>
<pre><code>func(x int, y float64) *[]string
func(int, float64) (result *[]string)
</code></pre>
<h3 id="类型的赋值assignability"><a class="header" href="#类型的赋值assignability">类型的赋值(Assignability)</a></h3>
<p>一个值(value)只有在满足下面的条件时，才可以被赋给对应的类型的变量(variable)。</p>
<pre><code>值的类型与变量的类型相同
值的类型与变量的实际类型相同，且其中一个的类型是未命名的类型
变量的类型是一个接口，值实现了接口中方法
值是一个双向的通道(channel)，变量类型也是通道，传递的数据类型相同，并且其中一个的类型是未命名的。
值是内置的数值nil，变量的类型是指针(pointer)、函数(function)、分片(slice)、字典(map)、通道(channel)、接口(interface)
值是一个符合变量的类型要求的常量。
</code></pre>
<h2 id="go支持的类型"><a class="header" href="#go支持的类型">go支持的类型</a></h2>
<h3 id="布尔boolean-types"><a class="header" href="#布尔boolean-types">布尔(Boolean types)</a></h3>
<p>布尔类型是内置的类型<code>bool</code>，它的value只能是两个内置的常量：</p>
<pre><code>true
false
</code></pre>
<h3 id="数值numeric-types"><a class="header" href="#数值numeric-types">数值(Numeric types)</a></h3>
<p>数值类型都是内置的类型，一共有以下几种。</p>
<pre><code>uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32
</code></pre>
<p>另外还有三个数值类型，它们占用的空间取决于实现：</p>
<pre><code>uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
</code></pre>
<h3 id="字符串string-types"><a class="header" href="#字符串string-types">字符串(String types)</a></h3>
<p>字符串是内置的类型<code>string</code>，字符串的值是连续的字节，这些字节是不可更改的。</p>
<p>可以通过内置函数<code>len</code>获取字符串的长度，可以用通过[i]读取字符串的第i个(从0开始)字节。</p>
<p>字符串的字节只能读取，不能更改，也不能取址。</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    str := &quot;Hello World!&quot;
    fmt.Printf(&quot;%c\n&quot;, str[6])

    //not allow
    //ptr := &amp;str[6]

    //not allow
    //str[6] = 'w'
}
</code></pre>
<h3 id="数组array-types"><a class="header" href="#数组array-types">数组(Array types)</a></h3>
<p>数组是多个相同类型的值，在go中，数组必须有长度，长度是数组类型的一部分。</p>
<pre><code>ArrayType   = &quot;[&quot; ArrayLength &quot;]&quot; ElementType .
ArrayLength = Expression .
ElementType = Type .
</code></pre>
<p>数组是单维的，可以累进成多维数组：</p>
<pre><code>[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
</code></pre>
<p>要注意长度是数组类型的一部分，长度不同的数组是不同的类型，例如：</p>
<pre><code>package main

func main() {
    var array1 [32]byte
    var array2 [24]byte

    array1[0] = 'a'
    array2[0] = 'b'

    //not allow
    //array2 = array1
}
</code></pre>
<p>数组成员可以用从0开始的坐标索引，长度可以用内置的函数<code>len</code>获取。</p>
<h3 id="分片slice-types"><a class="header" href="#分片slice-types">分片(Slice types)</a></h3>
<p>分片(Slice)是用来索引数组(Array)中的一段连续的成员的。</p>
<pre><code>SliceType = &quot;[&quot; &quot;]&quot; ElementType .
</code></pre>
<p>分片初始化后就绑定到了一个数组，多个分片可以绑定到同一个数组。</p>
<p>与数组不同的是，分片有长度(length)和容量(capacity)两个属性。</p>
<p>长度是分片所索引的数组成员的数量，可以用内置的函数<code>len</code>获取。</p>
<p>容量是分片能够索引的数组成员的最大数量，等于数组的长度减去分片索引的第一个数组成员在数组中位置。</p>
<p>例如在下面的代码中，分片slice1的长度是5，容量是20(=30-10)</p>
<pre><code>package main

func main() {
    var array1 [30]int
    for i := 0; i &lt; len(array1); i++ {
        array1[i] = i
    }

    slice1 := array1[10:15]

    println(&quot;array's length: &quot;, len(array1))
    println(&quot;slice1's length: &quot;, len(slice1))
    println(&quot;slice1's capacity: &quot;, cap(slice1))

    for i := 0; i &lt; len(slice1); i++ {
        println(slice1[i])
    }
}
</code></pre>
<p>分片可以通过两种方式创建，第一种方式就是上面的代码中使用的方式：</p>
<pre><code>    slice1 := array1[10:15]
</code></pre>
<p>这样创建的slice1索引的是数组的从0开始编号的第10个、第11个、第12个、第13个、第14个个成员，总计5个。</p>
<pre><code>10
11
12
13
14
</code></pre>
<blockquote>
<p>注意[10:15]是一个前闭后开的集合，即包括10，不包括15。</p>
</blockquote>
<p>第二种方式是使用内置的<code>make</code>函数创建。</p>
<pre><code>make([]T, length, capacity)
</code></pre>
<p>使用make创建的时候，至少需要指定分片的长度，make会为分片创建一个隐藏的数组。</p>
<p>如果指定了capacity，数组的长度就是capacity，如果没有指定，数组的长度等于分片的长度。</p>
<p>例如下面的代码中slice2的长度和容量都是10，slice3的长度是10，容量是20。</p>
<pre><code>package main

func main() {
    //not allow
    //slice1 := make([]int)
    //println(&quot;slice1， len is &quot;, len(slice1), &quot;capacity is &quot;, cap(slice1))

    slice2 := make([]int, 10)
    println(&quot;slice2， len is &quot;, len(slice2), &quot;capacity is &quot;, cap(slice2))

    slice3 := make([]int, 10, 20)
    println(&quot;slice3， len is &quot;, len(slice3), &quot;capacity is &quot;, cap(slice3))
}
</code></pre>
<p>通过make创建分片，相当与新建一个数组，然后取它的[0:length]。</p>
<pre><code>make([]int, 50, 100)
</code></pre>
<p>等同于：</p>
<pre><code>new([100]int)[0:50]
</code></pre>
<h3 id="结构体struct-types"><a class="header" href="#结构体struct-types">结构体(Struct types)</a></h3>
<p>结构体(Struct)是比较复杂的类型，它是由多个命名变量组成，这些变量每个都有名字和类型，被成为&quot;结构体成员(field)&quot;。</p>
<pre><code>StructType     = &quot;struct&quot; &quot;{&quot; { FieldDecl &quot;;&quot; } &quot;}&quot; .
FieldDecl      = (IdentifierList Type | AnonymousField) [ Tag ] .
AnonymousField = [ &quot;*&quot; ] TypeName .
Tag            = string_lit .
</code></pre>
<p>go语言的struct用法与C语言中的不同，C语言中是“struct 结构体名{ 结构体成员...}”，go语言中没有中间的结构体名。如果要给go的结构体命名，需要使用关键type：</p>
<pre><code>type 结构体名 struct{
	结构体成员
}
</code></pre>
<p>结构体成员的名称可以显示声明(IdentifierList Type)，也可以隐式声明(AnonymousField)。</p>
<p>隐式声明明是不为变量设置明确的标识符时，变量的名字默认为类型的名字。例如：</p>
<pre><code>struct {
    T1        // field name is T1
    *T2       // field name is T2
    P.T3      // field name is T3
    *P.T4     // field name is T4
    x, y int  // field names are x and y
}
</code></pre>
<p>go语言中的隐式声明的成员，其实有一点C++中的继承的意思，例如在下面的定义中，结构体B可以直接使用它的隐式成员A的结构体成员：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

type A struct {
    A1 string
    A2 string
}

type B struct {
    A
    B1 string
    B2 string
}

func main() {
    b := B{
        A: A{
            A1: &quot;a1&quot;,
            A2: &quot;a2&quot;,
        },
        B1: &quot;b1&quot;,
        B2: &quot;b2&quot;,
    }
    fmt.Println(b.A)
    fmt.Println(b.A.A1)
    fmt.Println(b.A1)
}
</code></pre>
<p>在上面的代码中，结构体B没有显示声明为A1的成员，因此<code>b.A1</code>索引的是它的隐式成员A的成员。</p>
<p>如果结构体B有一个名为A1的显示成员，那么只能通过<code>b.A.A1</code>的方式索引到A的成员A1，<code>b.A</code>索引的将是B的显示成员A1。</p>
<p>例如下面代码中，最后一行打印的是<code>b1's a1</code>。</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

type A struct {
    A1 string
    A2 string
}

type B struct {
    A
    A1 string
    B1 string
    B2 string
}

func main() {
    b := B{
        A: A{
            A1: &quot;a1&quot;,
            A2: &quot;a2&quot;,
        },
        A1: &quot;b's a1&quot;,
        B1: &quot;b1&quot;,
        B2: &quot;b2&quot;,
    }
    fmt.Println(b.A)
    fmt.Println(b.A.A1)
    fmt.Println(b.A1)
}
</code></pre>
<p>同一个结构体内的成员不能重名，在使用隐式声明的时候要特别注意，因为一个类型与它的指针类型，在被隐式声明的时候，会得到相同的变量名。例如下面的结构体的三个成员的名字都是<code>T</code>，这是不允许的。</p>
<pre><code>struct {
    T     // conflicts with anonymous field *T and *P.T
    *T    // conflicts with anonymous field T and *P.T
    *P.T  // conflicts with anonymous field T and *T
}
</code></pre>
<p>隐式声明的<code>T</code>和隐式声明的<code>*T</code>的区别之一是这个隐式声明的变量的存放位置。另外go语言声称：</p>
<pre><code>If S contains an anonymous field T, the method sets of S and *S both include promoted methods with receiver T. The method set of *S also includes promoted methods with receiver *T.

If S contains an anonymous field *T, the method sets of S and *S both include promoted methods with receiver T or *T.
</code></pre>
<p>但是试验却发现，下面的两段代码执行的效果是相同的。</p>
<p>代码一，隐式成员为<code>A</code>：</p>
<pre><code>package main

type A struct {
    A1 string
}

type B struct {
    A
    B1 string
    B2 string
}

func main() {
    b := B{
        A: A{
            A1: &quot;a1&quot;,
        },
        B1: &quot;b1&quot;,
        B2: &quot;b2&quot;,
    }

    b.method()
    println(b.A1)

    b.pointer_method()
    println(b.A1)

    pb := &amp;b

    pb.method()
    println(b.A1)

    pb.pointer_method()
    println(b.A1)
}
</code></pre>
<p>代码二，隐式成员为<code>*A</code>：</p>
<pre><code>package main

type A struct {
    A1 string
}

func (a A) method() {
    a.A1 = &quot;method set a1&quot;
}

func (a *A) pointer_method() {
    a.A1 = &quot;pointer method set a1&quot;
}

type B struct {
    *A
    B1 string
    B2 string
}

func main() {
    b := B{
        A: &amp;A{
            A1: &quot;a1&quot;,
        },
        B1: &quot;b1&quot;,
        B2: &quot;b2&quot;,
    }

    b.method()
    println(b.A1)

    b.pointer_method()
    println(b.A1)

    pb := &amp;b

    pb.method()
    println(b.A1)

    pb.pointer_method()
    println(b.A1)
}
</code></pre>
<p>go语言中可以在每个结构体成员后面跟随一个标签(tag)，标签用来注明成员的属性。标签可以是解释型字符串，也可以是原始型字符串。</p>
<pre><code>Tag            = string_lit .
string_lit     = raw_string_lit | interpreted_string_lit .
</code></pre>
<p>另外，在结构体中还可以添加只起到填充(padding)作用的成员：</p>
<pre><code>// A struct with 6 fields.
struct {
    x, y int
    u float32
    _ float32  // padding
    A *[]int
    F func()
}
</code></pre>
<h3 id="指针pointer-types"><a class="header" href="#指针pointer-types">指针(Pointer types)</a></h3>
<p>指针类型比较简单：</p>
<pre><code>PointerType = &quot;*&quot; BaseType .
BaseType    = Type .
</code></pre>
<p>支持多重指针：</p>
<pre><code>package main

func main() {
    i := 8
    pi := &amp;i
    ppi := &amp;pi

    println(*ppi, pi)
    println(*pi, i)
}
</code></pre>
<h3 id="函数function-types"><a class="header" href="#函数function-types">函数(Function types)</a></h3>
<p>go语言的函数的声明格式与其它语言也有所不同。</p>
<pre><code>FunctionType   = &quot;func&quot; Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = &quot;(&quot; [ ParameterList [ &quot;,&quot; ] ] &quot;)&quot; .
ParameterList  = ParameterDecl { &quot;,&quot; ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ &quot;...&quot; ] Type .
</code></pre>
<p>可以由以下几种样式的函数：</p>
<pre><code>func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
</code></pre>
<p>最显著的不同是，参数的类型是在参数名之后的，如果两个参数类型相同且位置相临，可以省略前一个参数的类型，例如：</p>
<pre><code>func(a, b int, z float32) (bool)
</code></pre>
<p>函数的最后一个参数可以是变长参数(variadic)，可以对应0个到多个输入参数：</p>
<pre><code>func(prefix string, values ...int)
</code></pre>
<p>函数可以有多个返回值：</p>
<pre><code>func(int, int, float64) (float64, *[]int)
</code></pre>
<p>也可以返回函数：</p>
<pre><code>func(n int) func(p *T)
</code></pre>
<p>注意，这里给出的是函数类型，函数类型不等于函数的声明与实现，函数的声明与实现在后面章节中。</p>
<h3 id="接口interface-types"><a class="header" href="#接口interface-types">接口(Interface types)</a></h3>
<p>接口类型的格式如下：</p>
<pre><code>InterfaceType      = &quot;interface&quot; &quot;{&quot; { MethodSpec &quot;;&quot; } &quot;}&quot; .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
</code></pre>
<p>例如：</p>
<pre><code>interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
    Close()
}
</code></pre>
<p>接口的成员是方法(method)，一个类型只要实现一个接口中的所有方法的类型，可以作为类型为该接口的变量的的动态类型。</p>
<p>例如下面的T就实现了上面的接口：</p>
<pre><code>func (p T) Read(b Buffer) bool { return … }
func (p T) Write(b Buffer) bool { return … }
func (p T) Close() { … }
</code></pre>
<p>一个类型可以实现多个接口的方法，也可以是空的，不包含任何的方法：</p>
<pre><code>interface{}
</code></pre>
<p>接口可以包含其它的接口，但是不能包含它自身，或者通过其它接口形成了重复包含：</p>
<pre><code>// illegal: Bad cannot embed itself
type Bad interface {
    Bad
}

// illegal: Bad1 cannot embed itself using Bad2
type Bad1 interface {
    Bad2
}
type Bad2 interface {
    Bad1
}
</code></pre>
<h3 id="字典map-types"><a class="header" href="#字典map-types">字典(Map types)</a></h3>
<p>go语言原生支持字典(map)。</p>
<pre><code>MapType     = &quot;map&quot; &quot;[&quot; KeyType &quot;]&quot; ElementType .
KeyType     = Type .
</code></pre>
<p>Key的类型不能是函数(function)、字典(map)、分片(slice)</p>
<p>如果Key的类型是接口，可以作为该接口变量的动态类型的类型必须是可比较的，否则会panic。</p>
<p>字典中的成员数量成为字典的长度(length)，可以通过内置函数len()获取。</p>
<p>字典的成员可以通过赋值操作增加，用Key作为index读取。</p>
<p>如果要删除字典中的成员，需要使用内置的delete()函数。</p>
<p>map需要使用内置函数make创建:</p>
<pre><code>make(map[string]int)
make(map[string]int, 100)
</code></pre>
<p>创建时指定length意思是，预先分配出可以容纳这么多成员的空间，而不是只能容纳这么多。</p>
<p>map的长度不受创建时指定的length的限制，可以无限增加成员。</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    m := make(map[int]int, 10)
    for i := 0; i &lt; 10; i++ {
        m[i] = i
    }
    println(len(m))
    fmt.Println(m)
    m[11] = 11
    println(len(m))
    fmt.Println(m)
}
</code></pre>
<h3 id="通道channel-types"><a class="header" href="#通道channel-types">通道(Channel types)</a></h3>
<p>通道是用来在并发编程中传递value的。</p>
<pre><code>ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType .
</code></pre>
<p>它可以是可读、可写、既可读又可写的，例如：</p>
<pre><code>chan T          // can be used to send and receive values of type T
chan&lt;- float64  // can only be used to send float64s
&lt;-chan int      // can only be used to receive ints
</code></pre>
<p>&lt;- 是靠左临近的，通道类型本身也开始被传递：</p>
<pre><code>chan&lt;- chan int    // same as chan&lt;- (chan int)
chan&lt;- &lt;-chan int  // same as chan&lt;- (&lt;-chan int)
&lt;-chan &lt;-chan int  // same as &lt;-chan (&lt;-chan int)
chan (&lt;-chan int)
</code></pre>
<p>通道类型的变量必须用内置的make函数创建：</p>
<pre><code>make(chan int, 100)
</code></pre>
<p>第二参数是指定通道中可以缓存的成员的数量，如果没有第二个参数或者第二个参数为0，那么该通道是不做缓存的，必须等对方接收或者写入完成后，才可以完成写入或接收。</p>
<p>通道需要由写入方使用内置的close函数关闭，接收方收取了最后一个数据后，再从通道中试图读取的时候，会立即返回失败。</p>
<p>例如，如果通道c被关闭，且通道中没有数据了，下面的语句将会立即返回，且ok是false。</p>
<pre><code>x, ok := &lt;-c
</code></pre>
<p>通道是并发安全的，使用内置函数len读取通道中缓存的数据个数，或者用cap读取通道容量，不需要考虑并发的影响。</p>
<p>另外通道中的数据遵循先入先出的规则。</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ol>
<li><a href="https://golang.org/ref/spec#Lexical_elements" title="go Lexical elements">go Lexical elements</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../go/chapter02/04-variables.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../go/chapter02/06-declarations.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
                <div style="text-align:center;width:100%">
                    <!--h1>底部相关广告</h1-->
                    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8176866190626448"
                         crossorigin="anonymous"></script>
                    <ins class="adsbygoogle"
                         style="display:block"
                         data-ad-format="autorelaxed"
                         data-ad-client="ca-pub-8176866190626448"
                         data-ad-slot="6443696990"></ins>
                    <script>
                         (adsbygoogle = window.adsbygoogle || []).push({});
                    </script>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../go/chapter02/04-variables.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../go/chapter02/06-declarations.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
