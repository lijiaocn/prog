<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <div style="width:100%;text-align:center">
                  <h2 style="color:#afa790">编程基础</h2>
                  <p style="font-weight:bold"><a style="color:lightgray;" href="https://www.lijiaocn.com">www.lijiaocn.com</a></p>
                </div>
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 笔记说明</a></li><li class="chapter-item expanded "><a href="shell/index.html"><strong aria-hidden="true">2.</strong> Shell 脚本</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="shell/struct.html"><strong aria-hidden="true">2.1.</strong> 变量与数据结构</a></li><li class="chapter-item expanded "><a href="shell/cmd.html"><strong aria-hidden="true">2.2.</strong> 内置命令用法</a></li></ol></li><li class="chapter-item expanded "><a href="c/index.html"><strong aria-hidden="true">3.</strong> C 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c/strings.html"><strong aria-hidden="true">3.1.</strong> 字符串处理</a></li><li class="chapter-item expanded "><a href="c/time.html"><strong aria-hidden="true">3.2.</strong> 时间操作</a></li><li class="chapter-item expanded "><a href="c/dynamiclib.html"><strong aria-hidden="true">3.3.</strong> 动态链接库</a></li><li class="chapter-item expanded "><a href="c/signal.html"><strong aria-hidden="true">3.4.</strong> 信号量操作</a></li><li class="chapter-item expanded "><a href="c/memory.html"><strong aria-hidden="true">3.5.</strong> 内存管理操作</a></li><li class="chapter-item expanded "><a href="c/print.html"><strong aria-hidden="true">3.6.</strong> 格式化打印输出</a></li><li class="chapter-item expanded "><a href="c/file.html"><strong aria-hidden="true">3.7.</strong> 文件&设备操作</a></li><li class="chapter-item expanded "><a href="c/process.html"><strong aria-hidden="true">3.8.</strong> 进程管理操作</a></li><li class="chapter-item expanded "><a href="c/concurrent.html"><strong aria-hidden="true">3.9.</strong> 并发编程</a></li><li class="chapter-item expanded "><a href="c/socket.html"><strong aria-hidden="true">3.10.</strong> socket通信</a></li><li class="chapter-item expanded "><a href="c/filesystem.html"><strong aria-hidden="true">3.11.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="c/sysconfig.html"><strong aria-hidden="true">3.12.</strong> 系统配置</a></li><li class="chapter-item expanded "><a href="c/namespace.html"><strong aria-hidden="true">3.13.</strong> Namespace操作</a></li><li class="chapter-item expanded "><a href="c/hardware.html"><strong aria-hidden="true">3.14.</strong> 硬件信息读取</a></li></ol></li><li class="chapter-item expanded "><a href="go/index.html"><strong aria-hidden="true">4.</strong> Go 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="go/chapter01/01-install.html"><strong aria-hidden="true">4.1.</strong> 安装和文档</a></li><li class="chapter-item expanded "><a href="go/chapter02/00-about.html"><strong aria-hidden="true">4.2.</strong> 基础语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="go/chapter02/02-lexical-elements.html"><strong aria-hidden="true">4.2.1.</strong> 词法</a></li><li class="chapter-item expanded "><a href="go/chapter02/03-constants.html"><strong aria-hidden="true">4.2.2.</strong> 常量</a></li><li class="chapter-item expanded "><a href="go/chapter02/04-variables.html"><strong aria-hidden="true">4.2.3.</strong> 变量</a></li><li class="chapter-item expanded "><a href="go/chapter02/05-types.html"><strong aria-hidden="true">4.2.4.</strong> 类型</a></li><li class="chapter-item expanded "><a href="go/chapter02/06-declarations.html"><strong aria-hidden="true">4.2.5.</strong> 声明</a></li><li class="chapter-item expanded "><a href="go/chapter02/07-expressions.html"><strong aria-hidden="true">4.2.6.</strong> 表达式</a></li><li class="chapter-item expanded "><a href="go/chapter02/08-statements.html"><strong aria-hidden="true">4.2.7.</strong> 语句</a></li><li class="chapter-item expanded "><a href="go/chapter02/10-package.html"><strong aria-hidden="true">4.2.8.</strong> 包声明</a></li></ol></li><li class="chapter-item expanded "><a href="go/chapter02/09-builtin.html"><strong aria-hidden="true">4.3.</strong> 内置函数</a></li><li class="chapter-item expanded "><a href="go/chapter02/11-initialization.html"><strong aria-hidden="true">4.4.</strong> 初始化</a></li><li class="chapter-item expanded "><a href="go/chapter02/12-errors.html"><strong aria-hidden="true">4.5.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="go/chapter02/13-system.html"><strong aria-hidden="true">4.6.</strong> 系统相关</a></li><li class="chapter-item expanded "><a href="go/chapter03/01-cmdline.html"><strong aria-hidden="true">4.7.</strong> 命令行参数</a></li><li class="chapter-item expanded "><a href="go/chapter03/02-log.html"><strong aria-hidden="true">4.8.</strong> 日志打印</a></li><li class="chapter-item expanded "><a href="go/chapter03/convert.html"><strong aria-hidden="true">4.9.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="go/chapter04/01-dependency.html"><strong aria-hidden="true">4.10.</strong> 代码管理</a></li><li class="chapter-item expanded "><a href="go/template/index.html"><strong aria-hidden="true">4.11.</strong> Go Tempalte</a></li><li class="chapter-item expanded "><a href="go/chapter02/99-examples.html"><strong aria-hidden="true">4.12.</strong> 遗留代码片段</a></li><li class="chapter-item expanded "><a href="testframe/ginkgo.html"><strong aria-hidden="true">4.13.</strong> Go 测试框架 GinkGo</a></li></ol></li><li class="chapter-item expanded "><a href="go/article/index.html"><strong aria-hidden="true">5.</strong> Go 语言深入</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="go/article/pkg.html"><strong aria-hidden="true">5.1.</strong> 代码要如何组织?</a></li><li class="chapter-item expanded "><a href="go/article/create_mod.html"><strong aria-hidden="true">5.2.</strong> 多版本依赖功能验证</a></li><li class="chapter-item expanded "><a href="go/article/testcase.html"><strong aria-hidden="true">5.3.</strong> 测试用例的覆盖率</a></li><li class="chapter-item expanded "><a href="go/article/varcopy.html"><strong aria-hidden="true">5.4.</strong> 按值传递的开销很大</a></li><li class="chapter-item expanded "><a href="go/article/waitgroup.html"><strong aria-hidden="true">5.5.</strong> 并发与按值传递血案</a></li><li class="chapter-item expanded "><a href="go/article/debug.html"><strong aria-hidden="true">5.6.</strong> 程序运行时跟踪调试</a></li><li class="chapter-item expanded "><a href="go/article/pprof.html"><strong aria-hidden="true">5.7.</strong> 程序运行时状态查看</a></li><li class="chapter-item expanded "><a href="go/article/unmarshal.html"><strong aria-hidden="true">5.8.</strong> 大量反序列化用指针</a></li></ol></li><li class="chapter-item expanded "><a href="go/gin/index.html"><strong aria-hidden="true">6.</strong> Gin 的原理与学习资料</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="go/gin/quickstart.html"><strong aria-hidden="true">6.1.</strong> 快速开始</a></li><li class="chapter-item expanded "><a href="go/gin/router.html"><strong aria-hidden="true">6.2.</strong> 路由管理</a></li><li class="chapter-item expanded "><a href="go/gin/param.html"><strong aria-hidden="true">6.3.</strong> 参数读取</a></li><li class="chapter-item expanded "><a href="go/gin/response.html"><strong aria-hidden="true">6.4.</strong> 响应数据</a></li></ol></li><li class="chapter-item expanded "><a href="lua/index.html"><strong aria-hidden="true">7.</strong> Lua 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lua/basic_type.html"><strong aria-hidden="true">7.1.</strong> 基本数据类型</a></li><li class="chapter-item expanded "><a href="lua/keywords_operator.html"><strong aria-hidden="true">7.2.</strong> 关键字与操作符</a></li><li class="chapter-item expanded "><a href="lua/control_flow.html"><strong aria-hidden="true">7.3.</strong> 条件语句与循环</a></li><li class="chapter-item expanded "><a href="lua/function.html"><strong aria-hidden="true">7.4.</strong> 函数定义使用</a></li><li class="chapter-item expanded "><a href="lua/module.html"><strong aria-hidden="true">7.5.</strong> 模块定义使用</a></li><li class="chapter-item expanded "><a href="lua/metatable.html"><strong aria-hidden="true">7.6.</strong> 元表定义设置</a></li><li class="chapter-item expanded "><a href="lua/object_oriented.html"><strong aria-hidden="true">7.7.</strong> 面向对象设计</a></li><li class="chapter-item expanded "><a href="lua/01-standard-output.html"><strong aria-hidden="true">7.8.</strong> 标准输出打印</a></li><li class="chapter-item expanded "><a href="lua/02-string-operation.html"><strong aria-hidden="true">7.9.</strong> 字符串操作</a></li><li class="chapter-item expanded "><a href="lua/03-lua-performance.html"><strong aria-hidden="true">7.10.</strong> 性能相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lua/03-lua-performance-local-var.html"><strong aria-hidden="true">7.10.1.</strong> 局部变量比全局变量快30%</a></li><li class="chapter-item expanded "><a href="lua/03-lua-performance-load-dynamic.html"><strong aria-hidden="true">7.10.2.</strong> 动态加载代码非常慢</a></li><li class="chapter-item expanded "><a href="lua/03-lua-performance-table-space.html"><strong aria-hidden="true">7.10.3.</strong> table自动扩容代价很高</a></li><li class="chapter-item expanded "><a href="lua/03-lua-performance-table-space-1.html"><strong aria-hidden="true">7.10.4.</strong> 清理table成员不会触发rehash</a></li><li class="chapter-item expanded "><a href="lua/03-lua-performance-string.html"><strong aria-hidden="true">7.10.5.</strong> 慎用字符串拼接</a></li><li class="chapter-item expanded "><a href="lua/03-lua-performance-less-var.html"><strong aria-hidden="true">7.10.6.</strong> 尽量少创建变量</a></li><li class="chapter-item expanded "><a href="lua/03-lua-performance-cache-result.html"><strong aria-hidden="true">7.10.7.</strong> 缓存运算结果</a></li><li class="chapter-item expanded "><a href="lua/03-lua-performance-garbage-collect.html"><strong aria-hidden="true">7.10.8.</strong> 主动控制垃圾回收</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="python3/index.html"><strong aria-hidden="true">8.</strong> Python3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="python3/2to3.html"><strong aria-hidden="true">8.1.</strong> python2 代码转换成 python3</a></li><li class="chapter-item expanded "><a href="python3/project.html"><strong aria-hidden="true">8.2.</strong> 运行环境与依赖管理</a></li><li class="chapter-item expanded "><a href="python3/syntax.html"><strong aria-hidden="true">8.3.</strong> 代码文件</a></li><li class="chapter-item expanded "><a href="python3/struct.html"><strong aria-hidden="true">8.4.</strong> 基本类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="python3/list.html"><strong aria-hidden="true">8.4.1.</strong> list</a></li><li class="chapter-item expanded "><a href="python3/tuple.html"><strong aria-hidden="true">8.4.2.</strong> tuple</a></li><li class="chapter-item expanded "><a href="python3/set.html"><strong aria-hidden="true">8.4.3.</strong> set</a></li><li class="chapter-item expanded "><a href="python3/dictionary.html"><strong aria-hidden="true">8.4.4.</strong> dictionary</a></li></ol></li><li class="chapter-item expanded "><a href="python3/string.html"><strong aria-hidden="true">8.5.</strong> 字符串处理</a></li><li class="chapter-item expanded "><a href="python3/time.html"><strong aria-hidden="true">8.6.</strong> 时间处理</a></li><li class="chapter-item expanded "><a href="python3/num.html"><strong aria-hidden="true">8.7.</strong> 数值处理</a></li><li class="chapter-item expanded "><a href="python3/builtin.html"><strong aria-hidden="true">8.8.</strong> 内置函数</a></li><li class="chapter-item expanded "><a href="python3/scope.html"><strong aria-hidden="true">8.9.</strong> 变量作用域</a></li><li class="chapter-item expanded "><a href="python3/params.html"><strong aria-hidden="true">8.10.</strong> 参数读取</a></li><li class="chapter-item expanded "><a href="python3/module.html"><strong aria-hidden="true">8.11.</strong> 模块用法</a></li><li class="chapter-item expanded "><a href="python3/package.html"><strong aria-hidden="true">8.12.</strong> 包用法</a></li><li class="chapter-item expanded "><a href="python3/format.html"><strong aria-hidden="true">8.13.</strong> 格式化输出</a></li><li class="chapter-item expanded "><a href="python3/file.html"><strong aria-hidden="true">8.14.</strong> 文件读写</a></li><li class="chapter-item expanded "><a href="python3/error.html"><strong aria-hidden="true">8.15.</strong> 错误和异常</a></li><li class="chapter-item expanded "><a href="python3/class.html"><strong aria-hidden="true">8.16.</strong> 类</a></li><li class="chapter-item expanded "><a href="python3/generator.html"><strong aria-hidden="true">8.17.</strong> 生成器</a></li></ol></li><li class="chapter-item expanded "><a href="py3spider/index.html"><strong aria-hidden="true">9.</strong> Python3 爬虫开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="py3spider/request.html"><strong aria-hidden="true">9.1.</strong> Python3 请求库</a></li><li class="chapter-item expanded "><a href="py3spider/parse.html"><strong aria-hidden="true">9.2.</strong> Python3 解析库</a></li><li class="chapter-item expanded "><a href="py3spider/mobile.html"><strong aria-hidden="true">9.3.</strong> 移动 APP 工具</a></li><li class="chapter-item expanded "><a href="py3spider/framework.html"><strong aria-hidden="true">9.4.</strong> Python3 爬虫框架</a></li></ol></li><li class="chapter-item expanded "><a href="django/index.html"><strong aria-hidden="true">10.</strong> Django 开发手册</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="django/install.html"><strong aria-hidden="true">10.1.</strong> 环境安装</a></li><li class="chapter-item expanded "><a href="django/first-project.html"><strong aria-hidden="true">10.2.</strong> 项目的创建</a></li><li class="chapter-item expanded "><a href="django/first-app.html"><strong aria-hidden="true">10.3.</strong> 应用的创建</a></li><li class="chapter-item expanded "><a href="django/database.html"><strong aria-hidden="true">10.4.</strong> 对接数据库</a></li><li class="chapter-item expanded "><a href="django/database-init.html"><strong aria-hidden="true">10.5.</strong> 数据库初始化</a></li><li class="chapter-item expanded "><a href="django/database-usage.html"><strong aria-hidden="true">10.6.</strong> 数据库查询写入</a></li><li class="chapter-item expanded "><a href="django/database-shell.html"><strong aria-hidden="true">10.7.</strong> 命令行操作数据库</a></li><li class="chapter-item expanded "><a href="django/admin.html"><strong aria-hidden="true">10.8.</strong> 使用后台管理页面</a></li><li class="chapter-item expanded "><a href="django/views.html"><strong aria-hidden="true">10.9.</strong> views 的开发</a></li><li class="chapter-item expanded "><a href="django/generic_views.html"><strong aria-hidden="true">10.10.</strong> 使用 Generic Views</a></li><li class="chapter-item expanded "><a href="django/test.html"><strong aria-hidden="true">10.11.</strong> 编写测试代码</a></li><li class="chapter-item expanded "><a href="django/static.html"><strong aria-hidden="true">10.12.</strong> 页面模版中引入静态资源</a></li><li class="chapter-item expanded "><a href="django/input.html"><strong aria-hidden="true">10.13.</strong> 传入参数的获取</a></li><li class="chapter-item expanded "><a href="django/log.html"><strong aria-hidden="true">10.14.</strong> 日志管理</a></li><li class="chapter-item expanded "><a href="django/global_setting.html"><strong aria-hidden="true">10.15.</strong> 项目的全局设置</a></li><li class="chapter-item expanded "><a href="django/problems.html"><strong aria-hidden="true">10.16.</strong> 问题记录</a></li><li class="chapter-item expanded "><a href="django/idea_usage.html"><strong aria-hidden="true">10.17.</strong> IDEA 远程调试 python</a></li><li class="chapter-item expanded "><a href="django/package.html"><strong aria-hidden="true">10.18.</strong> 使用自定义的 Package</a></li><li class="chapter-item expanded "><a href="django/deploy.html"><strong aria-hidden="true">10.19.</strong> 用WSGI方式部署Django服务</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="django/deploy_apache.html"><strong aria-hidden="true">10.19.1.</strong> 在Apache中部署Django应用</a></li></ol></li><li class="chapter-item expanded "><a href="django/redis_cache.html"><strong aria-hidden="true">10.20.</strong> 引入redis缓存</a></li><li class="chapter-item expanded "><a href="django/import-django.html"><strong aria-hidden="true">10.21.</strong> 导入django环境</a></li></ol></li><li class="chapter-item expanded "><a href="android/start.html"><strong aria-hidden="true">11.</strong> Android</a></li><li class="chapter-item expanded "><a href="vue/start.html"><strong aria-hidden="true">12.</strong> Vue</a></li><li class="chapter-item expanded "><a href="wechat/index.html"><strong aria-hidden="true">13.</strong> 微信公众号 API 使用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="wechat/shezhi.html"><strong aria-hidden="true">13.1.</strong> 设置方法</a></li><li class="chapter-item expanded "><a href="wechat/message.html"><strong aria-hidden="true">13.2.</strong> 消息格式</a></li><li class="chapter-item expanded "><a href="wechat/debug.html"><strong aria-hidden="true">13.3.</strong> 接口调试</a></li></ol></li><li class="chapter-item expanded "><a href="taobaoke/index.html"><strong aria-hidden="true">14.</strong> 淘宝客 API 使用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="taobaoke/kaitong.html"><strong aria-hidden="true">14.1.</strong> 开通方法</a></li><li class="chapter-item expanded "><a href="taobaoke/sdk.html"><strong aria-hidden="true">14.2.</strong> SDK下载</a></li><li class="chapter-item expanded "><a href="taobaoke/api.html"><strong aria-hidden="true">14.3.</strong> 接口梳理</a></li><li class="chapter-item expanded "><a href="taobaoke/api_call.html"><strong aria-hidden="true">14.4.</strong> 接口调用</a></li></ol></li></ol>
               <div style="width:100%;text-align:center">
                  <img style="width:100%" src="https://www.lijiaocn.com/img/ercode/cur.jpg"/>
               </div>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div style="text-align:center;width:100%">
                    <!--h1>顶部条幅广告</h1-->
                    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8176866190626448"
                     crossorigin="anonymous"></script>
                     <!-- 顶部条幅广告 -->
                    <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-8176866190626448"
                     data-ad-slot="1000173679"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
                     <script>
                     (adsbygoogle = window.adsbygoogle || []).push({});
                     </script>
                </div>

                <div id="content" class="content">
                    <main>
                        <h1 id="编程语言手册"><a class="header" href="#编程语言手册">编程语言手册</a></h1>
<p>该手册的目的是在长时间不接触某一门语言后，能够通过该手册快速回想起基本的语法和用法。</p>
<p>工作过程中接触到什么编程语言，就记录什么语言的内容，文档结构和内容在持续优化中。</p>
<p>👈 从左侧目录开始阅读。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="bash-脚本语法"><a class="header" href="#bash-脚本语法">Bash 脚本语法</a></h1>
<p>这里记录 Shell 脚本的用法，主要是 bash。</p>
<p>学习资料：</p>
<ul>
<li><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2014/01/08/shell-usage.html" title="Shell(bash)编程">Shell(bash)编程</a></li>
<li><a href="http://man7.org/linux/man-pages/man1/bash.1.html" title="bash - GNU Bourne-Again SHell">bash - GNU Bourne-Again SHell</a></li>
</ul>
<h2 id="bash-的命令行参数"><a class="header" href="#bash-的命令行参数">bash 的命令行参数</a></h2>
<pre><code class="language-sh">-c &quot;ls&quot;   : 执行字符串中的命令
--        : 命令行参数结束符
</code></pre>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="bash-的变量与数据结构"><a class="header" href="#bash-的变量与数据结构">Bash 的变量与数据结构</a></h1>
<p>主要学习资料： <a href="http://man7.org/linux/man-pages/man1/bash.1.html" title="bash - GNU Bourne-Again SHell">bash - GNU Bourne-Again SHell</a>。</p>
<h2 id="编程常用操作"><a class="header" href="#编程常用操作">编程常用操作</a></h2>
<h3 id="用-read-实现多变量赋值"><a class="header" href="#用-read-实现多变量赋值">用 read 实现多变量赋值</a></h3>
<p>用下面的命令可以同时定义多个变量，并赋值：</p>
<pre><code class="language-sh">read a b c &lt;&lt;&lt; &quot;1 2 3&quot;;echo &quot;$a|$b|$c&quot;
</code></pre>
<p>参考：<a href="https://codeday.me/bug/20170709/39537.html">Linux bash：多个变量赋值</a></p>
<h3 id="读取命令行参数"><a class="header" href="#读取命令行参数">读取命令行参数</a></h3>
<h4 id="内置命令-getopts"><a class="header" href="#内置命令-getopts">内置命令 getopts</a></h4>
<p>最新代码 <a href="https://github.com/lijiaocn/workspace/blob/master/studys/study-shell/cmdline/getopts.sh">getopts.sh</a>。</p>
<p>用 getopts 解析命令行参数，getopts 不支持长格式，只能用 <code>-h</code> 这样的短格式：</p>
<pre><code class="language-sh">while getopts &quot;p:h:&quot; option ;do
    if [[ $option == &quot;p&quot; ]];then
        echo &quot;listener port: $OPTARG&quot;
    fi
    if [[ $option == &quot;h&quot; ]];then
        read name value &lt;&lt;&lt; &quot;${OPTARG//:/ }&quot;;
        headers=&quot;$headers\nproxy_set_header $name $value;&quot;
    fi
done

echo $headers
</code></pre>
<p>执行效果如下：</p>
<pre><code class="language-sh">$ ./getopts.sh -p 80 -h h1:v1 -h h2:v2
listener port: 80

proxy_set_header h1 v1;
proxy_set_header h2 v2;
</code></pre>
<h3 id="用遍历参数的方式实现"><a class="header" href="#用遍历参数的方式实现">用遍历参数的方式实现</a></h3>
<p>最新代码 <a href="https://github.com/lijiaocn/workspace/blob/master/studys/study-shell/cmdline/loop.sh">loop.sh</a>。 </p>
<pre><code class="language-sh">#! /bin/sh
#
# loop.sh
# Copyright (C) 2019 lijiaocn &lt;lijiaocn@foxmail.com wechat:lijiaocn&gt;
#
# Distributed under terms of the GPL license.
#

function help(){
	echo &quot;usage: $0 [-f file] [-n name] [arguments...]&quot;
}

while :; do
	case $1 in
		-h|-\?|--help)
			help
			exit
			;;
		-f|--file)
			if [[ $2 == &quot;&quot; || ${2:0:1} == &quot;-&quot; ]];then
				echo 'ERROR: &quot;--file&quot; requires a non-empty option argument.' 2&gt;&amp;1
				exit 1
			fi
			file=$2
			shift
			;;
		-n|--name)
			if [[ $2 == &quot;&quot; || ${2:0:1} == &quot;-&quot; ]];then
				echo 'ERROR: &quot;--name&quot; requires a non-empty option argument.' 2&gt;&amp;1
				exit 1
			fi
			name=$2
			shift
			;;
		-|--)
			shift
			break
			;;
		*)
			break
			;;
	esac
	shift
done

echo &quot;file is: $file&quot;
echo &quot;name is: $name&quot;
echo &quot;arguments: $*&quot;
</code></pre>
<p>一个复杂一些的示例：<a href="https://github.com/lijiaocn/containers/blob/master/docker-nginx-tranproxy/entrypoint.sh#L81">docker-nginx-tranproxy/entrypoint.sh</a></p>
<h2 id="变量值读取"><a class="header" href="#变量值读取">变量值读取</a></h2>
<p>Bash 的变量值读取支持很多扩展方式（Parameter Expansion）。</p>
<h3 id="未定义变量"><a class="header" href="#未定义变量">未定义变量</a></h3>
<p>针对变量是否定义，存在以下几种处理方法：</p>
<pre><code class="language-sh">${parameter:-word}:  如果变量没有定义或者 null，返回默认值 word
${parameter:=word}:  如果变量没有定义或者 null，为变量赋值 word，并返回 word
${parameter:?word}:  如果变量没有定义或者 null，在错误输出中显示 word
${parameter:+word}:  如果定义变量，注意是是定义了！用 word 替代（返回 word）
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">echo &quot;未定义的变量，使用默认值：${notdef1:-word}  $notdef1&quot;
echo &quot;未定义的变量，赋值默认值：${notdef2:=word}  $notdef2&quot;
echo &quot;已定义的变量，使用替代数值：${notdef2:+valueinstead}&quot;
echo &quot;未定义的变量，打印错误信息：${notdef3:?notdef}&quot;
</code></pre>
<p>执行结果为：</p>
<pre><code class="language-sh">未定义的变量，使用默认值：word
未定义的变量，赋值默认值：word  word
已定义的变量，使用替代数值：valueinstead
./variable.sh: line 13: notdef3: notdef
</code></pre>
<h3 id="字符串处理"><a class="header" href="#字符串处理">字符串处理</a></h3>
<p>如果变量的值是字符串，在读取时可以直接进行处理。</p>
<p>下面的用法对非字符串变量也可以使用，譬如<code>@</code>和<code>*</code>，譬如数组，操作含义也相应变化，变量为字符串时，这些操作的含义是最好理解的：</p>
<pre><code class="language-sh">${parameter:offset}         :第一个字符以后的字符，不包括第一个
${parameter:offset:length}  :第一个字符以后的两个字符，不包括第一个

 :如果变量是 @，显示从 offset 开始的 length 个命令行参数
 :如果变量是 Array[@] 或 Array[*] ，显示从 offset 开始的 length 个数组成员

${#parameter}               :字符串长度

 :如果变量是 @ 或 *，返回命令行参数个数
 :如果变量是 Array[@] 或 Array[*]，返回数组的成员数量

${parameter#word}           :从字符串头开始，去掉 word 匹配的部分，最短匹配
${parameter##word}          :从字符串头开始，去掉 word 匹配的部分，最长匹配
${parameter%word}           :从字符串尾开始，去掉 word 匹配的部分，最短匹配
${parameter%%word}          :从字符串尾开始，去掉 word 匹配的部分，最长匹配
${parameter/pattern/string} :字符后换，默认只替换第一个
                             pattern 以 &quot;/&quot; 开头，全替换
                             pattern 以 &quot;#&quot; 开头，从首字母开始匹配
                             pattern 以 &quot;%&quot; 开头，从尾字母开始匹配

 :如果变量是 @ 或 *，对所有命令行参数进行处理，返回处理后的列表
 :如果变量是 Array[@] 或 Array[*]，对数组所有成员进行处理，返回处理后的列表
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">str=&quot;abcddeddfghijka&quot;

echo &quot;第0个字符后: ${str:0}&quot;
echo &quot;第1个字符后: ${str:1}&quot;
echo &quot;第1个字符后的两个字符: ${str:1:2}&quot;

echo &quot;字符串长度：${#str}&quot;

echo &quot;head match #abc: ${str#abc}&quot;
echo &quot;head match ##abc: ${str##abc}&quot;

echo &quot;head match #abc*: ${str#abc*}&quot;
echo &quot;head match ##abc*: ${str##abc*}&quot;

echo &quot;tail match %ijk: ${str%ijk}&quot;
echo &quot;tail match %%ijk: ${str%%ijk}&quot;

echo &quot;tail match %*ijk: ${str%*ijk}&quot;
echo &quot;tail match %%*ijk: ${str%%*ijk}&quot;

echo &quot;replace /d/D（替换一个）: ${str/d/D}&quot;
echo &quot;replace //d/D（全部替换）: ${str//d/D}&quot;
echo &quot;replace /#a/A（从开始处匹配替换）: ${str/#a/A}&quot;
echo &quot;replace /%a/A（从结尾处匹配替换）: ${str/%a/A}&quot;
</code></pre>
<p>执行结果为：</p>
<pre><code class="language-sh">第0个字符后: abcddeddfghijka
第1个字符后: bcddeddfghijka
第1个字符后的两个字符: bc
字符串长度：15
head match #abc: ddeddfghijka
head match ##abc: ddeddfghijka
head match #abc*: ddeddfghijka
head match ##abc*:
tail match %ijk: abcddeddfghijka
tail match %%ijk: abcddeddfghijka
tail match %*ijk: abcddeddfghijka
tail match %%*ijk: abcddeddfghijka
replace /d/D（替换一个）: abcDdeddfghijka
replace //d/D（全部替换）: abcDDeDDfghijka
replace /#a/A（从开始处匹配替换）: Abcddeddfghijka
replace /%a/A（从结尾处匹配替换）: abcddeddfghijkA
</code></pre>
<h3 id="读取变量名"><a class="header" href="#读取变量名">读取变量名</a></h3>
<p>注意读取的是变量的名字，不是变量值，</p>
<pre><code class="language-sh">${!prefix*}，${!prefix@}: 返回以 prefix 为前缀的已经定义的变量名
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">prefixV1=&quot;a&quot;
prefixV2=&quot;b&quot;
prefixV3=&quot;c&quot;

echo ${!prefix*}
echo ${!prefix@}
</code></pre>
<p>执行结果为：</p>
<pre><code class="language-sh">prefixV1 prefixV2 prefixV3
prefixV1 prefixV2 prefixV3
</code></pre>
<h3 id="读取数组信息"><a class="header" href="#读取数组信息">读取数组信息</a></h3>
<p>见数组章节。</p>
<pre><code class="language-sh">${!name[@]}，${!name[*]}：读取数组的 key 值
</code></pre>
<h2 id="数组"><a class="header" href="#数组">数组</a></h2>
<p>使用下面的形式赋予值时，会自动创建数组变量：</p>
<pre><code class="language-sh">array[&quot;0&quot;]=&quot;value0&quot;
array[&quot;1&quot;]=&quot;value1&quot;
array[&quot;2&quot;]=&quot;value2&quot;
array[&quot;5&quot;]=&quot;value5&quot;
</code></pre>
<p>如果要声明一个数组类型的变量，用 declare -a 声明：</p>
<pre><code class="language-sh"># 声明数组变量 array
declare -a array
</code></pre>
<p>用下面的方式生成一个带有值数组变量：</p>
<pre><code class="language-sh">array=(&quot;value0&quot; &quot;value1&quot; &quot;value2&quot; &quot;value3&quot;)
</code></pre>
<p>读取数组中指定位置的值：</p>
<pre><code class="language-sh">echo ${array[1]}
</code></pre>
<p>读取数组的信息：</p>
<pre><code class="language-sh"># 打印数组中的所有值
for i in ${array[@]}
do
    echo &quot;data: $i&quot;
done

# 打印数组中有值的 index
for i in ${!array[@]}
do
    echo &quot;index: $i&quot;
done

# 打印数组内元素个数
echo &quot;array size: ${#array[@]}&quot;
</code></pre>
<h2 id="参考-1"><a class="header" href="#参考-1">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="常用的-bash-内置的命令"><a class="header" href="#常用的-bash-内置的命令">常用的 Bash 内置的命令</a></h1>
<p>Bash 有很多内置命令，譬如 <code>:</code>、<code>.</code>、<code>source</code>、<code>alias</code>、<code>bg</code> 等。</p>
<h2 id="trap"><a class="header" href="#trap">trap</a></h2>
<p>设置信号处理函数，信号发生后，触发函数的执行。</p>
<p>除了支持 <code>man signal</code> 中列出的 32 个系统信号，还支持 DEBUG、ERR、EXIT，分别在每个命令执行前后触发、出错时触发、退出时触发。</p>
<pre><code class="language-sh">function debug {
   echo &quot;DEBUG&quot;
}
trap debug DEBUG

function err {
   echo &quot;ERR&quot;
}
trap err ERR

function cleanup {
   echo &quot;EXIT&quot;
}
trap cleanup EXIT

echo &quot;exec command...&quot;
ls /noexit
</code></pre>
<p>执行结果如下：</p>
<pre><code class="language-sh">DEBUG
DEBUG
DEBUG
exec command...
DEBUG
ls: /noexit: No such file or directory
DEBUG
ERR
DEBUG
EXIT
</code></pre>
<h2 id="参考-2"><a class="header" href="#参考-2">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c语言速查手册"><a class="header" href="#c语言速查手册">C语言速查手册</a></h1>
<p>C语言编程（这里特指linux c）中，最常用的资料是man手册和头文件。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="c语言中的字符串操作"><a class="header" href="#c语言中的字符串操作">C语言中的字符串操作</a></h1>
<p>编程过程中，如果不是在处理数值，就是在处理字符串。  by me ...</p>
<h2 id="字符串长度"><a class="header" href="#字符串长度">字符串长度</a></h2>
<p><code>man strlen</code>、<code>man strnlen</code></p>
<pre><code class="language-c">#include &lt;string.h&gt;

size_t strlen(const char *s);
size_t strnlen(const char *s, size_t maxlen);
</code></pre>
<p><code>man wcslen</code>、<code>man wcsnlen</code></p>
<pre><code class="language-c">#include &lt;wchar.h&gt;

size_t wcslen(const wchar_t *s);
size_t wcsnlen(const wchar_t *s, size_t maxlen);
</code></pre>
<h2 id="字符串比较"><a class="header" href="#字符串比较">字符串比较</a></h2>
<p><code>man strcmp</code></p>
<pre><code class="language-c">#include &lt;string.h&gt;

int strcmp(const char *s1, const char *s2);

int strncmp(const char *s1, const char *s2, size_t n);
</code></pre>
<h2 id="字符串复制"><a class="header" href="#字符串复制">字符串复制</a></h2>
<p><code>man strdup</code></p>
<pre><code class="language-c">#include &lt;string.h&gt;

char *strdup(const char *s);

char *strndup(const char *s, size_t n);
char *strdupa(const char *s);
char *strndupa(const char *s, size_t n);
</code></pre>
<p>注意返回的是一个指针，指针指向的内存是用malloc函数分配的，不再使用的时候需要调用free函数释放。</p>
<h2 id="按照指定的分隔符将字符串分割"><a class="header" href="#按照指定的分隔符将字符串分割">按照指定的分隔符，将字符串分割</a></h2>
<p><code>man strtok</code></p>
<pre><code class="language-c">#include &lt;string.h&gt;

char *strtok(char *str, const char *delim);

char *strtok_r(char *str, const char *delim, char **saveptr);
</code></pre>
<p><strong>注意</strong>：</p>
<ol>
<li>strtok是线程不安全的，线程安全需要使用strtok_r。</li>
<li>传入的字符串的内容会被改写，用<code>\0</code>分割成了多个token，如果需要保留原先字符串，需要复制保留。</li>
</ol>
<p>示例1：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[])
{
    char str[100];
    sprintf(str,&quot;a b c d e f&quot;);
    char *delim = &quot; &quot;;
    char *token = NULL;

    token = strtok(str, delim);
    while (NULL != token) {
        printf(&quot;%s\n&quot;, token);
        token = strtok(NULL, delim);
    }

    return 0;
}
</code></pre>
<p>示例2:</p>
<pre><code class="language-c">/*
 * main.c
 * Copyright (C) 2019 lijiaocn &lt;lijiaocn@foxmail.com&gt;
 *
 * Distributed under terms of the GPL license.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define str_iterate_parts(__iterator, __splitme, __separators)            \
    for (char *__p = NULL, *__it = strtok_r(__splitme, __separators, &amp;__p); \
            (__iterator = __it);                                            \
            __iterator = __it = strtok_r(NULL, __separators, &amp;__p))

int main(int argc, char *argv[])
{
	char str[100];
	sprintf(str,&quot;a b c d e f&quot;);
	printf(&quot;before: %s\n&quot;, str);
	char *delim = &quot; &quot;;
	char *token = NULL;
	char *saveptr = NULL;

/*
	token = strtok_r(str, delim, &amp;saveptr);
	while (NULL != token) {
		printf(&quot;%s\n&quot;, token);
		token = strtok_r(NULL, delim, &amp;saveptr);
	}
*/

	int i = 0;
	str_iterate_parts(token, str, delim){
		if (i &gt;= 3 ) break;
		printf(&quot;%s\n&quot;, token);
		i++;
	}
	printf(&quot;after : %s\n&quot;, str);

	return 0;
}
</code></pre>
<h2 id="定位指定字符"><a class="header" href="#定位指定字符">定位指定字符</a></h2>
<pre><code class="language-c">#include &lt;string.h&gt;

char *strchr(const char *s, int c);

char *strrchr(const char *s, int c);

#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &lt;string.h&gt;

char *strchrnul(const char *s, int c);
</code></pre>
<h2 id="定位子字符串"><a class="header" href="#定位子字符串">定位子字符串</a></h2>
<pre><code class="language-c">#include &lt;string.h&gt;

char *strstr(const char *haystack, const char *needle);

#define _GNU_SOURCE         /* See feature_test_macros(7) */

#include &lt;string.h&gt;

char *strcasestr(const char *haystack, const char *needle);
</code></pre>
<h2 id="输入字符串转换"><a class="header" href="#输入字符串转换">输入字符串转换</a></h2>
<p><code>man scanf</code> </p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);

#include &lt;stdarg.h&gt;

int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);
</code></pre>
<p>fscanf和sscanf可能有妙用。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="c语言中的时间操作"><a class="header" href="#c语言中的时间操作">C语言中的时间操作</a></h1>
<h2 id="获取当前时间"><a class="header" href="#获取当前时间">获取当前时间</a></h2>
<p>获取<code>相对指定时钟</code>的当前时间：</p>
<p><code>man clock_gettime</code></p>
<pre><code class="language-c">#include &lt;time.h&gt;

int clock_getres(clockid_t clk_id, struct timespec *res);

int clock_gettime(clockid_t clk_id, struct timespec *tp);

int clock_settime(clockid_t clk_id, const struct timespec *tp);

Link with -lrt (only for glibc versions before 2.17).
</code></pre>
<p><code>*res</code>是返回的当前时间，定义如下：</p>
<pre><code class="language-c">struct timespec {
    time_t   tv_sec;        /* seconds */
    long     tv_nsec;       /* nanoseconds */
};
</code></pre>
<p>时钟<code>clk_id</code>可以取以下值：</p>
<p>CLOCK_REALTIME：</p>
<pre><code>   System-wide  clock  that  measures  real  (i.e., wall-clock) time.  Setting this clock requires
   appropriate privileges.  This clock is affected by  discontinuous  jumps  in  the  system  time
   (e.g.,  if the system administrator manually changes the clock), and by the incremental adjust‐
   ments performed by adjtime(3) and NTP.
</code></pre>
<p>CLOCK_REALTIME_COARSE (since Linux 2.6.32; Linux-specific)：</p>
<pre><code>   A faster but less precise version of CLOCK_REALTIME.  Use when you  need  very  fast,  but  not
   fine-grained timestamps.
</code></pre>
<p>CLOCK_MONOTONIC：</p>
<pre><code>   Clock  that  cannot be set and represents monotonic time since some unspecified starting
   point.  This clock is not affected by discontinuous jumps in the system time  (e.g.,  if
   the system administrator manually changes the clock), but is affected by the incremental
   adjustments performed by adjtime(3) and NTP.
</code></pre>
<p>CLOCK_MONOTONIC_COARSE (since Linux 2.6.32; Linux-specific)：</p>
<pre><code>   A faster but less precise version of CLOCK_MONOTONIC.  Use when you need very fast,  but
   not fine-grained timestamps.
</code></pre>
<p>CLOCK_MONOTONIC_RAW (since Linux 2.6.28; Linux-specific)：</p>
<pre><code>   Similar to CLOCK_MONOTONIC, but provides access to a raw hardware-based time that is not
   subject to NTP adjustments or the incremental adjustments performed by adjtime(3).
</code></pre>
<p>CLOCK_BOOTTIME (since Linux 2.6.39; Linux-specific)：</p>
<pre><code>   Identical to CLOCK_MONOTONIC, except it also includes any time that the system  is  sus‐
   pended.   This allows applications to get a suspend-aware monotonic clock without having
   to deal with the complications of CLOCK_REALTIME, which may have discontinuities if  the
   time is changed using settimeofday(2).
</code></pre>
<p>CLOCK_PROCESS_CPUTIME_ID：</p>
<pre><code>   High-resolution per-process timer from the CPU.
</code></pre>
<p>CLOCK_THREAD_CPUTIME_ID：</p>
<pre><code>   Thread-specific CPU-time clock.
</code></pre>
<p>其中<code>CLOCK_BOOTTIME</code>可以简单理解为系统启动以后过去的时间，<a href="https://lwn.net/Articles/420142/">Introduce CLOCK_BOOTTIME </a>。</p>
<h2 id="获取指定进程的启动时间和运行时长"><a class="header" href="#获取指定进程的启动时间和运行时长">获取指定进程的启动时间和运行时长</a></h2>
<p><a href="https://github.com/lxc/lxcfs">lxcfs</a>中的做法，适用于linux。</p>
<p><code>/proc/[PID]/stat</code>文件的第22个字段是进程创建时间，单位是系统时钟嘀嗒数：</p>
<pre><code>starttime %llu (was %lu before Linux 2.6)
    (22)  The  time  the process started after system boot.  In kernels before Linux 2.6, this value was expressed in jiffies.  
    Since Linux 2.6, the value is expressed in clock ticks (divide by sysconf(_SC_CLK_TCK)).
</code></pre>
<p>将其取出后除以系统的时钟频率，得到的就是以秒为单位的启动时间，这个时间是相对于系统启动时间的，实现如下：</p>
<pre><code class="language-c">static uint64_t get_reaper_start_time_in_sec(pid_t pid)
{
    uint64_t clockticks;
    int64_t ticks_per_sec;

    clockticks = get_reaper_start_time(pid);
    if (clockticks == 0 &amp;&amp; errno == EINVAL) {
        lxcfs_debug(&quot;failed to retrieve start time of pid %d\n&quot;, pid);
        return 0;
    }

    ticks_per_sec = sysconf(_SC_CLK_TCK);
    if (ticks_per_sec &lt; 0 &amp;&amp; errno == EINVAL) {
        lxcfs_debug(
            &quot;%s\n&quot;,
            &quot;failed to determine number of clock ticks in a second&quot;);
        return 0;
    }

    return (clockticks /= ticks_per_sec);
}
</code></pre>
<p>函数<code>sysconf()</code>的用法见：<a href="https://www.lijiaocn.com/programming/chapter-c/sysconfig.html#sysconf">系统配置-&gt;sysconf</a>。</p>
<p><code>/proc/[PID]/stat</code>文件的第22个字段的读取方法：</p>
<pre><code class="language-c">static uint64_t get_reaper_start_time(pid_t pid)
{
    int ret;
    FILE *f;
    uint64_t starttime;
    /* strlen(&quot;/proc/&quot;) = 6
     * +
     * LXCFS_NUMSTRLEN64
     * +
     * strlen(&quot;/stat&quot;) = 5
     * +
     * \0 = 1
     * */
#define __PROC_PID_STAT_LEN (6 + LXCFS_NUMSTRLEN64 + 5 + 1)
    char path[__PROC_PID_STAT_LEN];
    pid_t qpid;

    qpid = lookup_initpid_in_store(pid);
    if (qpid &lt;= 0) {
        /* Caller can check for EINVAL on 0. */
        errno = EINVAL;
        return 0;
    }

    ret = snprintf(path, __PROC_PID_STAT_LEN, &quot;/proc/%d/stat&quot;, qpid);
    if (ret &lt; 0 || ret &gt;= __PROC_PID_STAT_LEN) {
        /* Caller can check for EINVAL on 0. */
        errno = EINVAL;
        return 0;
    }

    f = fopen(path, &quot;r&quot;);
    if (!f) {
        /* Caller can check for EINVAL on 0. */
        errno = EINVAL;
        return 0;
    }

    /* Note that the *scanf() argument supression requires that length
     * modifiers such as &quot;l&quot; are omitted. Otherwise some compilers will yell
     * at us. It's like telling someone you're not married and then asking
     * if you can bring your wife to the party.
     */
    ret = fscanf(f, &quot;%*d &quot;      /* (1)  pid         %d   */
            &quot;%*s &quot;      /* (2)  comm        %s   */
            &quot;%*c &quot;      /* (3)  state       %c   */
            &quot;%*d &quot;      /* (4)  ppid        %d   */
            &quot;%*d &quot;      /* (5)  pgrp        %d   */
            &quot;%*d &quot;      /* (6)  session     %d   */
            &quot;%*d &quot;      /* (7)  tty_nr      %d   */
            &quot;%*d &quot;      /* (8)  tpgid       %d   */
            &quot;%*u &quot;      /* (9)  flags       %u   */
            &quot;%*u &quot;      /* (10) minflt      %lu  */
            &quot;%*u &quot;      /* (11) cminflt     %lu  */
            &quot;%*u &quot;      /* (12) majflt      %lu  */
            &quot;%*u &quot;      /* (13) cmajflt     %lu  */
            &quot;%*u &quot;      /* (14) utime       %lu  */
            &quot;%*u &quot;      /* (15) stime       %lu  */
            &quot;%*d &quot;      /* (16) cutime      %ld  */
            &quot;%*d &quot;      /* (17) cstime      %ld  */
            &quot;%*d &quot;      /* (18) priority    %ld  */
            &quot;%*d &quot;      /* (19) nice        %ld  */
            &quot;%*d &quot;      /* (20) num_threads %ld  */
            &quot;%*d &quot;      /* (21) itrealvalue %ld  */
            &quot;%&quot; PRIu64, /* (22) starttime   %llu */
             &amp;starttime);
    if (ret != 1) {
        fclose(f);
        /* Caller can check for EINVAL on 0. */
        errno = EINVAL;
        return 0;
    }

    fclose(f);

    errno = 0;
    return starttime;
}
</code></pre>
<p>用当前时间减去进程的启动时间，就是进程的运行时长，当前时间需要是相对系统启动的时间，用系统调用<code>clock_gettime()</code>获取：</p>
<pre><code class="language-c">static uint64_t get_reaper_age(pid_t pid)
{
    uint64_t procstart, uptime, procage;

    /* We need to substract the time the process has started since system
     * boot minus the time when the system has started to get the actual
     * reaper age.
     */
    procstart = get_reaper_start_time_in_sec(pid);
    procage = procstart;
    if (procstart &gt; 0) {
        int ret;
        struct timespec spec;

        ret = clock_gettime(CLOCK_BOOTTIME, &amp;spec);
        if (ret &lt; 0)
            return 0;
        /* We could make this more precise here by using the tv_nsec
         * field in the timespec struct and convert it to milliseconds
         * and then create a double for the seconds and milliseconds but
         * that seems more work than it is worth.
         */
        uptime = spec.tv_sec;
        procage = uptime - procstart;
    }

    return procage;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="动态链接库操作"><a class="header" href="#动态链接库操作">动态链接库操作</a></h1>
<h2 id="打开关闭动态链接库"><a class="header" href="#打开关闭动态链接库">打开/关闭动态链接库</a></h2>
<pre><code class="language-c">#include &lt;dlfcn.h&gt;

void *dlopen(const char *filename, int flag);

int dlclose(void *handle);
</code></pre>
<h2 id="读取动态链接库的操作错误"><a class="header" href="#读取动态链接库的操作错误">读取动态链接库的操作错误</a></h2>
<pre><code class="language-c">#include &lt;dlfcn.h&gt;

char *dlerror(void);
</code></pre>
<h2 id="获取动态链接库中的符号地址"><a class="header" href="#获取动态链接库中的符号地址">获取动态链接库中的符号地址</a></h2>
<pre><code class="language-c">#include &lt;dlfcn.h&gt;

void *dlsym(void *handle, const char *symbol);
</code></pre>
<p>例如：</p>
<pre><code class="language-c">static int do_proc_open(const char *path, struct fuse_file_info *fi)
{
    int (*proc_open)(const char *path, struct fuse_file_info *fi);
    char *error;
    dlerror();    /* Clear any existing error */
    proc_open = (int (*)(const char *path, struct fuse_file_info *fi)) dlsym(dlopen_handle, &quot;proc_open&quot;);
    error = dlerror();
    if (error != NULL) {
        lxcfs_error(&quot;%s\n&quot;, error);
        return -1;
    }

    return proc_open(path, fi);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="信号量操作"><a class="header" href="#信号量操作">信号量操作</a></h1>
<h2 id="信号量列表"><a class="header" href="#信号量列表">信号量列表</a></h2>
<p><code>man 7 signal</code></p>
<pre><code class="language-bash">Signal     Value     Action   Comment
──────────────────────────────────────────────────────────────────────
SIGHUP        1       Term    Hangup detected on controlling terminal
                              or death of controlling process
SIGINT        2       Term    Interrupt from keyboard
SIGQUIT       3       Core    Quit from keyboard
SIGILL        4       Core    Illegal Instruction
SIGABRT       6       Core    Abort signal from abort(3)
SIGFPE        8       Core    Floating point exception
SIGKILL       9       Term    Kill signal
SIGSEGV      11       Core    Invalid memory reference
SIGPIPE      13       Term    Broken pipe: write to pipe with no
                              readers
SIGALRM      14       Term    Timer signal from alarm(2)
SIGTERM      15       Term    Termination signal
SIGUSR1   30,10,16    Term    User-defined signal 1
SIGUSR2   31,12,17    Term    User-defined signal 2
SIGCHLD   20,17,18    Ign     Child stopped or terminated
SIGCONT   19,18,25    Cont    Continue if stopped
SIGSTOP   17,19,23    Stop    Stop process
SIGTSTP   18,20,24    Stop    Stop typed at terminal
SIGTTIN   21,21,26    Stop    Terminal input for background process
SIGTTOU   22,22,27    Stop    Terminal output for background process
</code></pre>
<h2 id="信号量捕获"><a class="header" href="#信号量捕获">信号量捕获</a></h2>
<p><code>man signal</code></p>
<pre><code class="language-c">#include &lt;signal.h&gt;

typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="内存管理操作"><a class="header" href="#内存管理操作">内存管理操作</a></h1>
<h2 id="从栈上分配会自动回收的内存"><a class="header" href="#从栈上分配会自动回收的内存">从栈上分配会自动回收的内存</a></h2>
<p><code>man alloca</code></p>
<pre><code class="language-c">#include &lt;alloca.h&gt;

void *alloca(size_t size);
</code></pre>
<p>这个函数需要特意说明一下，alloca分配的是调用它的函数的栈中的内存，在调用函数返回时，alloca分配的内存会随着栈空间的释放一同释放。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="格式化打印输出"><a class="header" href="#格式化打印输出">格式化打印输出</a></h1>
<h2 id="printf系列函数"><a class="header" href="#printf系列函数">printf系列函数</a></h2>
<p><code>man 3 printf</code></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);

#include &lt;stdarg.h&gt;

int vprintf(const char *format, va_list ap);
int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="文件设备操作"><a class="header" href="#文件设备操作">文件&amp;设备操作</a></h1>
<h2 id="检查对某个文件的操作权限"><a class="header" href="#检查对某个文件的操作权限">检查对某个文件的操作权限</a></h2>
<p>检查对相对某个目录下的某文件的操作权限，<code>man faccessat</code>：</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt; /* Definition of AT_* constants */
#include &lt;unistd.h&gt;

int faccessat(int dirfd, const char *pathname, int mode, int flags);
</code></pre>
<h2 id="获取文件状态"><a class="header" href="#获取文件状态">获取文件状态</a></h2>
<p><code>man 2 stat</code></p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

int stat(const char *path, struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *path, struct stat *buf);
</code></pre>
<p><code>struct stat</code>在<code>/usr/include/bits/stat.h</code>中定义，原始定义中使用很多宏不方便阅读，可以用以下定义代替：</p>
<pre><code class="language-c">struct stat {
    dev_t     st_dev;     /* ID of device containing file */
    ino_t     st_ino;     /* inode number */
    mode_t    st_mode;    /* protection */
    nlink_t   st_nlink;   /* number of hard links */
    uid_t     st_uid;     /* user ID of owner */
    gid_t     st_gid;     /* group ID of owner */
    dev_t     st_rdev;    /* device ID (if special file) */
    off_t     st_size;    /* total size, in bytes */
    blksize_t st_blksize; /* blocksize for file system I/O */
    blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
    time_t    st_atime;   /* time of last access */
    time_t    st_mtime;   /* time of last modification */
    time_t    st_ctime;   /* time of last status change */
};
</code></pre>
<p>可以用下面的宏定义判断文件类型，传入参数是stat中的<code>st_mode</code>：</p>
<pre><code class="language-c">S_ISREG(m)  is it a regular file?
S_ISDIR(m)  directory?
S_ISCHR(m)  character device?
S_ISBLK(m)  block device?
S_ISFIFO(m) FIFO (named pipe)?
S_ISLNK(m)  symbolic link?  (Not in POSIX.1-1996.)
S_ISSOCK(m) socket?  (Not in POSIX.1-1996.)
</code></pre>
<p>st_mode中每个bit含义如下：</p>
<pre><code class="language-c">S_IFMT     0170000   bit mask for the file type bit fields
S_IFSOCK   0140000   socket
S_IFLNK    0120000   symbolic link
S_IFREG    0100000   regular file
S_IFBLK    0060000   block device
S_IFDIR    0040000   directory
S_IFCHR    0020000   character device
S_IFIFO    0010000   FIFO
S_ISUID    0004000   set-user-ID bit
S_ISGID    0002000   set-group-ID bit (see below)
S_ISVTX    0001000   sticky bit (see below)
S_IRWXU    00700     mask for file owner permissions
S_IRUSR    00400     owner has read permission
S_IWUSR    00200     owner has write permission
S_IXUSR    00100     owner has execute permission
S_IRWXG    00070     mask for group permissions
S_IRGRP    00040     group has read permission
S_IWGRP    00020     group has write permission
S_IXGRP    00010     group has execute permission
S_IRWXO    00007     mask for permissions for others (not in group)
S_IROTH    00004     others have read permission
S_IWOTH    00002     others have write permission
S_IXOTH    00001     others have execute permission
</code></pre>
<h2 id="打开创建文件"><a class="header" href="#打开创建文件">打开、创建文件</a></h2>
<p><code>man open</code></p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);

int creat(const char *pathname, mode_t mode);
</code></pre>
<p><code>openat()</code>是相对指定的目录描述符打开文件：</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;

int openat(int dirfd, const char *pathname, int flags);
int openat(int dirfd, const char *pathname, int flags, mode_t mode);
</code></pre>
<h2 id="关闭文件"><a class="header" href="#关闭文件">关闭文件</a></h2>
<p><code>man close</code></p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

int close(int fildes);
</code></pre>
<h2 id="文件描述符"><a class="header" href="#文件描述符">文件描述符</a></h2>
<p><code>man fcntl</code></p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int fcntl(int fd, int cmd, ... /* arg */ );
</code></pre>
<p>对已经打开的文件描述符进行操作。可以进行的操作比较多，而且用途三言两语难以说清楚，这里只列出个目录，详情到man手册中查看。</p>
<p>文件描述符复制（Duplicating a file descriptor）：</p>
<pre><code> F_DUPFD (int)、F_DUPFD_CLOEXEC (int; since Linux 2.6.24)
</code></pre>
<p>文件描述符标记（File descriptor flags）：</p>
<pre><code> F_GETFD (void)、F_SETFD (int)
</code></pre>
<p>文件状态标记（File status flags）：</p>
<pre><code>F_GETFL (void)、F_SETFL (int)
</code></pre>
<p>文件软锁（Advisory locking）：</p>
<pre><code>F_SETLK (struct flock *)、F_SETLKW (struct flock *)、F_GETLK (struct flock *)
</code></pre>
<p>文件信号响应管理（Managing signals）：</p>
<pre><code>F_GETOWN (void)、F_SETOWN (int)、F_GETOWN_EX (struct f_owner_ex *) (since Linux 2.6.32)
F_SETOWN_EX (struct f_owner_ex *) (since Linux 2.6.32)、F_GETSIG (void)、F_SETSIG (int)
</code></pre>
<p>文件描述符租约（Leases）：</p>
<pre><code> F_SETLEASE (int)、 F_GETLEASE (void)
</code></pre>
<p>文件和路径变化通知（File and directory change notification (dnotify)）：</p>
<pre><code> F_NOTIFY (int)
</code></pre>
<p>Pipe容量设置（Changing the capacity of a pipe）：</p>
<pre><code>F_SETPIPE_SZ (int; since Linux 2.6.35)、F_GETPIPE_SZ (void; since Linux 2.6.35)
</code></pre>
<h2 id="文件内容截断到指定长度"><a class="header" href="#文件内容截断到指定长度">文件内容截断到指定长度</a></h2>
<p><code>man truncate</code></p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

int truncate(const char *path, off_t length);
int ftruncate(int fd, off_t length);
</code></pre>
<h2 id="逐行读取文件内容"><a class="header" href="#逐行读取文件内容">逐行读取文件内容</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;

ssize_t getline(char **lineptr, size_t *n, FILE *stream);

ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
</code></pre>
<p><code>*lineptr</code>是存放一行文本的内存地址，<code>*n</code>是<code>*lineptr</code>指向的内存空间的大小。</p>
<p><strong>注意</strong>：如果<code>*lineptr</code>是null，getline和getdelim会让<code>*lineptr</code>指定自动分配的一块内存，要主动释放<code>*lineptr</code>指向的内存，这种情况下<code>*n</code>被忽略。</p>
<p><strong>注意</strong>：如果<code>*lineptr</code>指定的内存空间不足以存放整行数据，getline和getdelim会调用realloc重新分配内存，更改<code>*lineptr</code>指向新分配的内存，并同步更新<code>*n</code>。 </p>
<h2 id="向文件中写入内容"><a class="header" href="#向文件中写入内容">向文件中写入内容</a></h2>
<p><code>man 3 write</code></p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

ssize_t pwrite(int fildes, const void *buf, size_t nbyte,
       off_t offset);
ssize_t write(int fildes, const void *buf, size_t nbyte);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="进程管理操作"><a class="header" href="#进程管理操作">进程管理操作</a></h1>
<h2 id="获取进程id"><a class="header" href="#获取进程id">获取进程ID</a></h2>
<p><code>man pid</code></p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t getpid(void);
pid_t getppid(void);
</code></pre>
<p>分别是获取当前进程id，和父进程id。</p>
<h2 id="创建子进程"><a class="header" href="#创建子进程">创建子进程</a></h2>
<h3 id="fork"><a class="header" href="#fork">fork</a></h3>
<p><code>man fork</code></p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

pid_t fork(void);
</code></pre>
<p>子进程创建失败返回<code>-1</code>，创建成功，在父进程中返回子进程的<code>进程号</code>，在子进程中返回<code>0</code>。</p>
<h3 id="clone"><a class="header" href="#clone">clone</a></h3>
<p><code>man clone</code></p>
<p><code>clone()</code>比<code>fork()</code>功能更强大，可以传入子进程的运行函数，以及设置namespace等。</p>
<pre><code class="language-c">#include &lt;sched.h&gt;

int clone(int (*fn)(void *), void *child_stack,
          int flags, void *arg, ...
          /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );

/* Prototype for the raw system call */

long clone(unsigned long flags, void *child_stack,
          void *ptid, void *ctid,
          struct pt_regs *regs);
</code></pre>
<p>上面第一个定义是glibc提供的，封装了原始的clone系统调用，第二个定义是原始的clone系统调用定义。</p>
<p>关键是参数<code>flags</code>，它的bit位有特殊含义，分别是退出时向父进程发送的信号量和下面的标志位（具体说明查阅手册<code>man clone</code>）：</p>
<pre><code>CLONE_CHILD_CLEARTID (since Linux 2.5.49)
CLONE_CHILD_SETTID (since Linux 2.5.49)
CLONE_FILES (since Linux 2.0)
CLONE_FS (since Linux 2.0)
CLONE_IO (since Linux 2.6.25)
CLONE_NEWIPC (since Linux 2.6.19)
CLONE_NEWNET (since Linux 2.6.24)
CLONE_NEWNS (since Linux 2.4.19)
CLONE_NEWPID (since Linux 2.6.24)
CLONE_NEWUTS (since Linux 2.6.19)
CLONE_PARENT (since Linux 2.3.12)
CLONE_PARENT_SETTID (since Linux 2.5.49)
CLONE_PID (obsolete)
CLONE_PTRACE (since Linux 2.2)
CLONE_SETTLS (since Linux 2.5.32)
CLONE_SIGHAND (since Linux 2.0)
CLONE_STOPPED (since Linux 2.6.0-test2)
CLONE_SYSVSEM (since Linux 2.5.10)
CLONE_THREAD (since Linux 2.4.0-test8)
CLONE_UNTRACED (since Linux 2.5.46)
CLONE_VFORK (since Linux 2.2)
CLONE_VM (since Linux 2.0)
</code></pre>
<p>例如子进程退出时向父进程发送SIGCHLD信号：</p>
<pre><code class="language-c">pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);
if (pid == -1)
    errExit(&quot;clone&quot;);
printf(&quot;clone() returned %ld\n&quot;, (long) pid);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="并发编程"><a class="header" href="#并发编程">并发编程</a></h1>
<h2 id="once"><a class="header" href="#once">Once</a></h2>
<p>设置只有第一次被调用时会执行的操作，<code>man pthread_once()</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;

int pthread_once(pthread_once_t *once_control,  void (*init_routine)(void));

pthread_once_t once_control = PTHREAD_ONCE_INIT;
</code></pre>
<h2 id="线程锁"><a class="header" href="#线程锁">线程锁</a></h2>
<h3 id="线程读写锁"><a class="header" href="#线程读写锁">线程读写锁</a></h3>
<h4 id="线程读写锁的创建初始化和销毁"><a class="header" href="#线程读写锁的创建初始化和销毁">线程读写锁的创建初始化和销毁</a></h4>
<p>创建初始化和销毁，<code>man pthread_rwlock_init</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;

int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, 
       const pthread_rwlockattr_t *restrict attr);
</code></pre>
<h4 id="线程读写锁的加锁解锁操作"><a class="header" href="#线程读写锁的加锁解锁操作">线程读写锁的加锁解锁操作</a></h4>
<p>加读锁，<code>man pthread_rwlock_rdlock</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;

int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
</code></pre>
<p>加读锁等待超时，<code>man pthread_rwlock_timedrdlock</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock,
       const struct timespec *restrict abs_timeout);
</code></pre>
<p>加写锁，<code>man pthread_rwlock_wrlock</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;

int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
</code></pre>
<p>加写锁等待超时，<code>man pthread_rwlock_timedwrlock</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock,
       const struct timespec *restrict abs_timeout);
</code></pre>
<p>解锁，<code>man pthread_rwlock_unlock</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;

int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
</code></pre>
<h3 id="线程互斥锁"><a class="header" href="#线程互斥锁">线程互斥锁</a></h3>
<h4 id="线程互斥锁的创建初始化和销毁"><a class="header" href="#线程互斥锁的创建初始化和销毁">线程互斥锁的创建初始化和销毁</a></h4>
<p>创建初始化和销毁，<code>man pthread_mutex_init</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;

int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
       const pthread_mutexattr_t *restrict attr);

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
</code></pre>
<h4 id="线程互斥锁的加锁和解锁操作"><a class="header" href="#线程互斥锁的加锁和解锁操作">线程互斥锁的加锁和解锁操作</a></h4>
<p>加锁解锁，<code>man pthread_mutex_lock</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
</code></pre>
<p>加锁等待超时，<code>man pthread_mutex_timedlock</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
       const struct timespec *restrict abs_timeout);
</code></pre>
<p>解锁操作，<code>man pthread_mutex_unlock</code>：</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;

int pthread_mutex_unlock(pthread_mutex_t *mutex);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="socket通信相关操作"><a class="header" href="#socket通信相关操作">socket通信相关操作</a></h1>
<h2 id="socket管道"><a class="header" href="#socket管道">socket管道</a></h2>
<p><code>man socketpair</code></p>
<p>一次创建两个socket，构成一个未命名的socket pair，写入一个socket的数据能够从另一个socket中收到。</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;

int socketpair(int domain, int type, int protocol, int sv[2]);
</code></pre>
<p>可以作为父子进程的通信方式，例如：</p>
<pre><code class="language-c">static pid_t get_init_pid_for_task(pid_t task)
{
    int sock[2];
    pid_t pid;
    pid_t ret = -1;
    char v = '0';
    struct ucred cred;

    if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) &lt; 0) {
        perror(&quot;socketpair&quot;);
        return -1;
    }

    pid = fork();
    if (pid &lt; 0)
        goto out;
    if (!pid) {
        close(sock[1]);
        write_task_init_pid_exit(sock[0], task);
        _exit(0);
    }

    if (!recv_creds(sock[1], &amp;cred, &amp;v))
        goto out;
    ret = cred.pid;

out:
    close(sock[0]);
    close(sock[1]);
    if (pid &gt; 0)
        wait_for_pid(pid);
    return ret;
}
</code></pre>
<h2 id="向socket写数据"><a class="header" href="#向socket写数据">向socket写数据</a></h2>
<p><code>man sendmsg</code></p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int sockfd, const void *buf, size_t len, int flags);

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
               const struct sockaddr *dest_addr, socklen_t addrlen);

ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
</code></pre>
<h2 id="使用socket消息头"><a class="header" href="#使用socket消息头">使用socket消息头</a></h2>
<p>下面这些函数提供了操作通过socket发送的数据的消息头的能力：</p>
<pre><code class="language-c">#include &lt;sys/socket.h&gt;

struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *msgh);
struct cmsghdr *CMSG_NXTHDR(struct msghdr *msgh, struct cmsghdr *cmsg);
size_t CMSG_ALIGN(size_t length);
size_t CMSG_SPACE(size_t length);
size_t CMSG_LEN(size_t length);
unsigned char *CMSG_DATA(struct cmsghdr *cmsg);
</code></pre>
<p><code>msghdr</code>描述要发送的数据：</p>
<pre><code class="language-c">/* Structure describing messages sent by
   `sendmsg' and received by `recvmsg'.  */
struct msghdr
  {
    void *msg_name;     /* Address to send to/receive from.  */
    socklen_t msg_namelen;  /* Length of address data.  */

    struct iovec *msg_iov;  /* Vector of data to send/receive into.  */
    size_t msg_iovlen;      /* Number of elements in the vector.  */

    void *msg_control;      /* Ancillary data (eg BSD filedesc passing). */
    size_t msg_controllen;  /* Ancillary data buffer length.
                   !! The type should be socklen_t but the
                   definition of the kernel is incompatible
                   with this.  */

    int msg_flags;      /* Flags on received message.  */
  };
</code></pre>
<p>可以在其中添加额外的控制信息，<code>msg_control</code>指向额外的控制信息，<code>msg_controllen</code>是额外的控制信息占用的内存空间。</p>
<p>额外的控制信息用结构体<code>cmsghdr</code>表达，msg_control中可以包含多个cmsghdr：</p>
<pre><code class="language-c">/* Structure used for storage of ancillary data object information.  */
struct cmsghdr
  {
    size_t cmsg_len;        /* Length of data in cmsg_data plus length
                   of cmsghdr structure.
                   !! The type should be socklen_t but the
                   definition of the kernel is incompatible
                   with this.  */
    int cmsg_level;     /* Originating protocol.  */
    int cmsg_type;      /* Protocol specific type.  */
#if (!defined __STRICT_ANSI__ &amp;&amp; __GNUC__ &gt;= 2) || __STDC_VERSION__ &gt;= 199901L
    __extension__ unsigned char __cmsg_data __flexarr; /* Ancillary data.  */
#endif
  };
</code></pre>
<p>用宏<code>CMSG_FIRSTHDR</code>获得第一个cmsghdr的地址：</p>
<pre><code class="language-c">cmsg = CMSG_FIRSTHDR(&amp;msg);
</code></pre>
<p>用宏<code>CMSG_DATA</code>获得cmsghdr的数据地址：</p>
<pre><code class="language-c">memcpy(CMSG_DATA(cmsg), cred, sizeof(*cred));
</code></pre>
<h3 id="发送端的例子"><a class="header" href="#发送端的例子">发送端的例子</a></h3>
<pre><code class="language-c">// lxcfs/bindings.c: 2053
static int send_creds(int sock, struct ucred *cred, char v, bool pingfirst)
{
    struct msghdr msg = { 0 };
    struct iovec iov;
    struct cmsghdr *cmsg;
    //额外的控制信息占用的内存
    char cmsgbuf[CMSG_SPACE(sizeof(*cred))];
    char buf[1];
    buf[0] = 'p';

    if (pingfirst) {
        if (msgrecv(sock, buf, 1) != 1) {
            lxcfs_error(&quot;%s\n&quot;, &quot;Error getting reply from server over socketpair.&quot;);
            return SEND_CREDS_FAIL;
        }
    }

    //控制信息占用的内存的地址写入msg
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);

    //获取第一个额外控制信息的地址，并设置
    cmsg = CMSG_FIRSTHDR(&amp;msg);
    cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(struct ucred));
    cmsg-&gt;cmsg_level = SOL_SOCKET;
    cmsg-&gt;cmsg_type = SCM_CREDENTIALS;
    memcpy(CMSG_DATA(cmsg), cred, sizeof(*cred));

    msg.msg_name = NULL;
    msg.msg_namelen = 0;

    //设置要发送的数据
    buf[0] = v;
    iov.iov_base = buf;
    iov.iov_len = sizeof(buf);
    msg.msg_iov = &amp;iov;
    msg.msg_iovlen = 1;

    if (sendmsg(sock, &amp;msg, 0) &lt; 0) {
        lxcfs_error(&quot;Failed at sendmsg: %s.\n&quot;,strerror(errno));
        if (errno == 3)
            return SEND_CREDS_NOTSK;
        return SEND_CREDS_FAIL;
    }

    return SEND_CREDS_OK;
}
</code></pre>
<h3 id="接收端的例子"><a class="header" href="#接收端的例子">接收端的例子</a></h3>
<pre><code class="language-c">// lxcfs/bindings.c: 2097
static bool recv_creds(int sock, struct ucred *cred, char *v)
{
    struct msghdr msg = { 0 };
    struct iovec iov;
    struct cmsghdr *cmsg;
    char cmsgbuf[CMSG_SPACE(sizeof(*cred))];
    char buf[1];
    int ret;
    int optval = 1;

    *v = '1';

    cred-&gt;pid = -1;
    cred-&gt;uid = -1;
    cred-&gt;gid = -1;

    if (setsockopt(sock, SOL_SOCKET, SO_PASSCRED, &amp;optval, sizeof(optval)) == -1) {
        lxcfs_error(&quot;Failed to set passcred: %s\n&quot;, strerror(errno));
        return false;
    }
    buf[0] = '1';
    if (write(sock, buf, 1) != 1) {
        lxcfs_error(&quot;Failed to start write on scm fd: %s\n&quot;, strerror(errno));
        return false;
    }

    //准备用发送端同样规格的消息头
    msg.msg_name = NULL;
    msg.msg_namelen = 0;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);

    iov.iov_base = buf;
    iov.iov_len = sizeof(buf);
    msg.msg_iov = &amp;iov;
    msg.msg_iovlen = 1;

    if (!wait_for_sock(sock, 2)) {
        lxcfs_error(&quot;Timed out waiting for scm_cred: %s\n&quot;, strerror(errno));
        return false;
    }
    //接收数据
    ret = recvmsg(sock, &amp;msg, MSG_DONTWAIT);
    if (ret &lt; 0) {
        lxcfs_error(&quot;Failed to receive scm_cred: %s\n&quot;, strerror(errno));
        return false;
    }
    //读取额外的控制信息
    cmsg = CMSG_FIRSTHDR(&amp;msg);

    if (cmsg &amp;&amp; cmsg-&gt;cmsg_len == CMSG_LEN(sizeof(struct ucred)) &amp;&amp;
            cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp;
            cmsg-&gt;cmsg_type == SCM_CREDENTIALS) {
        memcpy(cred, CMSG_DATA(cmsg), sizeof(*cred));
    }
    //buf中已经写入发送过来的数据
    *v = buf[0];

    return true;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="文件系统相关操作"><a class="header" href="#文件系统相关操作">文件系统相关操作</a></h1>
<h2 id="libfuse使用"><a class="header" href="#libfuse使用">libfuse使用</a></h2>
<p>libfuse的用途以及基础使用方法参考<a href="https://www.lijiaocn.com/%E6%8A%80%E5%B7%A7/2019/01/21/linux-fuse-filesystem-in-userspace-usage.html">《Linux FUSE（用户态文件系统）的使用：用libfuse创建FUSE文件系统》</a>。</p>
<h3 id="fuse_get_context"><a class="header" href="#fuse_get_context">fuse_get_context</a></h3>
<p>fuse_get_context用于在文件系统操作时获取上下文，在头文件<code>fuse/fuse.h</code>中定义：</p>
<pre><code class="language-c">/**
 * Get the current context
 *
 * The context is only valid for the duration of a filesystem
 * operation, and thus must not be stored and used later.
 *
 * @return the context
 */
struct fuse_context *fuse_get_context(void);
</code></pre>
<p>返回的结构体fuse_context包含以下信息：</p>
<pre><code class="language-c">/** Extra context that may be needed by some filesystems
 *
 * The uid, gid and pid fields are not filled in case of a writepage
 * operation.
 */
struct fuse_context {
    /** Pointer to the fuse object */
    struct fuse *fuse;

    /** User ID of the calling process */
    uid_t uid;

    /** Group ID of the calling process */
    gid_t gid;

    /** Thread ID of the calling process */
    pid_t pid;

    /** Private filesystem data */
    void *private_data;

    /** Umask of the calling process (introduced in version 2.8) */
    mode_t umask;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="系统配置读取"><a class="header" href="#系统配置读取">系统配置读取</a></h1>
<h2 id="操作系统相关配置获取"><a class="header" href="#操作系统相关配置获取">操作系统相关配置获取</a></h2>
<p>sysconf：   获取数值类型的配置项</p>
<p>fpathconf： 获取打开的文件句柄对应的配置项</p>
<p>pathconf：  获取文件对应的配置项</p>
<p>confstr：   获取字符串类型的配置项</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

long sysconf(int name);
long fpathconf(int fd, int name);
long pathconf(char *path, int name);
size_t confstr(int name, char *buf, size_t len);
</code></pre>
<h3 id="sysconf"><a class="header" href="#sysconf">sysconf</a></h3>
<p>sysconf用于在运行时获取系统配置常量，主要是POSIX中规定一些参数，例如最大长度、最大数值等。</p>
<p><code>man 3 sysconf</code></p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

long sysconf(int name);
</code></pre>
<p><code>sysconf</code>可以读取以下配置：</p>
<p>First, the POSIX.1 compatible values.</p>
<pre><code>ARG_MAX - _SC_ARG_MAX
    The maximum length of the arguments to the exec(3) family of functions.  Must not be less than _POSIX_ARG_MAX (4096).

CHILD_MAX - _SC_CHILD_MAX
    The maximum number of simultaneous processes per user ID.  Must not be less than _POSIX_CHILD_MAX (25).

HOST_NAME_MAX - _SC_HOST_NAME_MAX
    Maximum length of a hostname, not including the terminating null byte, as returned by gethostname(2).  Must not be less than _POSIX_HOST_NAME_MAX (255).

LOGIN_NAME_MAX - _SC_LOGIN_NAME_MAX
    Maximum length of a login name, including the terminating null byte.  Must not be less than _POSIX_LOGIN_NAME_MAX (9).

clock ticks - _SC_CLK_TCK
    The  number  of  clock  ticks per second.  The corresponding variable is obsolete.  It was of course called CLK_TCK.  (Note: the macro CLOCKS_PER_SEC does not give information: it must
    equal 1000000.)

OPEN_MAX - _SC_OPEN_MAX
    The maximum number of files that a process can have open at any time.  Must not be less than _POSIX_OPEN_MAX (20).

PAGESIZE - _SC_PAGESIZE
    Size of a page in bytes.  Must not be less than 1.  (Some systems use PAGE_SIZE instead.)

RE_DUP_MAX - _SC_RE_DUP_MAX
    The number of repeated occurrences of a BRE permitted by regexec(3) and regcomp(3).  Must not be less than _POSIX2_RE_DUP_MAX (255).

STREAM_MAX - _SC_STREAM_MAX
    The maximum number of streams that a process can have open at any time.  If defined, it has the same value as the standard C macro FOPEN_MAX.  Must not be less  than  _POSIX_STREAM_MAX
    (8).

SYMLOOP_MAX - _SC_SYMLOOP_MAX
    The maximum number of symbolic links seen in a pathname before resolution returns ELOOP.  Must not be less than _POSIX_SYMLOOP_MAX (8).

TTY_NAME_MAX - _SC_TTY_NAME_MAX
    The maximum length of terminal device name, including the terminating null byte.  Must not be less than _POSIX_TTY_NAME_MAX (9).

TZNAME_MAX - _SC_TZNAME_MAX
    The maximum number of bytes in a timezone name.  Must not be less than _POSIX_TZNAME_MAX (6).

_POSIX_VERSION - _SC_VERSION
    indicates the year and month the POSIX.1 standard was approved in the format YYYYMML; the value 199009L indicates the Sept. 1990 revision.
</code></pre>
<p>Next, the POSIX.2 values, giving limits for utilities.</p>
<pre><code>BC_BASE_MAX - _SC_BC_BASE_MAX
    indicates the maximum obase value accepted by the bc(1) utility.

BC_DIM_MAX - _SC_BC_DIM_MAX
    indicates the maximum value of elements permitted in an array by bc(1).

BC_SCALE_MAX - _SC_BC_SCALE_MAX
    indicates the maximum scale value allowed by bc(1).

BC_STRING_MAX - _SC_BC_STRING_MAX
    indicates the maximum length of a string accepted by bc(1).

COLL_WEIGHTS_MAX - _SC_COLL_WEIGHTS_MAX
    indicates the maximum numbers of weights that can be assigned to an entry of the LC_COLLATE order keyword in the locale definition file,

EXPR_NEST_MAX - _SC_EXPR_NEST_MAX
    is the maximum number of expressions which can be nested within parentheses by expr(1).

LINE_MAX - _SC_LINE_MAX
    The maximum length of a utility's input line, either from standard input or from a file.  This includes space for a trailing newline.

RE_DUP_MAX - _SC_RE_DUP_MAX
    The maximum number of repeated occurrences of a regular expression when the interval notation \{m,n\} is used.

POSIX2_VERSION - _SC_2_VERSION
    indicates the version of the POSIX.2 standard in the format of YYYYMML.

POSIX2_C_DEV - _SC_2_C_DEV
    indicates whether the POSIX.2 C language development facilities are supported.

POSIX2_FORT_DEV - _SC_2_FORT_DEV
    indicates whether the POSIX.2 FORTRAN development utilities are supported.

POSIX2_FORT_RUN - _SC_2_FORT_RUN
    indicates whether the POSIX.2 FORTRAN run-time utilities are supported.

_POSIX2_LOCALEDEF - _SC_2_LOCALEDEF
    indicates whether the POSIX.2 creation of locates via localedef(1) is supported.

POSIX2_SW_DEV - _SC_2_SW_DEV
    indicates whether the POSIX.2 software development utilities option is supported.
</code></pre>
<p>These values also exist, but may not be standard.</p>
<pre><code> - _SC_PHYS_PAGES
    The number of pages of physical memory.  Note that it is possible for the product of this value and the value of _SC_PAGESIZE to overflow.

 - _SC_AVPHYS_PAGES
    The number of currently available pages of physical memory.

 - _SC_NPROCESSORS_CONF
    The number of processors configured.

     - _SC_NPROCESSORS_ONLN
           The number of processors currently online (available).
</code></pre>
<h3 id="pathconf-和-fpathconf"><a class="header" href="#pathconf-和-fpathconf">pathconf 和 fpathconf</a></h3>
<p><code>man  pathconf</code></p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

long fpathconf(int fd, int name);
long pathconf(char *path, int name);
</code></pre>
<p>Setting name equal to one of the following constants returns the following configuration options:</p>
<pre><code>_PC_LINK_MAX
    returns the maximum number of links to the file.  If fd or path refer to a directory, then the value applies to the whole directory.  The corresponding macro is _POSIX_LINK_MAX.

_PC_MAX_CANON
    returns the maximum length of a formatted input line, where fd or path must refer to a terminal.  The corresponding macro is _POSIX_MAX_CANON.

_PC_MAX_INPUT
    returns the maximum length of an input line, where fd or path must refer to a terminal.  The corresponding macro is _POSIX_MAX_INPUT.

_PC_NAME_MAX
    returns the maximum length of a filename in the directory path or fd that the process is allowed to create.  The corresponding macro is _POSIX_NAME_MAX.

_PC_PATH_MAX
    returns the maximum length of a relative pathname when path or fd is the current working directory.  The corresponding macro is _POSIX_PATH_MAX.

_PC_PIPE_BUF
    returns the size of the pipe buffer, where fd must refer to a pipe or FIFO and path must refer to a FIFO.  The corresponding macro is _POSIX_PIPE_BUF.

_PC_CHOWN_RESTRICTED
    returns nonzero if the chown(2) call may not be used on this file.  If fd or path refer to a directory, then this applies to all files in that directory.  The  corresponding  macro  is
    _POSIX_CHOWN_RESTRICTED.

_PC_NO_TRUNC
    returns nonzero if accessing filenames longer than _POSIX_NAME_MAX generates an error.  The corresponding macro is _POSIX_NO_TRUNC.

_PC_VDISABLE
    returns nonzero if special character processing can be disabled, where fd or path must refer to a terminal.
</code></pre>
<h3 id="confstr"><a class="header" href="#confstr">confstr</a></h3>
<p>The name argument is the system variable to be queried.  The following variables are supported:</p>
<pre><code>_CS_GNU_LIBC_VERSION (GNU C library only; since glibc 2.3.2)
    A string which identifies the GNU C library version on this system (e.g, &quot;glibc 2.3.4&quot;).

_CS_GNU_LIBPTHREAD_VERSION (GNU C library only; since glibc 2.3.2)
    A string which identifies the POSIX implementation supplied by this C library (e.g, &quot;NPTL 2.3.4&quot; or &quot;linuxthreads-0.10&quot;).

_CS_PATH
    A value for the PATH variable which indicates where all the POSIX.2 standard utilities can be found.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="namespace相关操作"><a class="header" href="#namespace相关操作">Namespace相关操作</a></h1>
<h2 id="当前进程关联到指定的namespace"><a class="header" href="#当前进程关联到指定的namespace">当前进程关联到指定的namespace</a></h2>
<pre><code class="language-c">#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include &lt;sched.h&gt;

int setns(int fd, int nstype);
</code></pre>
<p>fd是<code>/proc/进程号/ns/</code>中的某个文件打开后的句柄，nstype可以取以下值：</p>
<pre><code>0      Allow any type of namespace to be joined.

CLONE_NEWIPC
       fd must refer to an IPC namespace.

CLONE_NEWNET
       fd must refer to a network namespace.

CLONE_NEWUTS
       fd must refer to a UTS namespace.
</code></pre>
<h2 id="解除namespace关联"><a class="header" href="#解除namespace关联">解除namespace关联</a></h2>
<p><a href="https://lwn.net/Articles/135266/">new system call, unshare</a>，<code>man unshare</code>。</p>
<pre><code class="language-c">#include &lt;sched.h&gt;

int unshare(int flags);
</code></pre>
<p>unshare() allows a process to disassociate parts of its execution context that are currently being shared with other processes.  Part of the execution context, such as the mount namespace, is
shared implicitly when a new process is created using fork(2) or vfork(2), while other parts, such as virtual memory, may be shared by explicit request when creating a process using clone(2).</p>
<p>参数flags可以使用一下标志位：</p>
<pre><code>CLONE_FILES
       Reverse the effect of the clone(2) CLONE_FILES flag.  Unshare the  file  descriptor  table,  so
       that the calling process no longer shares its file descriptors with any other process.

CLONE_FS
       Reverse  the effect of the clone(2) CLONE_FS flag.  Unshare file system attributes, so that the
       calling process no longer shares its root directory (chroot(2)), current directory  (chdir(2)),
       or umask (umask(2)) attributes with any other process.

CLONE_NEWIPC (since Linux 2.6.19)
       This  flag  has  the  same  effect as the clone(2) CLONE_NEWIPC flag.  Unshare the System V IPC
       namespace, so that the calling process has a private copy of the System V IPC  namespace  which
       is not shared with any other process.  Specifying this flag automatically implies CLONE_SYSVSEM
       as well.  Use of CLONE_NEWIPC requires the CAP_SYS_ADMIN capability.

CLONE_NEWNET (since Linux 2.6.24)
       This flag has the same effect as the clone(2) CLONE_NEWNET flag.  Unshare  the  network  names‐
       pace,  so  that  the  calling process is moved into a new network namespace which is not shared
       with any previously existing process.  Use of CLONE_NEWNET requires the CAP_SYS_ADMIN  capabil‐
       ity.

CLONE_NEWNS
       This  flag  has the same effect as the clone(2) CLONE_NEWNS flag.  Unshare the mount namespace,
       so that the calling process has a private copy of its namespace which is not  shared  with  any
       other  process.   Specifying  this  flag  automatically  implies  CLONE_FS  as  well.   Use  of
       CLONE_NEWNS requires the CAP_SYS_ADMIN capability.

CLONE_NEWUTS (since Linux 2.6.19)
       This flag has the same effect as the clone(2) CLONE_NEWUTS flag.  Unshare the  UTS  IPC  names‐
       pace,  so  that the calling process has a private copy of the UTS namespace which is not shared
       with any other process.  Use of CLONE_NEWUTS requires the CAP_SYS_ADMIN capability.

CLONE_SYSVSEM (since Linux 2.6.26)
       This flag reverses the effect of the clone(2) CLONE_SYSVSEM flag.  Unshare System  V  semaphore
       undo  values, so that the calling process has a private copy which is not shared with any other
       process.  Use of CLONE_SYSVSEM requires the CAP_SYS_ADMIN capability.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="硬件信息读取"><a class="header" href="#硬件信息读取">硬件信息读取</a></h1>
<h2 id="读取cpu个数"><a class="header" href="#读取cpu个数">读取CPU个数</a></h2>
<p>读取系统配置的cpu个数和可用的cpu个数和，<code>man get_nprocs</code>：</p>
<pre><code class="language-c">#include &lt;sys/sysinfo.h&gt;

int get_nprocs_conf(void);
int get_nprocs(void);
</code></pre>
<p><code>get_nprocs_conf()</code>返回的配置的CPU个数可能会大于<code>get_nprocs()</code>返回的可用的CPU个数，因为CPU可能离线（offline）不可用。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-语言编程手册"><a class="header" href="#go-语言编程手册">Go 语言编程手册</a></h1>
<p>记录一些 Go 语言的常识，主要目的是在长时间不写代码后，能够通过这份笔记快速回想起来。</p>
<p>go语言的设计目标是<code>通用</code>的<code>系统</code>编程语言。</p>
<blockquote>
<p>Go is a general-purpose language designed with systems programming in mind. It is strongly typed and garbage-collected and has explicit support for concurrent programming. Programs are constructed from packages, whose properties allow efficient management of dependencies. The existing implementations use a traditional compile/link model to generate executable binaries. </p>
</blockquote>
<p>通用，意味着可以用go语言做很多事情，不受领域的限制。可以用它来写后台程序、应用程序，也可以用来做数据处理、分析决策。与通用相对的是<code>专用</code>，例如matlab也是一门编程语言，但它只能用来做数据处理。相比之下go语言可以做的事情丰富多了，但go可以做不等于它做的更好，譬如要做数据统计处理，还是用matlab、R等语言合适。</p>
<p>系统，是指go语言是面向操作系统的，使用go开发的程序直接在操作系统上运行，可以直接调用操作系统的接口。C、C++都是系统语言，Java不是。用Java开发的程序是运行在JVM上的，运行在操作系统上的JVM代为调用操作系统的接口。同理，HTML、Javascript、Excel中的宏语言等也不是系统编程语言。( <a href="https://en.wikipedia.org/wiki/System_programming_language" title="System programming language">System programming language</a>)</p>
<p>学习资料：</p>
<ul>
<li><a href="https://golang.org/" title="golang.org">golang.org</a></li>
<li><a href="https://golang.org/" title="golang.org">golang documentation</a></li>
<li><a href="https://golang.org/doc/" title="golang documentation">The Go Programming Language Specification</a></li>
</ul>
<h2 id="参考-3"><a class="header" href="#参考-3">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-语言的安装和文档"><a class="header" href="#go-语言的安装和文档">Go 语言的安装和文档</a></h1>
<p>下面是在linux系统上安装go的步骤，在mac上安装也是类似的过程。</p>
<h2 id="下载软件包"><a class="header" href="#下载软件包">下载软件包</a></h2>
<p>到golang官方网站的<a href="https://golang.org/dl/" title="golang.org download">下载页</a>下载软件包，golang的网站<code>https://golang.org</code>需要翻墙访问。</p>
<p>如果不能翻墙，可以到golang中国的<a href="https://www.golangtc.com/download" title="golangtc.com download">下载页</a>中下载，golang中国的网址是<code>https://www.golangtc.com</code>。</p>
<p>下载页列出每个版本的软件包的信息：</p>
<pre><code>go1.9.2.src.tar.gz           Source                         16MB   665f184bf8ac89986cfd5a4460736976f60b57df6b320ad71ad4cef53bb143dc
go1.9.2.darwin-amd64.tar.gz  Archive     macOS     x86-64   98MB   73fd5840d55f5566d8db6c0ffdd187577e8ebe650c783f68bd27cbf95bde6743
go1.9.2.darwin-amd64.pkg     Installer   macOS     x86-64   97MB   8b4f6ae6deae1150d2e341d02c247fd18a99af387516540eeb84702ffd76d3a1
go1.9.2.linux-386.tar.gz     Archive     Linux     x86      88MB   574b2c4b1a248e58ef7d1f825beda15429610a2316d9cbd3096d8d3fa8c0bc1a
go1.9.2.linux-amd64.tar.gz   Archive     Linux     x86-64   99MB   de874549d9a8d8d8062be05808509c09a88a248e77ec14eb77453530829ac02b
go1.9.2.linux-armv6l.tar.gz  Archive     Linux     ARMv6    86MB   8a6758c8d390e28ef2bcea511f62dcb43056f38c1addc06a8bc996741987e7bb
go1.9.2.windows-386.zip      Archive     Windows   x86      92MB   35d3be5d7b97c6d11ffb76c1b19e20a824e427805ee918e82c08a2e5793eda20
go1.9.2.windows-386.msi      Installer   Windows   x86      79MB   020ea4a53093dd98b5ad074c4e493ff52be0aa71eee89dc24ca7783cb528de97
go1.9.2.windows-amd64.zip    Archive     Windows   x86-64   104MB  682ec3626a9c45b657c2456e35cadad119057408d37f334c6c24d88389c2164c
go1.9.2.windows-amd64.msi    Installer   Windows   x86-64   90MB   daeb761aa6fdb22dc3954fd911963b347c44aa5c6ba974b9c01be7cbbd6922ba
</code></pre>
<p><code>src</code>表示源码，<code>darwin</code>表示mac系统，<code>linux</code>表示linux系统，<code>windows</code>表示windows系统，<code>386</code>表示32位平台，<code>amd64</code>表示64位平台。</p>
<p>这里以linux版本为例，选择了<code>linux</code>和<code>amd64</code>，即运行在64位平台上的linux系统。</p>
<blockquote>
<p>现在的CPU几乎都是64位的，64位运行效率更高，所以应当优先选择amd64，除非非常确定是要在32平台上安装go。</p>
</blockquote>
<p>下载了安装包之后首先做一下校验（这是一个良好的习惯！）。</p>
<pre><code>$ sha256sum go1.9.2.linux-amd64.tar.gz
de874549d9a8d8d8062be05808509c09a88a248e77ec14eb77453530829ac02b  go1.9.2.linux-amd64.tar.gz
</code></pre>
<p>得到的校验码与网站上公布的校验码核对无误之后，才可以放心的使用。</p>
<blockquote>
<p>为什么要对下载的文件做校验？</p>
<p>互联网其实充满了各种秘密的，我们从网络上下载下来的文件很有可能是被掉过包的。
很多人都有做这种事情的动力，譬如黑客、运营商、捣蛋分子。
使用一个被掉过包的文件是非常危险的，因为我们无法预知它被做了什么手脚。
因此，一定要养成从官网上下载文件的习惯，而且下载完成之后要做校验。</p>
</blockquote>
<h2 id="解压软件包"><a class="header" href="#解压软件包">解压软件包</a></h2>
<p>将下载的软件包解压到指定目录中，为go单独建立一个目录。</p>
<pre><code># mkdir -p /opt/go/1.9.2
# tar -C /opt/go/1.9.2/ -xzf go1.9.2.linux-amd64.tar.gz
</code></pre>
<p>解压完成后，在新建的目标目录中，有一个go目录，这个目录里存放了go的所有文件。</p>
<pre><code>$ ls /opt/go/1.9.2/
go
</code></pre>
<h2 id="添加go命令"><a class="header" href="#添加go命令">添加go命令</a></h2>
<p>go命令位于<code>/opt/go/1.9.2/bin/</code>目录中：</p>
<pre><code>$ ls /opt/go/1.9.2/go/bin/
go  godoc  gofmt
</code></pre>
<p>可以直接使用：</p>
<pre><code>$ /opt/go/1.9.2/go/bin/go version
go version go1.9.2 linux/amd64
</code></pre>
<p>为了方便，需要将<code>/opt/go/1.9.2/go/bin/</code>添加到环境变量<code>PATH</code>中：</p>
<pre><code>$ echo 'export PATH=$PATH:/opt/go/1.9.2/go/bin/' &gt;&gt;~/.bash_profile
$ source ~/.bash_profile
</code></pre>
<p>这样就可以直接在命令行执行go命令：</p>
<pre><code>$ go version
go version go1.4.2 linux/amd64
</code></pre>
<h2 id="godoc-文档"><a class="header" href="#godoc-文档">Godoc 文档</a></h2>
<p>godoc 是 go 的一个命令，提供了可以在本地浏览的 go 文档。godoc 默认位于 go 的安装包中，与 go 命令位于同一个目录中，安装了 go 以后就可以直接使用。</p>
<pre><code>$ godoc -h
usage: godoc package [name ...]
        godoc -http=:6060
...
</code></pre>
<p>运行下面的命令，即可启动一个可以在本地访问的godoc网站：</p>
<pre><code>$ godoc -http=:6060
</code></pre>
<p>用浏览器打开 http://127.0.0.1:6060/，就可以看到运行在本地的 godoc 站点。内容与 <a href="https://www.golangtc.com/download" title="golangtc.com download">golang.org</a> 相同，由五部分组成；</p>
<pre><code>Documents
Packages
The Project
Help
Blog
</code></pre>
<p><a href="https://golang.org/doc/" title="go Documents">Documents</a>中包含的信息最全，需要仔细阅读。例如<a href="https://golang.org/doc/cmd" title="go Command Documentation">Command Documentation</a>、<a href="https://golang.org/ref/spec" title="The Go Programming Language Specification">The Go Programming Language Specification</a>。</p>
<p>特别是<a href="https://golang.org/ref/spec" title="The Go Programming Language Specification">The Go Programming Language Specification</a>，它对go语言语法的说明是最细致精确、最权威的。</p>
<p>go 项目介绍：<a href="https://golang.org/project/" title="go Project">Project</a></p>
<p>go Package文档：<a href="https://golang.org/pkg/" title="go Packages">Packages</a></p>
<p>go 帮助手册：<a href="https://golang.org/help/" title="go Help">Help</a></p>
<p>go 最新动态：<a href="https://golang.org/blog/" title="go Blog">Blog</a></p>
<h2 id="参考-4"><a class="header" href="#参考-4">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
<li><a href="https://golang.org/dl/" title="golang.org download">golang.org download</a></li>
<li><a href="https://www.golangtc.com/download" title="golangtc.com download">golangtc.com download</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="基础语法"><a class="header" href="#基础语法">基础语法</a></h1>
<blockquote>
<p>学习是一个循序渐进过程。</p>
</blockquote>
<p>没有编程经验初学者，不应当一开始就试图掌握所有语法细节，而应当多写程序、多尝试，找到正确的做事方法。编程多年的程序员，要脱离教材，要能够看懂、使用更全面精确的一手资料。</p>
<p><a href="https://golang.org/ref/spec" title="The Go Programming Language Specification">The Go Programming Language Specification</a>是go语法的一手资料，是这一章内容的主要来源。</p>
<blockquote>
<p>还记得学习第一门编程语言的过程吗？我的第一门编程语言是C，主要从书本上学习它的语法。后来知道了ANSI C、GNU C、以及C99等的存在，开始尝试去看C的语法说明。无奈，那时候的根基实在太差，完全看不懂，也没能坚持下去。go是一门很年轻、很年轻的语言，它的语法说明中使用的句子 要通俗易懂太多了。</p>
</blockquote>
<h2 id="参考-5"><a class="header" href="#参考-5">参考</a></h2>
<ol>
<li><a href="https://golang.org/ref/spec" title="The Go Programming Language Specification">The Go Programming Language Specification</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go语言的词法规则"><a class="header" href="#go语言的词法规则">go语言的词法规则</a></h1>
<p>英语有单词，汉语有词语，编程语言也有自己的词汇。</p>
<p>很多工作多年的程序员都没有从语言的层面了解自己正在使用的程序语言。这不应当被批评谴责，<code>程序语言设计</code>是一个大牛云集的小众领域，而程序员是使用程序语言的芸芸大众。</p>
<p>绝大多数程序员的任务是使用程序语言开发出软件，而不是设计程序语言，正如厨师的任务是做出美味佳肴，而不是制作锅碗瓢盆和生产原材料。</p>
<p>但，了解一下还是有好处的，能够从更高的层面、更抽象的看问题，这很重要。</p>
<p>go语言使用的编码是utf-8，用go语言写的源代码是utf-8编码的文本文件。</p>
<h2 id="构成要素"><a class="header" href="#构成要素">构成要素</a></h2>
<p>英语单词的构成要素是字母，汉语词语的构成要素是字，go语言词汇的构成要素是字符。</p>
<p>字符(Characters)、字母(Letters)、数字(Digits)</p>
<h3 id="字符characters"><a class="header" href="#字符characters">字符(Characters)</a></h3>
<p>go语言用utf-8编码，它完全是由下面的字符(Characters)组成的。</p>
<pre><code>newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as &quot;Letter&quot; */ .
unicode_digit  = /* a Unicode code point classified as &quot;Number, decimal digit&quot; */ .
</code></pre>
<h3 id="字母letters数字digits"><a class="header" href="#字母letters数字digits">字母(Letters)、数字(Digits)</a></h3>
<p>go语言将部分utf-8字符称为字母(letter)与数字(digit)。</p>
<pre><code>letter        = unicode_letter | &quot;_&quot; .
decimal_digit = &quot;0&quot; … &quot;9&quot; .
octal_digit   = &quot;0&quot; … &quot;7&quot; .
hex_digit     = &quot;0&quot; … &quot;9&quot; | &quot;A&quot; … &quot;F&quot; | &quot;a&quot; … &quot;f&quot; .
</code></pre>
<h2 id="注释comments"><a class="header" href="#注释comments">注释(Comments)</a></h2>
<p>注释有<code>单行注释</code>(line comments)和<code>通用注释</code>(general comments)两种形式。</p>
<p>单行注释以<code>//</code>开始，到行尾结束。</p>
<p>通用注释以<code>/*</code>开始，到<code>*/</code>结束。</p>
<p>注释不能位于字符(rune)、字符串(string literal)和另一个注释当中。</p>
<h2 id="词汇tokens"><a class="header" href="#词汇tokens">词汇(Tokens)</a></h2>
<p>Tokens是一个统称，它由标识符、关键字、运算符、分隔符、整数、浮点数、虚数、字符、字符串组成。</p>
<p>简而言之，在一个go文件中，去掉空格(spaces, U+0020)、TAB(horizontal tabs, U+0009)、回车(carriage returns, U+000D)、换行(newlines, U+000A)、分号(Semicolons)之后，剩下肉眼可见的部分就是Tokens。</p>
<p>Tokens是编译原理中一个常用的术语。编译器在进行词法分析的时候，会连续的读取源码文件中的内容，它从第一个非空白的符号开始记录，遇到下一个空白的符号后，将已经记录的内容作为一个Token。</p>
<h2 id="分号semicolons"><a class="header" href="#分号semicolons">分号(Semicolons)</a></h2>
<p>很多编程语言都用“;”作为结束符号，标记一行代码的结束。go语言也用分号做结束符，但是在源码中可以不写出分号，go可以自主推断出是否结束。</p>
<p>当一行代码的最后一个Token是下面的类型时，go会自动在行尾补上分号：</p>
<pre><code>标识符(identifier)
整数、浮点数、虚数、字(rune)、字符串
关键字：break、continue、fallthrough、return
运算符和分隔符：++、--、)、]、}
</code></pre>
<h2 id="标识符identifiers"><a class="header" href="#标识符identifiers">标识符(Identifiers)</a></h2>
<p>标识符是用来索引程序中的实体(entities)的。</p>
<p>譬如说变量、常量、函数等，这些都是程序中的entity，它们需要有一个名字，这个名字就是它们的标识符。</p>
<p>当我们说变量A的时候，其实是在指标识符A关联的数值。</p>
<p>go的标识符语法格式如下：</p>
<pre><code>identifier = letter { letter | unicode_digit } .
</code></pre>
<p>即，由字母和数字组成，但必须以字母开头，且不能是关键字。</p>
<h2 id="关键字keywords"><a class="header" href="#关键字keywords">关键字(Keywords)</a></h2>
<p>关键字是go语言保留的一些单词，它们都是由特定功能的，不用用来做标识符。</p>
<p>关键字的数量是有限的，下面是go的全部关键字：</p>
<pre><code>break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
</code></pre>
<h2 id="运算符和分隔符operators-and-delimiters"><a class="header" href="#运算符和分隔符operators-and-delimiters">运算符和分隔符(Operators and Delimiters)</a></h2>
<p>运算符和分隔符是一类有特殊的意义的非字母符号。</p>
<p>它们的数量也是有限的，下面是go的全部运算符和分隔符：</p>
<pre><code>+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )
-    |     -=    |=     ||    &lt;     &lt;=    [    ]
*    ^     \*=    ^=     &lt;-    &gt;     &gt;=    {    }
/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;
%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :
     &amp;^          &amp;^=
</code></pre>
<h2 id="整数integer-literals"><a class="header" href="#整数integer-literals">整数(Integer literals)</a></h2>
<p>整数就是数学意义上的整数，在go中有十进制、八进制、十六进制三种表示方式。</p>
<pre><code>int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( &quot;1&quot; … &quot;9&quot; ) { decimal_digit } .
octal_lit   = &quot;0&quot; { octal_digit } .
hex_lit     = &quot;0&quot; ( &quot;x&quot; | &quot;X&quot; ) hex_digit { hex_digit } .
</code></pre>
<p>注意，没有2进制的表示方式。</p>
<p>注意，<code>decimal_digit</code>前面章节中给出的数字，后面再遇到前面已经定义的词法时，不再提示。</p>
<p>在十六进制表示方式中，大写字母与小写字母的含义是相同的。</p>
<pre><code>42            //十进制
0600          //八进制，以0开头
0xBadFace     //十六进制，以0x开头，忽略大小写
</code></pre>
<h2 id="浮点数floating-point-literals"><a class="header" href="#浮点数floating-point-literals">浮点数(Floating-point literals)</a></h2>
<p>浮点数就是数学上的浮点数，带有小数点的数，go支持用科学计数表示浮点数。</p>
<pre><code>float_lit = decimals &quot;.&quot; [ decimals ] [ exponent ] |
            decimals exponent |
            &quot;.&quot; decimals [ exponent ] .
decimals  = decimal_digit { decimal_digit } .
exponent  = ( &quot;e&quot; | &quot;E&quot; ) [ &quot;+&quot; | &quot;-&quot; ] decimals .
</code></pre>
<p>浮点数可以有以下几种样式：</p>
<pre><code>0.
72.40
072.40          //== 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
</code></pre>
<p>注意在浮点数中，全是十进制，没有八进制和十六进制，<code>0720.40</code>等于<code>720.40</code>。</p>
<h2 id="虚数imaginary-literals"><a class="header" href="#虚数imaginary-literals">虚数(Imaginary literals)</a></h2>
<p>虚数是复数的组成部分，在样式上，它就是在整数或者浮点数后面加上“i”。</p>
<pre><code>imaginary_lit = (decimals | float_lit) &quot;i&quot; .
</code></pre>
<p>虚数也只能用十进制表示。</p>
<pre><code>0i
011i  // == 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
</code></pre>
<h2 id="符号rune-literals"><a class="header" href="#符号rune-literals">符号(Rune literals)</a></h2>
<p>在go语言中，Rune literal就是一个utf-8字符的值。</p>
<p>go语言使用utf8编码，utf8是一种变长的编码，它使用1～4个字节表示一个符号。</p>
<p>这样的符号用C语言中的char来指示，明显是不合适的，因为char要求空间必须是1个byte。</p>
<p>当要对这样的字符进行处理的时候，需要有一个称呼来指示它，这个称呼就是<code>Rune</code>。</p>
<p>Rune，是一个单一意义的符号，它占用的空间是不固定的。</p>
<p>go语言中，rune的语法有一些复杂：</p>
<pre><code>rune_lit         = &quot;'&quot; ( unicode_value | byte_value ) &quot;'&quot; .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` &quot;x&quot; hex_digit hex_digit .
little_u_value   = `\` &quot;u&quot; hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` &quot;U&quot; hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( &quot;a&quot; | &quot;b&quot; | &quot;f&quot; | &quot;n&quot; | &quot;r&quot; | &quot;t&quot; | &quot;v&quot; | `\` | &quot;'&quot; | `&quot;` ) .
</code></pre>
<p>首先，它是用单引号包裹的。</p>
<p>单引号中包裹的可以是byte值，也可以是unicode编码值。</p>
<p>byte_value有八进制和十六进制两种表达方式，八进制以<code>\</code>开始，后面跟随三个数字，十六进度以<code>\x</code>开始，后面跟随两个十六进制数字。</p>
<p>unidecode编码有四种形式。</p>
<p>第一种是单字符，第二种是以<code>\u</code>开头后面跟随4个十六进制数字，第三种是以<code>\U</code>开头后面跟随8个十六进制数字。</p>
<p>第四种是以<code>\</code>开头的转义字符，转义字符的数量是有限的，只有下面这些：</p>
<pre><code>\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\'   U+0027 single quote  (valid escape only within rune literals)
\&quot;   U+0022 double quote  (valid escape only within string literals)
</code></pre>
<p>注意，用unicode_value表示时，unicode_value必须是有效的，符合utf-8编码规范。</p>
<p>godoc中给出的rune literal：</p>
<pre><code>'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // rune literal containing single quote character
'aa'         // illegal: too many characters
'\xa'        // illegal: too few hexadecimal digits
'\0'         // illegal: too few octal digits
'\uDFFF'     // illegal: surrogate half
'\U00110000' // illegal: invalid Unicode code point
</code></pre>
<h2 id="字符串string-literals"><a class="header" href="#字符串string-literals">字符串(String literals)</a></h2>
<p>字符串有两种形式，原始型(raw string literals)和解释型(interpreted string literals)。</p>
<pre><code>string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = &quot;`&quot; { unicode_char | newline } &quot;`&quot; .
interpreted_string_lit = `&quot;` { unicode_value | byte_value } `&quot;` .
</code></pre>
<p>原始型字符串用反引号包裹，反引号中的内容都是字符串的一部分，反斜杠就是反斜杠，还包括看不到换行回车等。</p>
<pre><code>`\n
\n`                  // same as &quot;\\n\n\\n&quot;
</code></pre>
<p>简而言之，原始型字符串，就是它看起来的样子。</p>
<p>解释型字符串用双引号包裹，可以使用反斜杠进行转义。</p>
<pre><code>&quot;Hello, world!\n&quot;
&quot;日本語&quot;
&quot;\u65e5本\U00008a9e&quot;
&quot;\xff\u00FF&quot;
&quot;\uD800&quot;             // illegal: surrogate half
&quot;\U00110000&quot;         // illegal: invalid Unicode code point
</code></pre>
<p>注意与rune类似，unicode_value必须有效的，符合utf-8规范的。</p>
<p>解释型字符串可以用多种形式描述相同的内容，这个特点，有时候是特别有用的。</p>
<p>下面的五个解释型字符串，样式不同，但内容完全一致：</p>
<pre><code>&quot;日本語&quot;                                 // UTF-8 input text
`日本語`                                 // UTF-8 input text as a raw literal
&quot;\u65e5\u672c\u8a9e&quot;                    // the explicit Unicode code points
&quot;\U000065e5\U0000672c\U00008a9e&quot;        // the explicit Unicode code points
&quot;\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e&quot;  // the explicit UTF-8 bytes
</code></pre>
<h2 id="参考-6"><a class="header" href="#参考-6">参考</a></h2>
<ol>
<li><a href="https://golang.org/ref/spec#Lexical_elements" title="go Lexical elements">go Lexical elements</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go的常量"><a class="header" href="#go的常量">go的常量</a></h1>
<p>常量意如起名，是不会变化的量，量就是值。常量是程序运行时，系统中某个位置里的数值。</p>
<h2 id="常量分类"><a class="header" href="#常量分类">常量分类</a></h2>
<p>常量分为以下几类:</p>
<pre><code>布尔，boolean
符号，rune
整数，integer
浮点数，floating-point
复数，complex
字符串，string
</code></pre>
<p>其中符号(rune)、整数(intrger)、浮点数(floating-point)和复数(complex)型常量，又被称为数值常量(numeric constants)。</p>
<h2 id="常量表示"><a class="header" href="#常量表示">常量表示</a></h2>
<p>常量的值有下面几种表达方式：</p>
<pre><code>符号，rune
整数，integer
浮点数，floating-point
虚数，imaginary
字符串，string
指向常量的标记符，identifier denoting a constant
常量表达式，constant expression
结果为常量的类型转化， a conversion with a result that is a constant
内置函数的返回结果
内置的常量true和false
内置的常量标识符iota
</code></pre>
<p>数值型常量的值与所显示值一致，不会出现<code>溢出</code>，IEEE-754中的“-0”(negative zero)、“无穷大”(infinity)、“非数”(not-a-number)没有对应的常量。</p>
<h2 id="常量的类型"><a class="header" href="#常量的类型">常量的类型</a></h2>
<p>常量可以是显示声明了类型的(typed)，也可以是未声明类型的(untyped)。</p>
<p>未声明类型的常量会依据它的值获得一个默认的类型：</p>
<pre><code>value_type       default_type
------------------------------
boolean          bool
rune             rune
integer          int
floating-point   float64
complex          complex128
string           string
</code></pre>
<p>例如：</p>
<pre><code>i := 3
j := 3.0
</code></pre>
<p>&quot;3&quot;是一个untyped的常量，因为3是一个整数，它的默认类型就是int。</p>
<p>&quot;3.0&quot;是一个浮点数，它的默认类型是float64。</p>
<h2 id="数值型常量的范围"><a class="header" href="#数值型常量的范围">数值型常量的范围</a></h2>
<p>可以在代码中写出任意大小的数值，但是代码中写出数未必能被编译器支持。</p>
<p>编译器支持的最大数值是有上限的，在代码中可以写入的数字确实无限的。</p>
<p>go的编译器做了以下承诺：</p>
<pre><code>至少支持256个比特长度的整数
至少支持256个比特长度的小数
如果整数数值超过支持的范围，编译器报错
如果浮点数和复数溢出，编译器报错
如果浮点数和复数超出了支持的精度，使用最接近的数值
</code></pre>
<p>例如下面的代码编译时会报错：</p>
<pre><code>package main

func main() {
	i := 115792089237316195423570985008687907853269984665640564039457584007913129639936
}
</code></pre>
<p>Error:</p>
<pre><code>./main.go:6: constant 115792089237316195423570985008687907853269984665640564039457584007913129639936 overflows int
</code></pre>
<blockquote>
<p>2^256=115792089237316195423570985008687907853269984665640564039457584007913129639936</p>
</blockquote>
<h2 id="参考-7"><a class="header" href="#参考-7">参考</a></h2>
<ol>
<li><a href="https://golang.org/ref/spec#Constants" title="go Constants">go Constants</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go的变量"><a class="header" href="#go的变量">go的变量</a></h1>
<p>变量记录的是一个位置，这个位置中存放的值是可以变化的。</p>
<p>变量是有类型的，变量的类型规定了如何解读指定位置中存放的值。</p>
<h2 id="静态类型和动态类型"><a class="header" href="#静态类型和动态类型">静态类型和动态类型</a></h2>
<p>变量的类型分为静态类型和动态类型。</p>
<p>声明变量时，指定的类型是变量的静态类型。</p>
<p>如果变量静态类型是接口(interface type)，它还会有一个动态类型，动态类型就是被赋予的值的类型。</p>
<pre><code>var x interface{}  // x is nil and has static type interface{}
x = 42             // x has value 42 and dynamic type int
x = v              // x has value (*T)(nil) and dynamic type *T
</code></pre>
<p>如果声明变量时没有设置变量的值，它的值就是对应类型的零值（zero value)。</p>
<h2 id="参考-8"><a class="header" href="#参考-8">参考</a></h2>
<ol>
<li><a href="https://golang.org/ref/spec#Lexical_elements" title="go Lexical elements">go Lexical elements</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go的类型"><a class="header" href="#go的类型">go的类型</a></h1>
<p>类型是用来诠释如何解读指定位置中存放的数据，以及约定操作符的含义的。</p>
<h2 id="类型的属性"><a class="header" href="#类型的属性">类型的属性</a></h2>
<h3 id="内置类型predeclared"><a class="header" href="#内置类型predeclared">内置类型(predeclared)</a></h3>
<p>go语言内置了下面的类型：</p>
<pre><code>bool byte complex64 complex128 error float32 float64
int int8 int16 int32 int64 rune string
uint uint8 uint16 uint32 uint64 uintptr
</code></pre>
<h3 id="命名类型named"><a class="header" href="#命名类型named">命名类型(named)</a></h3>
<p>类型可以是命名的(named)，也可以是未命名的(unnamed)。</p>
<pre><code>Type      = TypeName | TypeLit | &quot;(&quot; Type &quot;)&quot; .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
            SliceType | MapType | ChannelType .
</code></pre>
<p>使用<code>type</code>指定了名字的类型是命名的，例如下面的类型的名字为Student</p>
<pre><code>type Student struct {
	Name string
	age int
}
</code></pre>
<p>由其它类型组合成的新类型，可以不被命名，例如下面的类型是没有名字的：</p>
<pre><code>[] string
[] int
</code></pre>
<p>无类型的名字，通用用于定义其它类型:</p>
<pre><code>type Array []int
</code></pre>
<p>或者在函数定义中使用：</p>
<pre><code>func Display(s struct {
    name string
    age  int
}) {
    println(s.name)
    println(s.age)
}
</code></pre>
<h3 id="实际类型underlying-type"><a class="header" href="#实际类型underlying-type">实际类型(underlying type)</a></h3>
<p>类型是可以用来定义其它类型的，例如：</p>
<pre><code>type T1 string 
type T2 T1
</code></pre>
<p>这里定义了一个类型T1，然后又用T1定义了类型T2。</p>
<p>T1的实际类型(underlying type)是string，T2的实际类型不是T1，而是T1的实际类型string。</p>
<p>实际类型必须是go的内置类型或者类型的组合。</p>
<p>例如，string、T1、T2的实际类型是string。</p>
<pre><code>type T1 string
type T2 T1
</code></pre>
<p>[]T1、T3、T4的实际类型是[]T1。</p>
<pre><code>type T3 []T1
type T4 T3
</code></pre>
<h3 id="类型的方法method-sets"><a class="header" href="#类型的方法method-sets">类型的方法(method sets)</a></h3>
<p>类型可以有自己的方法(Method)，也就是其它语言中的函数。</p>
<p>一个非接口类型的方法集就所有接受者(receiver)为改类型的方法，接口类型的方法集就是接口定义中包含的方法。</p>
<p>需要注意的是指针类型类型（例如 * T)，它的方法集是所有接受者为所指类型(T)和指针类型( * T)的方法集。</p>
<p>例如下面的代码中，方法的Show的Receiver是Str，但是类型为 * Str的pstr也可以调用。</p>
<pre><code>package main

type Str string

func (s Str) Show() {
	println(s)
}

func main() {
	str := Str(&quot;Hello World!&quot;)
	pstr := &amp;str
	pstr.Show()
}
</code></pre>
<p>方法集中的方法不能重名、且必须有名字。</p>
<h3 id="类型的等同性identical"><a class="header" href="#类型的等同性identical">类型的等同性(identical)</a></h3>
<p>命名语句不同的两个命名类型，是不等同的。例如下面的T1和T2，虽然实际类型都是string，但它们是两个类型。</p>
<pre><code>type T1 string
type T2 string
</code></pre>
<p>命名类型与未命名类型是不等同的，例如下面的T1与[]string是两个类型。</p>
<pre><code>type T1 []string
[]string
</code></pre>
<p>命名语句和定义语句<code>完全相同</code>的两个命名类型是才等同的，例如下面的T1。</p>
<pre><code>type T1 string
type T1 string
</code></pre>
<p>定义语句<code>完全相同</code>的两个未命名类型才是等同的，例如下面的[]string。</p>
<pre><code>[5]string
[5]string
</code></pre>
<p>在编程时，同一个类型只会定义一次。</p>
<p>在代码中定义<code>两个</code>等同的类型其是做不到的，因为它们如果等同，那么其实就是一个。例如下面的代码。</p>
<pre><code>package main

type T string
type T string

func main() {
}
</code></pre>
<p>编译时会报错。</p>
<pre><code>./main.go:5: T redeclared in this block
    previous declaration at ./main.go:4
</code></pre>
<p>两个类型等同是一个用来解释类型不等同的规则，即如果不符合遵守等同的规则，那么就是不等同的。</p>
<p>对于未命名类型需要特别注意，只要不满足下面的条件，那么就是两个不同的类型：</p>
<pre><code>两个数组类型要等同，不仅数组中成员的类型要相同，而且数组的长度也要相同。
两个分片类型等同，只需要分片的成员类型相同。
两个结构体等同，结构体成员的顺序、名称、标签(tag)都必须相同。
两个指针类型，所指向的类型相同。
两个函数类型，要有相同的数量的参数和返回值，参数和返回值的类型要相同，参数名和返回值的名字可以不同。
两个接口类型，要有相同的方法，方法的顺序可以不同。
两个字典类型，key的类型和value的类型必须相同。
两个通道(channel)类型，通道的方向和传递的类型必须相同。
</code></pre>
<p>例如下面两个函数类型符合上面的条件，所以是相同的：</p>
<pre><code>func(x int, y float64) *[]string
func(int, float64) (result *[]string)
</code></pre>
<h3 id="类型的赋值assignability"><a class="header" href="#类型的赋值assignability">类型的赋值(Assignability)</a></h3>
<p>一个值(value)只有在满足下面的条件时，才可以被赋给对应的类型的变量(variable)。</p>
<pre><code>值的类型与变量的类型相同
值的类型与变量的实际类型相同，且其中一个的类型是未命名的类型
变量的类型是一个接口，值实现了接口中方法
值是一个双向的通道(channel)，变量类型也是通道，传递的数据类型相同，并且其中一个的类型是未命名的。
值是内置的数值nil，变量的类型是指针(pointer)、函数(function)、分片(slice)、字典(map)、通道(channel)、接口(interface)
值是一个符合变量的类型要求的常量。
</code></pre>
<h2 id="go支持的类型"><a class="header" href="#go支持的类型">go支持的类型</a></h2>
<h3 id="布尔boolean-types"><a class="header" href="#布尔boolean-types">布尔(Boolean types)</a></h3>
<p>布尔类型是内置的类型<code>bool</code>，它的value只能是两个内置的常量：</p>
<pre><code>true
false
</code></pre>
<h3 id="数值numeric-types"><a class="header" href="#数值numeric-types">数值(Numeric types)</a></h3>
<p>数值类型都是内置的类型，一共有以下几种。</p>
<pre><code>uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32
</code></pre>
<p>另外还有三个数值类型，它们占用的空间取决于实现：</p>
<pre><code>uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
</code></pre>
<h3 id="字符串string-types"><a class="header" href="#字符串string-types">字符串(String types)</a></h3>
<p>字符串是内置的类型<code>string</code>，字符串的值是连续的字节，这些字节是不可更改的。</p>
<p>可以通过内置函数<code>len</code>获取字符串的长度，可以用通过[i]读取字符串的第i个(从0开始)字节。</p>
<p>字符串的字节只能读取，不能更改，也不能取址。</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    str := &quot;Hello World!&quot;
    fmt.Printf(&quot;%c\n&quot;, str[6])

    //not allow
    //ptr := &amp;str[6]

    //not allow
    //str[6] = 'w'
}
</code></pre>
<h3 id="数组array-types"><a class="header" href="#数组array-types">数组(Array types)</a></h3>
<p>数组是多个相同类型的值，在go中，数组必须有长度，长度是数组类型的一部分。</p>
<pre><code>ArrayType   = &quot;[&quot; ArrayLength &quot;]&quot; ElementType .
ArrayLength = Expression .
ElementType = Type .
</code></pre>
<p>数组是单维的，可以累进成多维数组：</p>
<pre><code>[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
</code></pre>
<p>要注意长度是数组类型的一部分，长度不同的数组是不同的类型，例如：</p>
<pre><code>package main

func main() {
    var array1 [32]byte
    var array2 [24]byte

    array1[0] = 'a'
    array2[0] = 'b'

    //not allow
    //array2 = array1
}
</code></pre>
<p>数组成员可以用从0开始的坐标索引，长度可以用内置的函数<code>len</code>获取。</p>
<h3 id="分片slice-types"><a class="header" href="#分片slice-types">分片(Slice types)</a></h3>
<p>分片(Slice)是用来索引数组(Array)中的一段连续的成员的。</p>
<pre><code>SliceType = &quot;[&quot; &quot;]&quot; ElementType .
</code></pre>
<p>分片初始化后就绑定到了一个数组，多个分片可以绑定到同一个数组。</p>
<p>与数组不同的是，分片有长度(length)和容量(capacity)两个属性。</p>
<p>长度是分片所索引的数组成员的数量，可以用内置的函数<code>len</code>获取。</p>
<p>容量是分片能够索引的数组成员的最大数量，等于数组的长度减去分片索引的第一个数组成员在数组中位置。</p>
<p>例如在下面的代码中，分片slice1的长度是5，容量是20(=30-10)</p>
<pre><code>package main

func main() {
    var array1 [30]int
    for i := 0; i &lt; len(array1); i++ {
        array1[i] = i
    }

    slice1 := array1[10:15]

    println(&quot;array's length: &quot;, len(array1))
    println(&quot;slice1's length: &quot;, len(slice1))
    println(&quot;slice1's capacity: &quot;, cap(slice1))

    for i := 0; i &lt; len(slice1); i++ {
        println(slice1[i])
    }
}
</code></pre>
<p>分片可以通过两种方式创建，第一种方式就是上面的代码中使用的方式：</p>
<pre><code>    slice1 := array1[10:15]
</code></pre>
<p>这样创建的slice1索引的是数组的从0开始编号的第10个、第11个、第12个、第13个、第14个个成员，总计5个。</p>
<pre><code>10
11
12
13
14
</code></pre>
<blockquote>
<p>注意[10:15]是一个前闭后开的集合，即包括10，不包括15。</p>
</blockquote>
<p>第二种方式是使用内置的<code>make</code>函数创建。</p>
<pre><code>make([]T, length, capacity)
</code></pre>
<p>使用make创建的时候，至少需要指定分片的长度，make会为分片创建一个隐藏的数组。</p>
<p>如果指定了capacity，数组的长度就是capacity，如果没有指定，数组的长度等于分片的长度。</p>
<p>例如下面的代码中slice2的长度和容量都是10，slice3的长度是10，容量是20。</p>
<pre><code>package main

func main() {
    //not allow
    //slice1 := make([]int)
    //println(&quot;slice1， len is &quot;, len(slice1), &quot;capacity is &quot;, cap(slice1))

    slice2 := make([]int, 10)
    println(&quot;slice2， len is &quot;, len(slice2), &quot;capacity is &quot;, cap(slice2))

    slice3 := make([]int, 10, 20)
    println(&quot;slice3， len is &quot;, len(slice3), &quot;capacity is &quot;, cap(slice3))
}
</code></pre>
<p>通过make创建分片，相当与新建一个数组，然后取它的[0:length]。</p>
<pre><code>make([]int, 50, 100)
</code></pre>
<p>等同于：</p>
<pre><code>new([100]int)[0:50]
</code></pre>
<h3 id="结构体struct-types"><a class="header" href="#结构体struct-types">结构体(Struct types)</a></h3>
<p>结构体(Struct)是比较复杂的类型，它是由多个命名变量组成，这些变量每个都有名字和类型，被成为&quot;结构体成员(field)&quot;。</p>
<pre><code>StructType     = &quot;struct&quot; &quot;{&quot; { FieldDecl &quot;;&quot; } &quot;}&quot; .
FieldDecl      = (IdentifierList Type | AnonymousField) [ Tag ] .
AnonymousField = [ &quot;*&quot; ] TypeName .
Tag            = string_lit .
</code></pre>
<p>go语言的struct用法与C语言中的不同，C语言中是“struct 结构体名{ 结构体成员...}”，go语言中没有中间的结构体名。如果要给go的结构体命名，需要使用关键type：</p>
<pre><code>type 结构体名 struct{
	结构体成员
}
</code></pre>
<p>结构体成员的名称可以显示声明(IdentifierList Type)，也可以隐式声明(AnonymousField)。</p>
<p>隐式声明明是不为变量设置明确的标识符时，变量的名字默认为类型的名字。例如：</p>
<pre><code>struct {
    T1        // field name is T1
    *T2       // field name is T2
    P.T3      // field name is T3
    *P.T4     // field name is T4
    x, y int  // field names are x and y
}
</code></pre>
<p>go语言中的隐式声明的成员，其实有一点C++中的继承的意思，例如在下面的定义中，结构体B可以直接使用它的隐式成员A的结构体成员：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

type A struct {
    A1 string
    A2 string
}

type B struct {
    A
    B1 string
    B2 string
}

func main() {
    b := B{
        A: A{
            A1: &quot;a1&quot;,
            A2: &quot;a2&quot;,
        },
        B1: &quot;b1&quot;,
        B2: &quot;b2&quot;,
    }
    fmt.Println(b.A)
    fmt.Println(b.A.A1)
    fmt.Println(b.A1)
}
</code></pre>
<p>在上面的代码中，结构体B没有显示声明为A1的成员，因此<code>b.A1</code>索引的是它的隐式成员A的成员。</p>
<p>如果结构体B有一个名为A1的显示成员，那么只能通过<code>b.A.A1</code>的方式索引到A的成员A1，<code>b.A</code>索引的将是B的显示成员A1。</p>
<p>例如下面代码中，最后一行打印的是<code>b1's a1</code>。</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

type A struct {
    A1 string
    A2 string
}

type B struct {
    A
    A1 string
    B1 string
    B2 string
}

func main() {
    b := B{
        A: A{
            A1: &quot;a1&quot;,
            A2: &quot;a2&quot;,
        },
        A1: &quot;b's a1&quot;,
        B1: &quot;b1&quot;,
        B2: &quot;b2&quot;,
    }
    fmt.Println(b.A)
    fmt.Println(b.A.A1)
    fmt.Println(b.A1)
}
</code></pre>
<p>同一个结构体内的成员不能重名，在使用隐式声明的时候要特别注意，因为一个类型与它的指针类型，在被隐式声明的时候，会得到相同的变量名。例如下面的结构体的三个成员的名字都是<code>T</code>，这是不允许的。</p>
<pre><code>struct {
    T     // conflicts with anonymous field *T and *P.T
    *T    // conflicts with anonymous field T and *P.T
    *P.T  // conflicts with anonymous field T and *T
}
</code></pre>
<p>隐式声明的<code>T</code>和隐式声明的<code>*T</code>的区别之一是这个隐式声明的变量的存放位置。另外go语言声称：</p>
<pre><code>If S contains an anonymous field T, the method sets of S and *S both include promoted methods with receiver T. The method set of *S also includes promoted methods with receiver *T.

If S contains an anonymous field *T, the method sets of S and *S both include promoted methods with receiver T or *T.
</code></pre>
<p>但是试验却发现，下面的两段代码执行的效果是相同的。</p>
<p>代码一，隐式成员为<code>A</code>：</p>
<pre><code>package main

type A struct {
    A1 string
}

type B struct {
    A
    B1 string
    B2 string
}

func main() {
    b := B{
        A: A{
            A1: &quot;a1&quot;,
        },
        B1: &quot;b1&quot;,
        B2: &quot;b2&quot;,
    }

    b.method()
    println(b.A1)

    b.pointer_method()
    println(b.A1)

    pb := &amp;b

    pb.method()
    println(b.A1)

    pb.pointer_method()
    println(b.A1)
}
</code></pre>
<p>代码二，隐式成员为<code>*A</code>：</p>
<pre><code>package main

type A struct {
    A1 string
}

func (a A) method() {
    a.A1 = &quot;method set a1&quot;
}

func (a *A) pointer_method() {
    a.A1 = &quot;pointer method set a1&quot;
}

type B struct {
    *A
    B1 string
    B2 string
}

func main() {
    b := B{
        A: &amp;A{
            A1: &quot;a1&quot;,
        },
        B1: &quot;b1&quot;,
        B2: &quot;b2&quot;,
    }

    b.method()
    println(b.A1)

    b.pointer_method()
    println(b.A1)

    pb := &amp;b

    pb.method()
    println(b.A1)

    pb.pointer_method()
    println(b.A1)
}
</code></pre>
<p>go语言中可以在每个结构体成员后面跟随一个标签(tag)，标签用来注明成员的属性。标签可以是解释型字符串，也可以是原始型字符串。</p>
<pre><code>Tag            = string_lit .
string_lit     = raw_string_lit | interpreted_string_lit .
</code></pre>
<p>另外，在结构体中还可以添加只起到填充(padding)作用的成员：</p>
<pre><code>// A struct with 6 fields.
struct {
    x, y int
    u float32
    _ float32  // padding
    A *[]int
    F func()
}
</code></pre>
<h3 id="指针pointer-types"><a class="header" href="#指针pointer-types">指针(Pointer types)</a></h3>
<p>指针类型比较简单：</p>
<pre><code>PointerType = &quot;*&quot; BaseType .
BaseType    = Type .
</code></pre>
<p>支持多重指针：</p>
<pre><code>package main

func main() {
    i := 8
    pi := &amp;i
    ppi := &amp;pi

    println(*ppi, pi)
    println(*pi, i)
}
</code></pre>
<h3 id="函数function-types"><a class="header" href="#函数function-types">函数(Function types)</a></h3>
<p>go语言的函数的声明格式与其它语言也有所不同。</p>
<pre><code>FunctionType   = &quot;func&quot; Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = &quot;(&quot; [ ParameterList [ &quot;,&quot; ] ] &quot;)&quot; .
ParameterList  = ParameterDecl { &quot;,&quot; ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ &quot;...&quot; ] Type .
</code></pre>
<p>可以由以下几种样式的函数：</p>
<pre><code>func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
</code></pre>
<p>最显著的不同是，参数的类型是在参数名之后的，如果两个参数类型相同且位置相临，可以省略前一个参数的类型，例如：</p>
<pre><code>func(a, b int, z float32) (bool)
</code></pre>
<p>函数的最后一个参数可以是变长参数(variadic)，可以对应0个到多个输入参数：</p>
<pre><code>func(prefix string, values ...int)
</code></pre>
<p>函数可以有多个返回值：</p>
<pre><code>func(int, int, float64) (float64, *[]int)
</code></pre>
<p>也可以返回函数：</p>
<pre><code>func(n int) func(p *T)
</code></pre>
<p>注意，这里给出的是函数类型，函数类型不等于函数的声明与实现，函数的声明与实现在后面章节中。</p>
<h3 id="接口interface-types"><a class="header" href="#接口interface-types">接口(Interface types)</a></h3>
<p>接口类型的格式如下：</p>
<pre><code>InterfaceType      = &quot;interface&quot; &quot;{&quot; { MethodSpec &quot;;&quot; } &quot;}&quot; .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
</code></pre>
<p>例如：</p>
<pre><code>interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
    Close()
}
</code></pre>
<p>接口的成员是方法(method)，一个类型只要实现一个接口中的所有方法的类型，可以作为类型为该接口的变量的的动态类型。</p>
<p>例如下面的T就实现了上面的接口：</p>
<pre><code>func (p T) Read(b Buffer) bool { return … }
func (p T) Write(b Buffer) bool { return … }
func (p T) Close() { … }
</code></pre>
<p>一个类型可以实现多个接口的方法，也可以是空的，不包含任何的方法：</p>
<pre><code>interface{}
</code></pre>
<p>接口可以包含其它的接口，但是不能包含它自身，或者通过其它接口形成了重复包含：</p>
<pre><code>// illegal: Bad cannot embed itself
type Bad interface {
    Bad
}

// illegal: Bad1 cannot embed itself using Bad2
type Bad1 interface {
    Bad2
}
type Bad2 interface {
    Bad1
}
</code></pre>
<h3 id="字典map-types"><a class="header" href="#字典map-types">字典(Map types)</a></h3>
<p>go语言原生支持字典(map)。</p>
<pre><code>MapType     = &quot;map&quot; &quot;[&quot; KeyType &quot;]&quot; ElementType .
KeyType     = Type .
</code></pre>
<p>Key的类型不能是函数(function)、字典(map)、分片(slice)</p>
<p>如果Key的类型是接口，可以作为该接口变量的动态类型的类型必须是可比较的，否则会panic。</p>
<p>字典中的成员数量成为字典的长度(length)，可以通过内置函数len()获取。</p>
<p>字典的成员可以通过赋值操作增加，用Key作为index读取。</p>
<p>如果要删除字典中的成员，需要使用内置的delete()函数。</p>
<p>map需要使用内置函数make创建:</p>
<pre><code>make(map[string]int)
make(map[string]int, 100)
</code></pre>
<p>创建时指定length意思是，预先分配出可以容纳这么多成员的空间，而不是只能容纳这么多。</p>
<p>map的长度不受创建时指定的length的限制，可以无限增加成员。</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    m := make(map[int]int, 10)
    for i := 0; i &lt; 10; i++ {
        m[i] = i
    }
    println(len(m))
    fmt.Println(m)
    m[11] = 11
    println(len(m))
    fmt.Println(m)
}
</code></pre>
<h3 id="通道channel-types"><a class="header" href="#通道channel-types">通道(Channel types)</a></h3>
<p>通道是用来在并发编程中传递value的。</p>
<pre><code>ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType .
</code></pre>
<p>它可以是可读、可写、既可读又可写的，例如：</p>
<pre><code>chan T          // can be used to send and receive values of type T
chan&lt;- float64  // can only be used to send float64s
&lt;-chan int      // can only be used to receive ints
</code></pre>
<p>&lt;- 是靠左临近的，通道类型本身也开始被传递：</p>
<pre><code>chan&lt;- chan int    // same as chan&lt;- (chan int)
chan&lt;- &lt;-chan int  // same as chan&lt;- (&lt;-chan int)
&lt;-chan &lt;-chan int  // same as &lt;-chan (&lt;-chan int)
chan (&lt;-chan int)
</code></pre>
<p>通道类型的变量必须用内置的make函数创建：</p>
<pre><code>make(chan int, 100)
</code></pre>
<p>第二参数是指定通道中可以缓存的成员的数量，如果没有第二个参数或者第二个参数为0，那么该通道是不做缓存的，必须等对方接收或者写入完成后，才可以完成写入或接收。</p>
<p>通道需要由写入方使用内置的close函数关闭，接收方收取了最后一个数据后，再从通道中试图读取的时候，会立即返回失败。</p>
<p>例如，如果通道c被关闭，且通道中没有数据了，下面的语句将会立即返回，且ok是false。</p>
<pre><code>x, ok := &lt;-c
</code></pre>
<p>通道是并发安全的，使用内置函数len读取通道中缓存的数据个数，或者用cap读取通道容量，不需要考虑并发的影响。</p>
<p>另外通道中的数据遵循先入先出的规则。</p>
<h2 id="参考-9"><a class="header" href="#参考-9">参考</a></h2>
<ol>
<li><a href="https://golang.org/ref/spec#Lexical_elements" title="go Lexical elements">go Lexical elements</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="代码区块声明声明作用域名"><a class="header" href="#代码区块声明声明作用域名">代码区块、声明、声明作用域名</a></h1>
<p>声明的影响是有范围的，它的影响范围叫做作用域，作用域对应的是代码区块。</p>
<h2 id="代码区块blocks"><a class="header" href="#代码区块blocks">代码区块(blocks)</a></h2>
<pre><code>Block = &quot;{&quot; StatementList &quot;}&quot; .
StatementList = { Statement &quot;;&quot; } .
</code></pre>
<p>在go中有这样几种代码区块：</p>
<pre><code>所有的代码组成一个终极区块(universe block)
隶属于同一个package的代码，组成对应的包区块(package block)
同一个文件中的代码，组成一个文件区块(file block)
if、for、switch语句包裹的代码，组成了独立的隐式区块(implicit block)
switch、select的条件(clause)语句中的代码，组成了独立的隐式区块
&quot;{&quot;和&quot;}&quot;包裹的代码，组成一个隐式区块
</code></pre>
<h2 id="声明的作用域declarations-and-scope"><a class="header" href="#声明的作用域declarations-and-scope">声明的作用域(Declarations and scope)</a></h2>
<p>声明就是设置标记符(identifier)的过程，实现标记符以下内容的绑定：</p>
<pre><code>constant，常量
type，类型
variable，变量
function，函数
label，标记
package，包
</code></pre>
<p>声明的语法格式：</p>
<pre><code>Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
</code></pre>
<p>在包区块中，<code>init</code>只能用于声明init函数。</p>
<p>声明的效果是限定在区块中的。</p>
<pre><code>go内置的标记符在终极区块(universe block)中有效
在函数之外声明的常量、类型、变量、函数在包区块(package block)中有效，注意不包括方法(method)。
通过import导入的包(package)的名字，在文件区块(file block)中有效
声明的方法的接收者(receiver)、函数参数、函数返回值，在函数的代码区块中有效
在函数的代码区块中声明的常量、变量、类型，在声明位置和所在的最内层区块的末尾之间有效
</code></pre>
<p>代码区块是可以嵌套的，内层代码区块中的声明在内存代码区块中覆盖外层代码区块中的声明。</p>
<h2 id="标记作用域label-scopes"><a class="header" href="#标记作用域label-scopes">标记作用域(Label scopes)</a></h2>
<p>标记(Label)的作用域与其它的标记符不同，它被用于<code>break</code>、<code>continue</code>、<code>goto</code>。</p>
<p>标记一旦声明，必须使用，否则编译报错。</p>
<p>标记在函数内声明，它在整个函数区块以及函数区块的嵌入区块中有效，并且可以与其它标识符同名，</p>
<h2 id="内置的标记符"><a class="header" href="#内置的标记符">内置的标记符</a></h2>
<p>go内置了空白标记符(Blank identifier)和预声明的标记服(Predeclared identifiers)。</p>
<p>空白标记符就是一个下划线<code>_</code>，表示对应的目标不被声明。</p>
<p>预声明的标记符有以下这些:</p>
<pre><code>Types:
    bool byte complex64 complex128 error float32 float64
    int int8 int16 int32 int64 rune string
    uint uint8 uint16 uint32 uint64 uintptr

Constants:
    true false iota

Zero value:
    nil

Functions:
    append cap close complex copy delete imag len
    make new panic print println real recover
</code></pre>
<h2 id="标识符的导出exported-identifiers"><a class="header" href="#标识符的导出exported-identifiers">标识符的导出(Exported identifiers)</a></h2>
<p>可以将包区块(package block)中的满足条件的标记符导出到其它包区块中。</p>
<pre><code>标记符必须以大写字母开头(Unicode upper case letter)
标记符是在包区块中声明的，或者是结构的成语名（filed name)、方法名(method name)
</code></pre>
<p>不符合这两点的标记符不能导出。</p>
<h2 id="标记符的唯一性uniqueness-of-identifiers"><a class="header" href="#标记符的唯一性uniqueness-of-identifiers">标记符的唯一性(Uniqueness of identifiers)</a></h2>
<p>不同名的两个标记符是不同的，在不同的包中同名的两个标记符也不同的。</p>
<h2 id="常量的声明constant-declarations"><a class="header" href="#常量的声明constant-declarations">常量的声明(Constant declarations)</a></h2>
<p>常量的声明是将常量、常量表达式绑定到指定的标记符，之后可用标记符读取常量。</p>
<pre><code>ConstDecl      = &quot;const&quot; ( ConstSpec | &quot;(&quot; { ConstSpec &quot;;&quot; } &quot;)&quot; ) .
ConstSpec      = IdentifierList [ [ Type ] &quot;=&quot; ExpressionList ] .

IdentifierList = identifier { &quot;,&quot; identifier } .
ExpressionList = Expression { &quot;,&quot; Expression } .
</code></pre>
<p>有以下几种声明样式：</p>
<pre><code>const Pi float64 = 3.14159265358979323846
const zero = 0.0         // untyped floating-point constant
const (
    size int64 = 1024
    eof        = -1  // untyped integer constant
)
const a, b, c = 3, 4, &quot;foo&quot;  // a = 3, b = 4, c = &quot;foo&quot;, untyped integer and string constants
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
</code></pre>
<p>在使用小括号样式时，如果后续声明的常量表达式是相同的，那么可以省略这些常量表达样式。</p>
<p>下面的声明:</p>
<pre><code>const (
    Sunday = iota
    Monday
    Tuesday
)
</code></pre>
<p>等同于：</p>
<pre><code>const (
    Sunday = iota
    Monday = iota
    Tuesday = iota
)
</code></pre>
<p>go内置常量iota是一个特殊的常量表达式，它在<code>const</code>关键字之后第一次出现是value是0，在后续的每次声明中，value增加1，直到遇到下一个const后，重新归零。</p>
<pre><code>const ( // iota is reset to 0
    c0 = iota  // c0 == 0
    c1 = iota  // c1 == 1
    c2 = iota  // c2 == 2
)

const ( // iota is reset to 0
    a = 1 &lt;&lt; iota  // a == 1
    b = 1 &lt;&lt; iota  // b == 2
    c = 3          // c == 3  (iota is not used but still incremented)
    d = 1 &lt;&lt; iota  // d == 8
)

const ( // iota is reset to 0
    u         = iota * 42  // u == 0     (untyped integer constant)
    v float64 = iota * 42  // v == 42.0  (float64 constant)
    w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0  (iota has been reset)
const y = iota  // y == 0  (iota has been reset)
</code></pre>
<p>注意，在同一个声明中出现的多个itoa的value是相同的：</p>
<pre><code>const (
    bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0
    bit1, mask1                           // bit1 == 2, mask1 == 1
    _, _                                  // skips iota == 2
    bit3, mask3                           // bit3 == 8, mask3 == 7
)
</code></pre>
<h2 id="类型声明"><a class="header" href="#类型声明">类型声明</a></h2>
<p>类型用关键字type进行声明。</p>
<pre><code>TypeDecl     = &quot;type&quot; ( TypeSpec | &quot;(&quot; { TypeSpec &quot;;&quot; } &quot;)&quot; ) .
TypeSpec     = identifier Type .
</code></pre>
<p>类型声明也有几种样式:</p>
<pre><code>type IntArray [16]int

type (
    Point struct{ x, y float64 }
    Polar Point
)

type TreeNode struct {
    left, right *TreeNode
    value *Comparable
}

type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}
</code></pre>
<p>需要注意，为一个类型声明了另一个标记符之后，这个标记符对应的类型不会得到被声明的类型的方法。</p>
<pre><code>// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of the base type of PtrMutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex
</code></pre>
<h2 id="变量的声明variable-declarations"><a class="header" href="#变量的声明variable-declarations">变量的声明(Variable declarations)</a></h2>
<pre><code>VarDecl     = &quot;var&quot; ( VarSpec | &quot;(&quot; { VarSpec &quot;;&quot; } &quot;)&quot; ) .
VarSpec     = IdentifierList ( Type [ &quot;=&quot; ExpressionList ] | &quot;=&quot; ExpressionList ) .
</code></pre>
<p>变量有以下几种声明格式:</p>
<pre><code>var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
    i       int
    u, v, s = 2.0, 3.0, &quot;bar&quot;
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // map lookup; only interested in &quot;found&quot;
</code></pre>
<p>如果声明时没有赋值，变量的值为对应的类型的零值(zero value)。</p>
<p>如果声明时没有指定类型，变量的类型根据赋的值推导出来：</p>
<pre><code>var d = math.Sin(0.5)  // d is float64
var i = 42             // i is int
var t, ok = x.(T)      // t is T, ok is bool
</code></pre>
<p>特别注意，如果没有指定类型，赋值时不能使用nil：</p>
<pre><code>var n = nil            // illegal
</code></pre>
<h2 id="变量的简单声明short-variable-declarations"><a class="header" href="#变量的简单声明short-variable-declarations">变量的简单声明(Short variable declarations)</a></h2>
<p>变量还可以使用简短的方式声明。</p>
<pre><code>ShortVarDecl = IdentifierList &quot;:=&quot; ExpressionList .
</code></pre>
<p>例如：</p>
<pre><code>i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() returns two values
_, y, _ := coord(p)  // coord() returns three values; only interested in y coordinate
</code></pre>
<p>使用简短方式时必须注意，&quot;:=&quot;右边必须有新的标记符：</p>
<pre><code>field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclares offset
a, a := 1, 2                              // illegal: double declaration of a or no new variable 
                                          // if a was declared elsewhere
</code></pre>
<p>简单方式比较适合在&quot;if&quot;、&quot;for&quot;、&quot;switch&quot;语句声明只会在本区块中使用的变量。</p>
<h2 id="函数的声明function-declarations"><a class="header" href="#函数的声明function-declarations">函数的声明(Function declarations)</a></h2>
<p>函数使用关键字<code>func</code>声明。</p>
<pre><code>FunctionDecl = &quot;func&quot; FunctionName ( Function | Signature ) .
FunctionName = identifier .
Function     = Signature FunctionBody .
FunctionBody = Block .
</code></pre>
<p>如果函数类型中有返回值，函数声明中必须在每个路径的最后进行return。</p>
<pre><code>func IndexRune(s string, r rune) int {
    for i, c := range s {
        if c == r {
            return i
        }
    }
    // invalid: missing return statement
}
</code></pre>
<p>可以声明一个不是用go实现的函数，在声明中省略函数体即可。</p>
<pre><code>func flushICache(begin, end uintptr)  // implemented externally
</code></pre>
<h2 id="方法的声明method-declarations"><a class="header" href="#方法的声明method-declarations">方法的声明(Method declarations)</a></h2>
<p>方法也用关键字<code>func</code>声明，但是格式不同，比函数声明多了一个Receiver。</p>
<pre><code>MethodDecl   = &quot;func&quot; Receiver MethodName ( Function | Signature ) .
Receiver     = Parameters .
</code></pre>
<p>Receiver的类型是<code>T</code>或者<code>*T</code>，T的类型不能是指针和接口，并且必须是在同一个包中定义的。</p>
<p>Receiver可以设置标记符，标记符在方法的区块中有效，且不能与方法中的其它标记符重名。</p>
<pre><code>func (p *Point) Length() float64 {
   return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
   p.x *= factor
   p.y *= factor
}
</code></pre>
<p>方法的类型是函数，例如上面声明的方法Scale，它的类型是：</p>
<pre><code>func(p *Point, factor float64)
</code></pre>
<h2 id="参考-10"><a class="header" href="#参考-10">参考</a></h2>
<ol>
<li><a href="https://golang.org/ref/spec#Lexical_elements" title="go Lexical elements">go Lexical elements</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="表达式expressions-与运算符operator"><a class="header" href="#表达式expressions-与运算符operator">表达式(Expressions) 与运算符(Operator)</a></h1>
<h2 id="表达式"><a class="header" href="#表达式">表达式</a></h2>
<p>表达式是用运算符和函数的描述的一个计算过程。</p>
<h3 id="常量表达式constant-expressions"><a class="header" href="#常量表达式constant-expressions">常量表达式(Constant expressions)</a></h3>
<p>常量表达式在编译时执行，常量表达式中只能使用常量。</p>
<p>使用常量表达式时，需要特别注意未明确声明类型的常量的类型。</p>
<pre><code>const a = 2 + 3.0             // a == 5.0   (untyped floating-point constant)
const b = 15 / 4              // b == 3     (untyped integer constant)
const c = 15 / 4.0            // c == 3.75  (untyped floating-point constant)
const Θ float64 = 3/2         // Θ == 1.0   (type float64, 3/2 is integer division)
const Π float64 = 3/2.        // Π == 1.5   (type float64, 3/2. is float division)
const d = 1 &lt;&lt; 3.0            // d == 8     (untyped integer constant)
const e = 1.0 &lt;&lt; 3            // e == 8     (untyped integer constant)
const f = int32(1) &lt;&lt; 33      // illegal    (constant 8589934592 overflows int32)
const g = float64(2) &gt;&gt; 1     // illegal    (float64(2) is a typed floating-point constant)
const h = &quot;foo&quot; &gt; &quot;bar&quot;       // h == true  (untyped boolean constant)
const j = true                // j == true  (untyped boolean constant)
const k = 'w' + 1             // k == 'x'   (untyped rune constant)
const l = &quot;hi&quot;                // l == &quot;hi&quot;  (untyped string constant)
const m = string(k)           // m == &quot;x&quot;   (type string)
const Σ = 1 - 0.707i          //            (untyped complex constant)
const Δ = Σ + 2.0e-4          //            (untyped complex constant)
const Φ = iota*1i - 1/1i      //            (untyped complex constant)
</code></pre>
<p>complex是内置的函数，返回常量：</p>
<pre><code>const ic = complex(0, c)      // ic == 3.75i  (untyped complex constant)
const iΘ = complex(0, Θ)      // iΘ == 1i     (type complex128)
</code></pre>
<p>如果常量的值超过了能够表达的范围，这个常量可以作为中间值使用：</p>
<pre><code>const Huge = 1 &lt;&lt; 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)
const Four int8 = Huge &gt;&gt; 98  // Four == 4                                (type int8)
</code></pre>
<p>除数不能为0：</p>
<pre><code>const n = 3.14 / 0.0          // illegal: division by zero
</code></pre>
<p>不可以将常量转换为不匹配的类型：</p>
<pre><code>uint(-1)     // -1 cannot be represented as a uint
int(3.14)    // 3.14 cannot be represented as an int
int64(Huge)  // 1267650600228229401496703205376 cannot be represented as an int64
Four * 300   // operand 300 cannot be represented as an int8 (type of Four)
Four * 100   // product 400 cannot be represented as an int8 (type of Four)
</code></pre>
<h3 id="选择表达式selector"><a class="header" href="#选择表达式selector">选择表达式(Selector)</a></h3>
<p>选择表达式的格式如下:</p>
<pre><code>x.f
</code></pre>
<p>其中f是选择器(selector)，类型为f，它不能是空白标记符<code>_</code>。</p>
<p>如果x是包名，那么选择的是包中的标记符。</p>
<p>f可以是x的成员、方法、匿名成员、匿名成员的方法，到达f时经过的选择次数是f的深度(depth)。</p>
<p>如果f是x的直接成员，深度为0，f是x的直接匿名成员的成员，深度为f在匿名成员中的深度+1。</p>
<p>选择表达式遵循下面的规则：</p>
<pre><code>x的类型为T或者*T，并且T不是指针和接口，x.f是T中深度最小的名为f的成员。
x的类型为T，T是接口, x.f是x的动态类型的名为f的方法。
如果x是指针，x.f是(*x).f的简写，两者等同
</code></pre>
<p>如果按照上面的规则，找不到f，编译或运行时报错。</p>
<p>对于下面的代码：</p>
<pre><code>type T0 struct {
	x int
}

func (*T0) M0()

type T1 struct {
	y int
}

func (T1) M1()

type T2 struct {
	z int
	T1
	*T0
}

func (*T2) M2()

type Q *T2

var t T2     // with t.T0 != nil
var p *T2    // with p != nil and (*p).T0 != nil
var q Q = p
</code></pre>
<p>可以有这么些选择方法：</p>
<pre><code>t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x

p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x

q.x          // (*(*q).T0).x        (*q).x is a valid field selector

p.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver
p.M1()       // ((*p).T1).M1()      M1 expects T1 receiver
p.M2()       // p.M2()              M2 expects *T2 receiver
t.M2()       // (&amp;t).M2()           M2 expects *T2 receiver, see section on Calls
</code></pre>
<p>注意q没有选择<code>M0()</code>，因为M0()的Reciver类型是<code>*T1</code>，类型Q中不能继承T1的方法。</p>
<h3 id="方法表达式method-expressions"><a class="header" href="#方法表达式method-expressions">方法表达式(Method expressions)</a></h3>
<p>方法(method)表达式就是方法的实现语句。</p>
<pre><code>MethodExpr    = ReceiverType &quot;.&quot; MethodName .
ReceiverType  = TypeName | &quot;(&quot; &quot;*&quot; TypeName &quot;)&quot; | &quot;(&quot; ReceiverType &quot;)&quot; .
</code></pre>
<p>与函数的不同的是，方法是有接收者(Receiver)的，如下：</p>
<pre><code>type T struct {
        a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
</code></pre>
<p>方法是属于类型的，类型的方法和类型的指针的方法是不同的。</p>
<p>类型的方法是一个将接收者作为参数传入的函数，例如在上面例子中:</p>
<pre><code>T.Mv 的类型为 func(tv T, a int) int
T.Mp 的类型为 func(tv *T, a int) int
</code></pre>
<p>类型的方法可以直接通过类型名调用：</p>
<pre><code>T.Mv(t, 7)             //注意要传入接收者
(T).Mv(t, 7)
(*T).Mp(&amp;t, 7)         //注意传入的是接收者是指针
</code></pre>
<p>类型不能调用类型指针的方法，类型指针可以调用类型的方法：</p>
<pre><code>T.Mp(&amp;t,7)       //Mp是(*T)的方法，不允许T调用
(*T).Mv(t,7)     //Mv是T的方法，*T可以调用
</code></pre>
<p>也可以把方法赋值给变量，然后通过变量调用:</p>
<pre><code>f1 := T.Mv; f1(t, 7)         //要传入接受者t
f2 := (T).Mv; f2(t, 7)       //要传入接受者t

f3 := T.Mp; f3(&amp;t, 7)         //要传入接受者&amp;t
f4 := (T).Mp; f4(&amp;t, 7)       //要传入接受者&amp;t
</code></pre>
<p>也可以通过该类型的变量调用，这时候不需要传入接收者。</p>
<pre><code>t.Mv(7)
t.Mp(7)
</code></pre>
<p>因为变量的方法和类型的方法是不同的，所以不需要传入接收者。</p>
<pre><code>t.Mv 的类型为 func(a int) int
t.Mp 的类型为 func(a int) int
</code></pre>
<p>无论一个变量(t)是不是指针(类型为<code>*T</code>的变量），它都既可以调用类型(T)的方法，也可以调用类型指针(<code>*T</code>)的方法。go语言自身代为完成了取址和取值操作。</p>
<p>变量的方法也可以存放单独的变量中，然后通过变量调用：</p>
<pre><code>f := t.Mv; f(7)   // like t.Mv(7)
f := pt.Mp; f(7)  // like pt.Mp(7)
f := pt.Mv; f(7)  // like (*pt).Mv(7)
f := t.Mp; f(7)   // like (&amp;t).Mp(7)
f := makeT().Mp   // invalid: result of makeT() is not addressable
</code></pre>
<p>变量的类型为接口时，用同样的方式调用方法：</p>
<pre><code>var i interface { M(int) } = myVal
f := i.M; f(7)  // like i.M(7)
</code></pre>
<h3 id="索引表达式index-expressions"><a class="header" href="#索引表达式index-expressions">索引表达式(Index expressions)</a></h3>
<p>索引表达式格式如下：</p>
<pre><code>a[x]
</code></pre>
<p>a的类型不同，表达式的运行结果不同。</p>
<pre><code>如果a不是字典，x的必须是整数，并且0&lt;= x &lt;len(a)
如果a是数组，返回数组中x位置处的成员，如果x超出数组范围，程序panic
如果a是指向数组的指针，a[x]等同于(*a)[x]
如果a是分片(Slice)， a[x]返回x位置处的数组成员，如果x超出范围，程序panic
如果a是字符串，返回x位置处的字符，如果x超出范围，程序panic，且a[x]不能被赋值
如果a是字典(map)，x的类型必须是字典的key的类型，返回字典中x对应的值，和表示对应成员是否存在的布尔类型的值(bool)
如果a是字典(map)，且a的值是nil，a[x]返回字典中成员类型的零值
</code></pre>
<h3 id="分片表达式slice-expressions"><a class="header" href="#分片表达式slice-expressions">分片表达式(Slice expressions)</a></h3>
<p>分片表达式适用于字符串、数组、指向数组的指针和分片。</p>
<pre><code>a[low : high]
</code></pre>
<p>返回一个从零开始，长度为high-low的分片。</p>
<pre><code>a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
</code></pre>
<p>得到分片s的情况如下：</p>
<pre><code>s[0] == 2
s[1] == 3
s[2] == 4
</code></pre>
<p>分片表达式中low和high省略：</p>
<pre><code>a[2:]  // same as a[2 : len(a)]
a[:3]  // same as a[0 : 3]
a[:]   // same as a[0 : len(a)]
</code></pre>
<p>如果a是指向数组的指针，a[low:high]等同于<code>(*a)[low:high]</code>。</p>
<p>如果a是字符串、数组、指向数组的指针，low和high的取值范围为：</p>
<pre><code>0 &lt;= low &lt;= high &lt;= len(a)
</code></pre>
<p>如果a是分片，low和high的取值范围为：</p>
<pre><code>0 &lt;= low &lt;= high &lt;= cap(a)
</code></pre>
<p>low和high超出范围时，引发panic。</p>
<p>如果a是已经声明字符串、分片，返回值也是字符串、分片。</p>
<p>如果a是未声明的字符串，返回一个类型为字符串的变量.</p>
<p>如果a是数组，返回指向这个数组的分片。</p>
<h3 id="完整分片表达式full-slice-expressions"><a class="header" href="#完整分片表达式full-slice-expressions">完整分片表达式(Full slice expressions)</a></h3>
<p>完整的分片表达式还带有一个max，限定返回的分片的容量为(capacity)为<code>max-low</code>。</p>
<pre><code>a[low : high : max]
</code></pre>
<p>在完整的分片表达式中，只有low可以省略，默认为0。</p>
<p>如果a是字符串、数组、指向数组的指针，low和high的取值范围为：</p>
<pre><code>0&lt;= low &lt;= high &lt;= max &lt;= len(a)
</code></pre>
<p>如果a是分片，low、high和max的取值范围为：</p>
<pre><code>0&lt;= low &lt;= high &lt;= max &lt;= cap(a)
</code></pre>
<p>如果超出范围，引发panic。</p>
<h3 id="类型断言表达式type-assertions-expressions"><a class="header" href="#类型断言表达式type-assertions-expressions">类型断言表达式(Type assertions expressions)</a></h3>
<p>断言表达式用来判断x是否不为nil，且它的类型是否与T匹配。</p>
<pre><code>x.(T)
</code></pre>
<p>如果T不是接口类型，x的类型必须是接口，判断T是否可以成为x的动态类型。</p>
<p>如果T是接口类型，判断x是否实现了接口T。</p>
<p>如果T不是接口类型，x的类型也不是接口，引发panic。</p>
<p>如果断言成立，表达式的值就是类型为T的x，和布尔值true；如果断言不成立，表达式的值是类型T的零值，和布尔值false。</p>
<h3 id="调用表达式call-expressions"><a class="header" href="#调用表达式call-expressions">调用表达式(Call expressions)</a></h3>
<p>调用表达式适用于函数和方法：</p>
<pre><code>f(a1, a2, … an)
</code></pre>
<p>针对方法使用时，需要带有receiver:</p>
<pre><code>math.Atan2(x, y)  // function call
var pt *Point
pt.Scale(3.5)     // method call with receiver pt
</code></pre>
<p>传入值按值、按顺序传递给函数或方法的参数，返回值也是按值传递的。</p>
<p>如果一个函数的返回值，满足另一个参数的传入参数要求，可以写成<code>f(g(parameters_of_g))</code>，例如：</p>
<pre><code>func Split(s string, pos int) (string, string) {
        return s[0:pos], s[pos:]
}

func Join(s, t string) string {
        return s + t
}

if Join(Split(value, len(value)/2)) != value {
        log.Panic(&quot;test fails&quot;)
}
</code></pre>
<p>调用表达式支持变长参数，变长参数必须是最后一个，且类型前是<code>...</code>。</p>
<p>例如在下面的函数中：</p>
<pre><code>func Greeting(prefix string, who ...string)
</code></pre>
<p>如果以这种方式调用，参数who的值是nil：</p>
<pre><code>Greeting(&quot;nobody&quot;)
</code></pre>
<p>如果以这种方式调用，参数who的值的类型是[]string：</p>
<pre><code>Greeting(&quot;hello:&quot;, &quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;)
</code></pre>
<p>如果以这种方式调用，参数who等于s：</p>
<pre><code>s:= []string{&quot;James&quot;, &quot;Jasmine&quot;}
Greeting(&quot;goodbye:&quot;, s...)
</code></pre>
<h2 id="运算符operator"><a class="header" href="#运算符operator">运算符(Operator)</a></h2>
<p>运算符用于构成表达式。</p>
<pre><code>Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &quot;||&quot; | &quot;&amp;&amp;&quot; | rel_op | add_op | mul_op .
rel_op     = &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; .
add_op     = &quot;+&quot; | &quot;-&quot; | &quot;|&quot; | &quot;^&quot; .
mul_op     = &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&amp;&quot; | &quot;&amp;^&quot; .

unary_op   = &quot;+&quot; | &quot;-&quot; | &quot;!&quot; | &quot;^&quot; | &quot;*&quot; | &quot;&amp;&quot; | &quot;&lt;-&quot; .
</code></pre>
<p>运算符都是go语言内置的。</p>
<pre><code>Precedence    Operator
    5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^
    4             +  -  |  ^
    3             ==  !=  &lt;  &lt;=  &gt;  &gt;=
    2             &amp;&amp;
    1             ||
</code></pre>
<p>优先级相同的二元运算符按照先左后右的顺序结合：</p>
<pre><code>x / y * z
</code></pre>
<p>等同于：</p>
<pre><code>(x / y) * z
</code></pre>
<h3 id="算数运算符arithmetic-operators"><a class="header" href="#算数运算符arithmetic-operators">算数运算符(Arithmetic operators)</a></h3>
<pre><code>+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&amp;    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers
&amp;^   bit clear (AND NOT)    integers

&lt;&lt;   left shift             integer &lt;&lt; unsigned integer
&gt;&gt;   right shift            integer &gt;&gt; unsigned integer
</code></pre>
<h3 id="字符串拼接string-concatenation"><a class="header" href="#字符串拼接string-concatenation">字符串拼接(String concatenation)</a></h3>
<p>字符串可以用运算符&quot;+&quot;进行拼接：</p>
<pre><code>:= &quot;hi&quot; + string(c)
s += &quot; and good bye&quot;
</code></pre>
<h3 id="比较运算符comparison-operators"><a class="header" href="#比较运算符comparison-operators">比较运算符(Comparison operators)</a></h3>
<pre><code>==    equal
!=    not equal
&lt;     less
&lt;=    less or equal
&gt;     greater
&gt;=    greater or equal
</code></pre>
<h3 id="逻辑运算符logical-operators"><a class="header" href="#逻辑运算符logical-operators">逻辑运算符(Logical operators)</a></h3>
<pre><code>&amp;&amp;    conditional AND    p &amp;&amp; q  is  &quot;if p then q else false&quot;
||    conditional OR     p || q  is  &quot;if p then true else q&quot;
!     NOT                !p      is  &quot;not p&quot;
</code></pre>
<h3 id="地址运算符address-operators"><a class="header" href="#地址运算符address-operators">地址运算符(Address operators)</a></h3>
<pre><code>&amp;     
*  
</code></pre>
<h3 id="读取运算符receive-operator"><a class="header" href="#读取运算符receive-operator">读取运算符(Receive operator)</a></h3>
<pre><code>v1 := &lt;-ch
v2 = &lt;-ch
f(&lt;-ch)
&lt;-strobe  // wait until clock pulse and discard received value
</code></pre>
<h3 id="类型转换conversions"><a class="header" href="#类型转换conversions">类型转换(Conversions)</a></h3>
<pre><code>Conversion = Type &quot;(&quot; Expression [ &quot;,&quot; ] &quot;)&quot; .
</code></pre>
<h2 id="参考-11"><a class="header" href="#参考-11">参考</a></h2>
<ol>
<li><a href="https://golang.org/ref/spec#Lexical_elements" title="go Lexical elements">go Lexical elements</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go的状态语句"><a class="header" href="#go的状态语句">go的状态语句</a></h1>
<pre><code>Statement =
    Declaration | LabeledStmt | SimpleStmt |
    GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
    FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
    DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
</code></pre>
<h2 id="终止语句terminating-statements"><a class="header" href="#终止语句terminating-statements">终止语句(Terminating statements)</a></h2>
<p>终止语句是指下的情况：</p>
<pre><code>return
goto
调用内置函数panic(interface{})
if语句以及else语句中语句的结束
for语句语句的结束
switch语句语句
select
labeled 
</code></pre>
<h2 id="空白语句empty-statements"><a class="header" href="#空白语句empty-statements">空白语句(Empty statements)</a></h2>
<p>空白语句不做任何事情：</p>
<pre><code>EmptyStmt = .
</code></pre>
<h2 id="标记语句labeled-statements"><a class="header" href="#标记语句labeled-statements">标记语句(Labeled statements)</a></h2>
<p>标记语句可以是goto、break、continue的目标。</p>
<pre><code>LabeledStmt = Label &quot;:&quot; Statement .
Label       = identifier .
</code></pre>
<h2 id="表达式语句expression-statements"><a class="header" href="#表达式语句expression-statements">表达式语句(Expression statements)</a></h2>
<p>除了下面的内置函数，其它的函数、方法和接收操作符都可以用于表达式语句。</p>
<pre><code>append cap complex imag len make new real
unsafe.Alignof unsafe.Offsetof unsafe.Sizeof
</code></pre>
<h2 id="发送语句send-statements"><a class="header" href="#发送语句send-statements">发送语句(Send statements)</a></h2>
<p>发送语句是专用于向通道(channel)发送数据的。</p>
<pre><code>SendStmt = Channel &quot;&lt;-&quot; Expression .
Channel  = Expression .
</code></pre>
<h2 id="递增递减语句incdec-statements"><a class="header" href="#递增递减语句incdec-statements">递增递减语句(IncDec statements)</a></h2>
<pre><code>IncDecStmt = Expression ( &quot;++&quot; | &quot;--&quot; ) .
</code></pre>
<h2 id="赋值语句assignments"><a class="header" href="#赋值语句assignments">赋值语句(Assignments)</a></h2>
<pre><code>Assignment = ExpressionList assign_op ExpressionList .
assign_op = [ add_op | mul_op ] &quot;=&quot; .
</code></pre>
<h2 id="if语句if-statements"><a class="header" href="#if语句if-statements">if语句(If statements)</a></h2>
<pre><code>IfStmt = &quot;if&quot; [ SimpleStmt &quot;;&quot; ] Expression Block [ &quot;else&quot; ( IfStmt | Block ) ] .
</code></pre>
<h2 id="switch语句switch-statements"><a class="header" href="#switch语句switch-statements">switch语句(Switch statements)</a></h2>
<p>switch语句分为以表达式为依据，和以类型为依据两种形式。</p>
<pre><code>SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
</code></pre>
<p>使用表达式作为分支依据：</p>
<pre><code>ExprSwitchStmt = &quot;switch&quot; [ SimpleStmt &quot;;&quot; ] [ Expression ] &quot;{&quot; { ExprCaseClause } &quot;}&quot; .
ExprCaseClause = ExprSwitchCase &quot;:&quot; StatementList .
ExprSwitchCase = &quot;case&quot; ExpressionList | &quot;default&quot; .
</code></pre>
<p>例如:</p>
<pre><code>switch tag {
default: s3()
case 0, 1, 2, 3: s1()
case 4, 5, 6, 7: s2()
}

switch x := f(); {  // missing switch expression means &quot;true&quot;
case x &lt; 0: return -x
default: return x
}

switch {
case x &lt; y: f1()
case x &lt; z: f2()
case x == 4: f3()
}
</code></pre>
<p>使用类型为依据：</p>
<pre><code>TypeSwitchStmt  = &quot;switch&quot; [ SimpleStmt &quot;;&quot; ] TypeSwitchGuard &quot;{&quot; { TypeCaseClause } &quot;}&quot; .
TypeSwitchGuard = [ identifier &quot;:=&quot; ] PrimaryExpr &quot;.&quot; &quot;(&quot; &quot;type&quot; &quot;)&quot; .
TypeCaseClause  = TypeSwitchCase &quot;:&quot; StatementList .
TypeSwitchCase  = &quot;case&quot; TypeList | &quot;default&quot; .
TypeList        = Type { &quot;,&quot; Type } .
</code></pre>
<p>例如：</p>
<pre><code>switch i := x.(type) {
case nil:
    printString(&quot;x is nil&quot;)                // type of i is type of x (interface{})
case int:
    printInt(i)                            // type of i is int
case float64:
    printFloat64(i)                        // type of i is float64
case func(int) float64:
    printFunction(i)                       // type of i is func(int) float64
case bool, string:
    printString(&quot;type is bool or string&quot;)  // type of i is type of x (interface{})
default:
    printString(&quot;don't know the type&quot;)     // type of i is type of x (interface{})
}
</code></pre>
<h2 id="for语句for-statements"><a class="header" href="#for语句for-statements">for语句(For statements)</a></h2>
<p>for的语句循环条件有三种。</p>
<pre><code>ForStmt = &quot;for&quot; [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .
</code></pre>
<p>简略条件判断：</p>
<pre><code>for a &lt; b {
    a *= 2
}
</code></pre>
<p>完整条件判断：</p>
<pre><code>ForClause = [ InitStmt ] &quot;;&quot; [ Condition ] &quot;;&quot; [ PostStmt ] .
InitStmt = SimpleStmt .
PostStmt = SimpleStmt .
</code></pre>
<p>例如:</p>
<pre><code>for i := 0; i &lt; 10; i++ {
    f(i)
}

for cond { S() }    is the same as    for ; cond ; { S() }
for      { S() }    is the same as    for true     { S() }
</code></pre>
<p>range判断：</p>
<pre><code>RangeClause = [ ExpressionList &quot;=&quot; | IdentifierList &quot;:=&quot; ] &quot;range&quot; Expression .
</code></pre>
<p>需要特别注意的是Expression不同时，<code>range Expression</code>的返回值不同。</p>
<pre><code>Range expression                          1st value          2nd value

array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
string          s  string type            index    i  int    see below  rune
map             m  map[K]V                key      k  K      m[k]       V
channel         c  chan E, &lt;-chan E       element  e  E
</code></pre>
<h2 id="go语句go-statements"><a class="header" href="#go语句go-statements">go语句(Go statements)</a></h2>
<pre><code>Stmt = &quot;go&quot; Expression .
</code></pre>
<h2 id="select语句select-statements"><a class="header" href="#select语句select-statements">select语句(Select statements)</a></h2>
<p>select语句用于执行当前可以执行的语句。</p>
<pre><code>SelectStmt = &quot;select&quot; &quot;{&quot; { CommClause } &quot;}&quot; .
CommClause = CommCase &quot;:&quot; StatementList .
CommCase   = &quot;case&quot; ( SendStmt | RecvStmt ) | &quot;default&quot; .
RecvStmt   = [ ExpressionList &quot;=&quot; | IdentifierList &quot;:=&quot; ] RecvExpr .
RecvExpr   = Expression .
</code></pre>
<p>如果有多个语句当前都可以执行，需要特别注意这些语句的执行顺序。</p>
<pre><code>1. 通道(channel)相关的语句如果同时进入可执行状态，只执行在源码中位置靠前的语句
2. 如果多个语句可以执行，随机选择一个执行。
3. 如果所有语句都不能执行，那么执行default语句，如果没有default语句，进入等待状态
</code></pre>
<p>例如:</p>
<pre><code>var a []int
var c, c1, c2, c3, c4 chan int
var i1, i2 int
select {
case i1 = &lt;-c1:
    print(&quot;received &quot;, i1, &quot; from c1\n&quot;)
case c2 &lt;- i2:
    print(&quot;sent &quot;, i2, &quot; to c2\n&quot;)
case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3
    if ok {
        print(&quot;received &quot;, i3, &quot; from c3\n&quot;)
    } else {
        print(&quot;c3 is closed\n&quot;)
    }
case a[f()] = &lt;-c4:
    // same as:
    // case t := &lt;-c4
    //    a[f()] = t
default:
    print(&quot;no communication\n&quot;)
}

for {  // send random sequence of bits to c
    select {
    case c &lt;- 0:  // note: no statement, no fallthrough, no folding of cases
    case c &lt;- 1:
    }
}

select {}  // block forever
</code></pre>
<h2 id="返回语句return-statements"><a class="header" href="#返回语句return-statements">返回语句(Return statements)</a></h2>
<pre><code>ReturnStmt = &quot;return&quot; [ ExpressionList ] .
</code></pre>
<p>例如:</p>
<pre><code>func simpleF() int {
    return 2
}
</code></pre>
<p>支持多值返回:</p>
<pre><code>func complexF1() (re float64, im float64) {
    return -7.0, -4.0
}
</code></pre>
<p>可以直接将表达式的结果返回：</p>
<pre><code>func complexF2() (re float64, im float64) {
    return complexF1()
}
</code></pre>
<p>还可以命名返回：</p>
<pre><code>func complexF3() (re float64, im float64) {
    re = 7.0
    im = 4.0
    return
}

func (devnull) Write(p []byte) (n int, _ error) {
    n = len(p)
    return
}
</code></pre>
<p>命名的返回的时候，不同有同名的其它变量：</p>
<pre><code>func f(n int) (res int, err error) {
    if _, err := f(n-1); err != nil {
        return  // invalid return statement: err is shadowed
    }
    return
}
</code></pre>
<h2 id="break语句break-statement"><a class="header" href="#break语句break-statement">break语句(Break statement)</a></h2>
<pre><code>BreakStmt = &quot;break&quot; [ Label ] .
</code></pre>
<p>例如:</p>
<pre><code>OuterLoop:
    for i = 0; i &lt; n; i++ {
        for j = 0; j &lt; m; j++ {
            switch a[i][j] {
            case nil:
                state = Error
                break OuterLoop
            case item:
                state = Found
                break OuterLoop
            }
        }
    }
</code></pre>
<h2 id="continue语句continue-statements"><a class="header" href="#continue语句continue-statements">continue语句(Continue statements)</a></h2>
<pre><code>ContinueStmt = &quot;continue&quot; [ Label ] .
</code></pre>
<p>例如:</p>
<pre><code>RowLoop:
	for y, row := range rows {
		for x, data := range row {
			if data == endOfRow {
				continue RowLoop
			}
			row[x] = data + bias(x, y)
		}
	}
</code></pre>
<h2 id="goto语句goto-statements"><a class="header" href="#goto语句goto-statements">goto语句(Goto statements)</a></h2>
<pre><code>GotoStmt = &quot;goto&quot; Label .
</code></pre>
<p>使用goto的时候要特别注意，不要在goto与Label直接存在变量的声明。</p>
<p>例如下面的做法符合语法要求，但是容易造成混乱，在<code>L:</code>之后的位置使用i，会报错：</p>
<pre><code>	goto L  // BAD
	v := 3
L:
</code></pre>
<p>goto只能跳转到所在区块中的标记位置。</p>
<p>例如下面的做法是不符合语法的，L1是另一个区块中的标记。</p>
<pre><code>if n%2 == 1 {
	goto L1
}
for n &gt; 0 {
	f()
	n--
L1:
	f()
	n--
}
</code></pre>
<h2 id="fallthrough语句fallthrough-statements"><a class="header" href="#fallthrough语句fallthrough-statements">fallthrough语句(Fallthrough statements)</a></h2>
<p>fallthrouch用于switch语句中，表示紧邻的下一个语句需要被执行。</p>
<pre><code>FallthroughStmt = &quot;fallthrough&quot; .
</code></pre>
<h2 id="defer语句defer-statements"><a class="header" href="#defer语句defer-statements">defer语句(Defer statements)</a></h2>
<p>defer表示跟随的语句需要在函数执行结束的时候执行。</p>
<pre><code>DeferStmt = &quot;defer&quot; Expression .
</code></pre>
<p>例如：</p>
<pre><code>lock(l)
defer unlock(l)  // unlocking happens before surrounding function returns

// prints 3 2 1 0 before surrounding function returns
for i := 0; i &lt;= 3; i++ {
	defer fmt.Print(i)
}

// f returns 1
func f() (result int) {
	defer func() {
		result++
	}()
	return 0
}
</code></pre>
<h2 id="参考-12"><a class="header" href="#参考-12">参考</a></h2>
<ol>
<li><a href="https://golang.org/ref/spec#Lexical_elements" title="go Lexical elements">go Lexical elements</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go的包管理语句"><a class="header" href="#go的包管理语句">go的包管理语句</a></h1>
<h2 id="声明包"><a class="header" href="#声明包">声明包</a></h2>
<pre><code>PckageClause  = &quot;package&quot; PackageName .
PackageName    = identifier .
</code></pre>
<h2 id="导入包import-declarations-"><a class="header" href="#导入包import-declarations-">导入包(Import declarations )</a></h2>
<pre><code>ImportDecl       = &quot;import&quot; ( ImportSpec | &quot;(&quot; { ImportSpec &quot;;&quot; } &quot;)&quot; ) .
ImportSpec       = [ &quot;.&quot; | PackageName ] ImportPath .
ImportPath       = string_lit .
</code></pre>
<p>例如：</p>
<pre><code>Import declaration          Local name of Sin

import   &quot;lib/math&quot;         math.Sin
import m &quot;lib/math&quot;         m.Sin
import . &quot;lib/math&quot;         Sin
import _ &quot;lib/math&quot;
</code></pre>
<h2 id="参考-13"><a class="header" href="#参考-13">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go的内置函数"><a class="header" href="#go的内置函数">go的内置函数</a></h1>
<p>go内置了一些函数，这些函数可以直接使用。</p>
<h2 id="关闭close"><a class="header" href="#关闭close">关闭(Close)</a></h2>
<pre><code>close
</code></pre>
<h2 id="长度和容量length-and-capacit"><a class="header" href="#长度和容量length-and-capacit">长度和容量(Length and capacit)</a></h2>
<pre><code>Call      Argument type    Result

len(s)    string type      string length in bytes
          [n]T, *[n]T      array length (== n)
          []T              slice length
          map[K]T          map length (number of defined keys)
          chan T           number of elements queued in channel buffer

cap(s)    [n]T, *[n]T      array length (== n)
          []T              slice capacity
          chan T           channel buffer capacity
</code></pre>
<h2 id="分配allocation"><a class="header" href="#分配allocation">分配(Allocation)</a></h2>
<pre><code>new(T)
</code></pre>
<h2 id="创建making-slices-maps-and-channels"><a class="header" href="#创建making-slices-maps-and-channels">创建(Making slices, maps and channels)</a></h2>
<pre><code>Call             Type T     Result

make(T, n)       slice      slice of type T with length n and capacity n
make(T, n, m)    slice      slice of type T with length n and capacity m

make(T)          map        map of type T
make(T, n)       map        map of type T with initial space for n elements

make(T)          channel    unbuffered channel of type T
make(T, n)       channel    buffered channel of type T, buffer size n
</code></pre>
<p>例如：</p>
<pre><code>s := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100
s := make([]int, 1e3)           // slice with len(s) == cap(s) == 1000
s := make([]int, 1&lt;&lt;63)         // illegal: len(s) is not representable by a value of type int
s := make([]int, 10, 0)         // illegal: len(s) &gt; cap(s)
c := make(chan int, 10)         // channel with a buffer size of 10
m := make(map[string]int, 100)  // map with initial space for 100 elements
</code></pre>
<h2 id="分片的追加appending-to-slices"><a class="header" href="#分片的追加appending-to-slices">分片的追加(Appending to slices)</a></h2>
<pre><code>append(s S, x ...T) S  // T is the element type of S
</code></pre>
<p>例如：</p>
<pre><code>s0 := []int{0, 0}
s1 := append(s0, 2)                // append a single element     s1 == []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)          // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)            // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}
s4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, &quot;foo&quot;)   //                             t == []interface{}{42, 3.1415, &quot;foo&quot;}

var b []byte
b = append(b, &quot;bar&quot;...)            // append string contents      b == []byte{'b', 'a', 'r' }
</code></pre>
<h2 id="分片的复制copying-slices"><a class="header" href="#分片的复制copying-slices">分片的复制(Copying slices)</a></h2>
<pre><code>copy(dst, src []T) int
copy(dst []byte, src string) int
</code></pre>
<p>例如：</p>
<pre><code>var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, &quot;Hello, World!&quot;)  // n3 == 5, b == []byte(&quot;Hello&quot;)
</code></pre>
<h2 id="字典成员的删除deletion-of-map-elements"><a class="header" href="#字典成员的删除deletion-of-map-elements">字典成员的删除(Deletion of map elements)</a></h2>
<pre><code>delete(m, k)  // remove element m[k] from map m 
</code></pre>
<h2 id="复数的操作manipulating-complex-numbers"><a class="header" href="#复数的操作manipulating-complex-numbers">复数的操作(Manipulating complex numbers)</a></h2>
<pre><code>complex(realPart, imaginaryPart floatT) complexT
real(complexT) floatT
imag(complexT) floatT
</code></pre>
<p>例如：</p>
<pre><code>var a = complex(2, -2)             // complex128
const b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4i
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
var s uint = complex(1, 0)         // untyped complex constant 1 + 0i can be converted to uint
_ = complex(1, 2&lt;&lt;s)               // illegal: 2 assumes floating-point type, cannot shift
var rl = real(c64)                 // float32
var im = imag(a)                   // float64
const c = imag(b)                  // untyped constant -1.4
_ = imag(3 &lt;&lt; s)                   // illegal: 3 assumes complex type, cannot shift
</code></pre>
<h2 id="panic处理handling-panics"><a class="header" href="#panic处理handling-panics">panic处理(Handling panics)</a></h2>
<pre><code>panic(interface{})
func recover() interface{}
</code></pre>
<p>例如：</p>
<pre><code>func protect(g func()) {
	defer func() {
		log.Println(&quot;done&quot;)  // Println executes normally even if there is a panic
		if x := recover(); x != nil {
			log.Printf(&quot;run time panic: %v&quot;, x)
		}
	}()
	log.Println(&quot;start&quot;)
	g()
}
</code></pre>
<h2 id="自举函数bootstrapping"><a class="header" href="#自举函数bootstrapping">自举函数(Bootstrapping)</a></h2>
<pre><code>Function   Behavior

print      prints all arguments; formatting of arguments is implementation-specific
println    like print but prints spaces between arguments and a newline at the end
</code></pre>
<h2 id="参考-14"><a class="header" href="#参考-14">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go程序的初始化"><a class="header" href="#go程序的初始化">go程序的初始化</a></h1>
<h2 id="变量初始化为对应类型的零值"><a class="header" href="#变量初始化为对应类型的零值">变量初始化为对应类型的零值</a></h2>
<p>例如：</p>
<pre><code>type T struct { i int; f float64; next *T }
t := new(T)
</code></pre>
<p>初始化值为：</p>
<pre><code>t.i == 0
t.f == 0.0
t.next == nil
</code></pre>
<h2 id="包的初始化"><a class="header" href="#包的初始化">包的初始化</a></h2>
<p>下面的代码中，变量的初始化顺序为：d、b、c、a。</p>
<pre><code>var (
	a = c + b
	b = f()
	c = f()
	d = 3
)

func f() int {
	d++
	return d
}
</code></pre>
<p>init函数：</p>
<pre><code>init() { … }
</code></pre>
<h2 id="开始执行"><a class="header" href="#开始执行">开始执行</a></h2>
<pre><code>func main() { … }
</code></pre>
<h2 id="参考-15"><a class="header" href="#参考-15">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go的错误处理"><a class="header" href="#go的错误处理">go的错误处理</a></h1>
<h2 id="返回的错误值"><a class="header" href="#返回的错误值">返回的错误值</a></h2>
<pre><code>type error interface {
	Error() string
}
</code></pre>
<h2 id="panic的传入参数类型"><a class="header" href="#panic的传入参数类型">panic的传入参数类型</a></h2>
<pre><code>package runtime

type Error interface {
	error
	// and perhaps other methods
}
</code></pre>
<h2 id="参考-16"><a class="header" href="#参考-16">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="操作系统相关"><a class="header" href="#操作系统相关">操作系统相关</a></h1>
<h2 id="unsafe"><a class="header" href="#unsafe">unsafe</a></h2>
<pre><code>package unsafe

type ArbitraryType int  // shorthand for an arbitrary Go type; it is not a real type
type Pointer *ArbitraryType

func Alignof(variable ArbitraryType) uintptr
func Offsetof(selector ArbitraryType) uintptr
func Sizeof(variable ArbitraryType) uintptr
</code></pre>
<h2 id="size-and-alignment-guarantees"><a class="header" href="#size-and-alignment-guarantees">Size and alignment guarantees</a></h2>
<pre><code>type                                 size in bytes

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
</code></pre>
<h2 id="参考-17"><a class="header" href="#参考-17">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="实现命令行参数"><a class="header" href="#实现命令行参数">实现命令行参数</a></h1>
<h2 id="flag"><a class="header" href="#flag">Flag</a></h2>
<p><code>flag</code>是Go语言的一个标准包，用来处理命令行参数。</p>
<h3 id="代码"><a class="header" href="#代码">代码</a></h3>
<pre><code class="language-go">//create: 2017/10/26 22:04:34 change: 2017/12/25 13:38:09 lijiaocn@foxmail.com
package main

import (
	&quot;flag&quot;
)

type CmdLine struct {
	Help    bool
	Host    string
	APIPath string
	Prefix  string
	Token   string
	SkipTLS bool
}

var cmdline CmdLine

func init() {
	flag.BoolVar(&amp;cmdline.Help, &quot;help&quot;, false, &quot;show usage&quot;)
	flag.StringVar(&amp;cmdline.Host, &quot;host&quot;, &quot;https://127.0.0.1:6443&quot;, &quot;kubernetes api host&quot;)
	flag.StringVar(&amp;cmdline.APIPath, &quot;apipath&quot;, &quot;/&quot;, &quot;kubernetes api path&quot;)
	flag.StringVar(&amp;cmdline.Prefix, &quot;prefix&quot;, &quot;&quot;, &quot;kubernetes api prefix&quot;)
	flag.StringVar(&amp;cmdline.Token, &quot;token&quot;, &quot;&quot;, &quot;user's bearer token&quot;)
	flag.BoolVar(&amp;cmdline.SkipTLS, &quot;skiptls&quot;, false, &quot;don't verify TLS certificate&quot;)
}

func main() {
	flag.Parse()
	if cmdline.Help {
		flag.Usage()
		return
	}
	println(&quot;Help:&quot;, cmdline.Help)
	println(&quot;Host:&quot;, cmdline.Host)
	println(&quot;APIPath:&quot;, cmdline.APIPath)
	println(&quot;Prefix:&quot;, cmdline.Prefix)
	println(&quot;Token:&quot;, cmdline.Token)
	println(&quot;SkipTLS:&quot;, cmdline.SkipTLS)
}
</code></pre>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<p>查看使用方法：</p>
<pre><code class="language-bash">$ ./k8s-haproxy -h
Usage of ./k8s-haproxy:
  -apipath string
        kubernetes api path (default &quot;/&quot;)
  -help
        show usage
  -host string
        kubernetes api host (default &quot;https://127.0.0.1:6443&quot;)
  -prefix string
        kubernetes api prefix
  -skiptls
        don't verify TLS certificate
  -token string
        user's bearer token
</code></pre>
<p>指定参数值：</p>
<pre><code class="language-bash">$ ./k8s-haproxy -host=192.168.2.1:443 -token=&quot;this is my token&quot;
Help: false
Host: 192.168.2.1:443
APIPath: /
Prefix:
Token: this is my token
SkipTLS: false
</code></pre>
<h2 id="参考-18"><a class="header" href="#参考-18">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="打印日志"><a class="header" href="#打印日志">打印日志</a></h1>
<h2 id="glog"><a class="header" href="#glog">glog</a></h2>
<p><code>glog</code>原本是google使用C++实现的一个日志模块(<a href="https://github.com/google/glog" title="glog c++">glog c++</a>)，go语言出来以后，又实现了一个Go版本的<a href="https://github.com/golang/glog" title="glog golang">glog</a>。</p>
<h3 id="代码-1"><a class="header" href="#代码-1">代码</a></h3>
<p>glog依赖标准包flag，在调用glog的方法之前，需要调用<code>flag.Parse()</code>。</p>
<pre><code class="language-go">//create: 2017/12/25 14:24:03 change: 2017/12/25 15:08:49 lijiaocn@foxmail.com
package main

import (
	&quot;flag&quot;
	&quot;github.com/golang/glog&quot;
)

func main() {
	flag.Parse()
	glog.Infof(&quot;%s\n&quot;, &quot;This is a info&quot;)
	glog.Warningf(&quot;%s\n&quot;, &quot;This is a warning&quot;)
	glog.Errorf(&quot;%s\n&quot;, &quot;This is a error&quot;)
	glog.V(1).Infof(&quot;%s\n&quot;, &quot;This is a v1 log&quot;)
	glog.V(2).Infof(&quot;%s\n&quot;, &quot;This is a v2 log&quot;)
	//this call will make the progress exit.
	//glog.Fatalf(&quot;%s\n&quot;, &quot;This is a fatal&quot;)
	//this call will make the progress exit.
	//glog.Exitf(&quot;%s\n&quot;, &quot;This is a exit&quot;)
}
</code></pre>
<h3 id="运行-1"><a class="header" href="#运行-1">运行</a></h3>
<p>glog支持以下参数。</p>
<pre><code class="language-bash">$ ./glog -h
Usage of ./glog:
  -alsologtostderr
        log to standard error as well as files
  -log_backtrace_at value
        when logging hits line file:N, emit a stack trace
  -log_dir string
        If non-empty, write log files in this directory
  -logtostderr
        log to standard error instead of files
  -stderrthreshold value
        logs at or above this threshold go to stderr
  -v value
        log level for V logs
  -vmodule value
        comma-separated list of pattern=N settings for file-filtered logging
</code></pre>
<p>glog将日志以文件的形式写入<code>-log_dir</code>指定的目录，使用<code>-log_dir</code>时只有ERROR日志会打印到标准输出，</p>
<pre><code class="language-bash">$ ./glog -log_dir=./log
E1225 15:19:10.514843   83246 main.go:13] This is a error
</code></pre>
<p>生成的日志文件：</p>
<pre><code class="language-bash">lijiaos-MacBook-Pro:glog lijiao$ ls log/
glog.ERROR
glog.INFO
glog.WARNING
glog.lijiaos-MacBook-Pro.lijiao.log.ERROR.20171225-151858.83190
glog.lijiaos-MacBook-Pro.lijiao.log.ERROR.20171225-151910.83246
glog.lijiaos-MacBook-Pro.lijiao.log.INFO.20171225-151858.83190
glog.lijiaos-MacBook-Pro.lijiao.log.INFO.20171225-151910.83246
glog.lijiaos-MacBook-Pro.lijiao.log.WARNING.20171225-151858.83190
glog.lijiaos-MacBook-Pro.lijiao.log.WARNING.20171225-151910.83246
</code></pre>
<p>参数<code>-logtostderr</code>将所有日志打印到标准输出，不保存到文件中。</p>
<pre><code class="language-bash">$ ./glog  -logtostderr
I1225 15:22:11.770424   83995 main.go:11] This is a info
W1225 15:22:11.770510   83995 main.go:12] This is a warning
E1225 15:22:11.770513   83995 main.go:13] This is a error
</code></pre>
<p>参数<code>-v</code>指定日志的级别，只打印V(x)中，x小于等于-v指定的数值的日志。</p>
<pre><code class="language-bash">$ ./glog  -logtostderr -v 1
I1225 15:28:03.517261   85366 main.go:11] This is a info
W1225 15:28:03.517335   85366 main.go:12] This is a warning
E1225 15:28:03.517339   85366 main.go:13] This is a error
I1225 15:28:03.517342   85366 main.go:14] This is a v1 log
</code></pre>
<h3 id="建议"><a class="header" href="#建议">建议</a></h3>
<p>必须要记录的日志使用<code>glog.InfoX</code>、<code>glog.WarningX</code>、<code>glog.ErrorX</code>等函数打印。</p>
<p>用于开发调试的日志使用<code>glov.V().InfoX</code>打印。</p>
<h3 id="参考-19"><a class="header" href="#参考-19">参考</a></h3>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
<li><a href="https://github.com/golang/glog" title="glog golang">glog golang</a></li>
<li><a href="https://github.com/google/glog" title="glog c++">glog c++</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-语言的类型转换"><a class="header" href="#go-语言的类型转换">Go 语言的类型转换</a></h1>
<h2 id="string-转换成-byte"><a class="header" href="#string-转换成-byte">string 转换成 []byte</a></h2>
<pre><code class="language-go">var str string
str = &quot;abcd&quot;
var [] bytes

bytes = []byte(str)
</code></pre>
<h2 id="string-转数值"><a class="header" href="#string-转数值">string 转数值</a></h2>
<p>标准库 <a href="https://golang.org/pkg/strconv/#pkg-index" title="Package strconv">strconv</a> 提供了多个 string 与数值的转换方法：</p>
<pre><code class="language-go">i, err := strconv.Atoi(&quot;-42&quot;)
s := strconv.Itoa(-42)
</code></pre>
<p>指定进制：</p>
<pre><code class="language-go">b, err := strconv.ParseBool(&quot;true&quot;)
f, err := strconv.ParseFloat(&quot;3.1415&quot;, 64)
i, err := strconv.ParseInt(&quot;-42&quot;, 10, 64)
u, err := strconv.ParseUint(&quot;42&quot;, 10, 64)
</code></pre>
<h2 id="数值转字符串"><a class="header" href="#数值转字符串">数值转字符串</a></h2>
<pre><code class="language-go">s := strconv.Itoa(-42)
s = fmt.Sprintf(&quot;%d&quot;, 32)
</code></pre>
<h2 id="参考-20"><a class="header" href="#参考-20">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="依赖代码管理"><a class="header" href="#依赖代码管理">依赖代码管理</a></h1>
<p>这里记录用于Go项目的依赖管理工具。</p>
<h2 id="go-modules"><a class="header" href="#go-modules">Go Modules</a></h2>
<p>Go 1.11和Go 1.12引入了Go Modules，在Go 1.13中，Go Module将是默认的依赖管理方法：<a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2019/05/05/go-modules.html">Go 1.11和1.12引入的新的依赖代码管理方法：Go Modules</a>。</p>
<h2 id="dep"><a class="header" href="#dep">Dep</a></h2>
<p><a href="https://github.com/golang/dep" title="dep">dep</a>是一个比较新的依赖管理工具，它计划成为Go的标准工具(截止2017-12-26 20:50:43)。</p>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<p>可以下面的方法安装：</p>
<pre><code class="language-bash">go get -u github.com/golang/dep/cmd/dep
</code></pre>
<p>在Mac上还可以用brew安装：</p>
<pre><code class="language-bash">brew install dep
brew upgrade dep
</code></pre>
<h3 id="使用"><a class="header" href="#使用">使用</a></h3>
<p>在项目的根目录中执行<code>dep init</code>完成初始化设置。</p>
<pre><code class="language-bash">$ dep init
$ tree
.
├── Gopkg.lock
├── Gopkg.toml
└── vendor

1 directory, 2 files
</code></pre>
<p><code>Gopkg.toml</code>和<code>Gopkg.lock</code>用来记录项目的依赖包，如果项目中没有代码，这两个文件是空的。</p>
<p>使用<code>dep ensure -add</code>添加依赖包（项目目录中需要有源码）：</p>
<pre><code class="language-bash">dep ensure -add  k8s.io/client-go
</code></pre>
<p>这时依赖包的依赖包还没有安装到项目本地，需要执行<code>dep ensure</code>进行安装。</p>
<p>代码中引用的其它<code>未通过dep添加</code>的依赖包，也需要执行<code>dep ensure</code>进行安装。</p>
<p>如果要更改依赖的版本，编辑<code>Gopkg.toml</code>之后，执行<code>dep ensure</code>。</p>
<p><code>dep ensure</code>将所有的依赖包信息更新到Gopkg.lock文件中，并将所有的依赖包下载到vendor目录中。</p>
<h3 id="发布"><a class="header" href="#发布">发布</a></h3>
<p>可以只将<code>Gopkg.toml</code>和<code>Gopkg.lock</code>包含到项目代码库中。之后在项目根目录中执行<code>dep ensure</code>下载依赖包：</p>
<pre><code class="language-bash">dep ensure
</code></pre>
<h2 id="glide"><a class="header" href="#glide">Glide</a></h2>
<p><a href="https://github.com/Masterminds/glide" title="glide">glide</a>是一个使用比较多的依赖管理工具。</p>
<h3 id="安装-1"><a class="header" href="#安装-1">安装</a></h3>
<p>在linux上可以用下面的方法安装：</p>
<pre><code class="language-bash">curl https://glide.sh/get | sh
</code></pre>
<p>Mac上还可以用brew安装：</p>
<pre><code class="language-bash">brew install glide
</code></pre>
<h3 id="使用-1"><a class="header" href="#使用-1">使用</a></h3>
<h4 id="glide-create初始化"><a class="header" href="#glide-create初始化">glide create初始化</a></h4>
<p>在项目的根目录中执行<code>glide create</code>完成初始化设置。</p>
<pre><code class="language-bash">$ glide create
[INFO]	Generating a YAML configuration file and guessing the dependencies
[INFO]	Attempting to import from other package managers (use --skip-import to skip)
[INFO]	Scanning code to look for dependencies
[INFO]	Writing configuration file (glide.yaml)
[INFO]	Would you like Glide to help you find ways to improve your glide.yaml configuration?
[INFO]	If you want to revisit this step you can use the config-wizard command at any time.
[INFO]	Yes (Y) or No (N)?
N
[INFO]	You can now edit the glide.yaml file. Consider:
[INFO]	--&gt; Using versions and ranges. See https://glide.sh/docs/versions/
[INFO]	--&gt; Adding additional metadata. See https://glide.sh/docs/glide.yaml/
[INFO]	--&gt; Running the config-wizard command to improve the versions in your configuration
</code></pre>
<p>如果项目中已经有代码，会将已有代码的依赖写入到glide.yaml中。</p>
<p>之后直接使用<code>glide up --quick</code>将已有代码的依赖收集到vendor目录中。</p>
<h4 id="glide-get-添加依赖包"><a class="header" href="#glide-get-添加依赖包">glide get 添加依赖包</a></h4>
<p>使用glide安装依赖包的时候，会自动提示版本。例如用glide的命令引入<code>k8s.io/client-go</code>时：</p>
<pre><code class="language-bash">$ glide get k8s.io/client-go
[INFO]	Preparing to install 1 package.
[INFO]	Attempting to get package k8s.io/client-go
[INFO]	--&gt; Gathering release information for k8s.io/client-go
[INFO]	The package k8s.io/client-go appears to have Semantic Version releases (http://semver.org).
[INFO]	The latest release is v6.0.0. You are currently not using a release. Would you like
[INFO]	to use this release? Yes (Y) or No (N)
Y
[INFO]	The package k8s.io/client-go appears to use semantic versions (http://semver.org).
[INFO]	Would you like to track the latest minor or patch releases (major.minor.patch)?
[INFO]	The choices are:
[INFO]	 - Tracking minor version releases would use '&gt;= 6.0.0, &lt; 7.0.0' ('^6.0.0')
[INFO]	 - Tracking patch version releases would use '&gt;= 6.0.0, &lt; 6.1.0' ('~6.0.0')
[INFO]	 - Skip using ranges
[INFO]	For more information on Glide versions and ranges see https://glide.sh/docs/versions
[INFO]	Minor (M), Patch (P), or Skip Ranges (S)?
P
[INFO]	--&gt; Adding k8s.io/client-go to your configuration with the version ~6.0.0
[INFO]	Downloading dependencies. Please wait...
[INFO]	--&gt; Fetching updates for k8s.io/client-go
[INFO]	Resolving imports
[INFO]	Downloading dependencies. Please wait...
[INFO]	--&gt; Detected semantic version. Setting version for k8s.io/client-go to v6.0.0
[INFO]	Exporting resolved dependencies...
[INFO]	--&gt; Exporting k8s.io/client-go
[INFO]	Replacing existing vendor dependencies
</code></pre>
<p>安装完成之后目录结构如下：</p>
<pre><code class="language-bash">$ tree -L 2
.
├── glide.lock
├── glide.yaml
└── vendor
    └── k8s.io
</code></pre>
<p><code>glide get</code>在glide.yaml和glide.lock中记录了依赖的client-go的版本。</p>
<p>这时，依赖包已经安装到了项目本地，但是依赖包的依赖包还需要通过执行<code>glide up</code>进行安装。</p>
<h4 id="glide-up-更新vendor目录"><a class="header" href="#glide-up-更新vendor目录">glide up 更新vendor目录</a></h4>
<p>项目的源代码中直接引入的<code>不是通过glide命令安装</code>的包，也需要执行<code>glide up</code>安装。</p>
<p><code>glide up</code>会在glide.lock中记录依赖包的依赖包和源码引用的依赖包，并将这些依赖包安装到项目本地。</p>
<blockquote>
<p>⚠️  glide up安装的依赖包是直接从github或者其它网址下载的，既不会使用、也不会更改$GOPATH中的源码。</p>
</blockquote>
<blockquote>
<p>⚠️  没有指定版本的依赖包，glide up每次执行的时候，都会去获取安装最新的代码。</p>
</blockquote>
<blockquote>
<p>⚠️  glide up默认递归搜集依赖，可以用glide up --quick</p>
</blockquote>
<pre><code class="language-bash">$ glide up
[INFO]	Downloading dependencies. Please wait...
[INFO]	--&gt; Fetching updates for k8s.io/client-go
[INFO]	--&gt; Detected semantic version. Setting version for k8s.io/client-go to v5.0.1
[INFO]	Resolving imports
[INFO]	--&gt; Fetching github.com/lijiaocn/GoPkgs
[INFO]	Found Godeps.json file in /Users/lijiao/.glide/cache/src/https-k8s.io-apimachinery
[INFO]	--&gt; Parsing Godeps metadata...
...
[INFO]	--&gt; Exporting k8s.io/kube-openapi
[INFO]	--&gt; Exporting k8s.io/api
[INFO]	Replacing existing vendor dependencies
[INFO]	Project relies on 31 dependencies.

$ head glide.lock
hash: 1002f0b1fae48b0c9e90737a6071f892d98b6bd9016d55f91cca24d25672e4cb
updated: 2017-12-27T10:44:30.038822286+08:00
imports:
- name: github.com/davecgh/go-spew
  version: 782f4967f2dc4564575ca782fe2d04090b5faca8
  subpackages:
  - spew
- name: github.com/emicklei/go-restful
  version: ff4f55a206334ef123e4f79bbf348980da81ca46
  subpackages:
</code></pre>
<p>如果要更改依赖包的版本，修改<code>glide.yaml</code>文件的version后，也执行<code>glide up</code>。</p>
<pre><code class="language-bash">$ cat glide.yaml
package: github.com/lijiaocn/handbook-go/codes/04-01-version/glide
import:
- package: k8s.io/client-go
  version: ~6.0.0
$ glide up -v
</code></pre>
<h3 id="管理"><a class="header" href="#管理">管理</a></h3>
<p>查看依赖包：</p>
<pre><code>glide list
</code></pre>
<p>删除依赖包：</p>
<pre><code>glide rm
</code></pre>
<p>设置镜像站：</p>
<pre><code>glide mirror
</code></pre>
<h3 id="发布-1"><a class="header" href="#发布-1">发布</a></h3>
<p>发布的时候将<code>glide.lock</code>和<code>glide.yaml</code>包含到项目源码库中。</p>
<p>获取到项目代码后，项目的根目录中执行<code>glide install</code>下载项目的依赖包。</p>
<pre><code class="language-bash">$ glide install
[INFO]	Downloading dependencies. Please wait...
[INFO]	--&gt; Found desired version locally github.com/davecgh/go-spew 782f4967f2dc4564575ca782fe2d04090b5faca8!
[INFO]	--&gt; Found desired version locally github.com/emicklei/go-restful ff4f55a206334ef123e4f79bbf348980da81ca46!
[INFO]	--&gt; Found desired version locally github.com/emicklei/go-restful-swagger12 dcef7f55730566d41eae5db10e7d6981829720f6!
...
[INFO]	--&gt; Exporting gopkg.in/inf.v0
[INFO]	--&gt; Exporting k8s.io/client-go
[INFO]	--&gt; Exporting k8s.io/kube-openapi
[INFO]	Replacing existing vendor dependencies
</code></pre>
<h2 id="godep"><a class="header" href="#godep">Godep</a></h2>
<p>Go语言早期没有提供依赖包管理的功能，<a href="https://github.com/Masterminds/glide" title="glide">godep</a>是一个比较简单的第三方依赖管理工具。</p>
<h3 id="安装-2"><a class="header" href="#安装-2">安装</a></h3>
<p>可以用下面的命令安装godep：</p>
<pre><code>go get github.com/tools/godep
</code></pre>
<h3 id="下载"><a class="header" href="#下载">下载</a></h3>
<p>godep不会自动拉取代码，使用前，先要确认中<code>$GOPATH</code>中的源码的版本是正确的。</p>
<p>例如，如果要使用<code>k8s.io/client-go</code>的v6.0.0版本的代码。</p>
<p>先下载源码：</p>
<pre><code>go get k8s.io/client-go/...
</code></pre>
<p>然后将下载的client-go源码切换到v6.0.0：</p>
<pre><code>cd $GOPATH/src/k8s.io/client-go
git checkout v6.0.0
</code></pre>
<p>因为client-go自身也使用godep进行了依赖管理，所以还需要在client-go中执行：</p>
<pre><code>godep restore ./...
</code></pre>
<blockquote>
<p>执行restore的目的下载client-go的依赖包。</p>
</blockquote>
<p>这时可以直接在项目中引用目标版本的代码，但依赖包的文件还是到$GOPATH中读取。</p>
<p>如果另一个项目使用了同名依赖包的另一个版本，两者就会冲突。所以还需要将项目的依赖信息、依赖文件保存到项目本地。</p>
<h3 id="保存"><a class="header" href="#保存">保存</a></h3>
<p>通过以下命令，将项目引用的第三方代码以及版本信息保存在本地:</p>
<pre><code>godep save          #保存当前目录下的go文件(不遍历子目录)引用的第三方代码
godep save ./...    #保存当前目录以及子目录下的go文件引用的第三方代码
</code></pre>
<p>在Go1.5之前，godep将版本信息和第三方代码保存的项目的Godeps目录下。因此在go1.5之前，需要通过godep调用go命令，才会使用保存在项目本地的依赖包。例如：</p>
<pre><code>godep go build
</code></pre>
<p>在Go1.5以后，godep将版本信息保存在godeps目录中,将依赖包保存在项目本地的vendor目录中，可以直接使用go命令。</p>
<h3 id="发布-2"><a class="header" href="#发布-2">发布</a></h3>
<p>可以将项目本地的依赖包，即Godep目录和vendor目录提交到项目的代码库中。</p>
<p>也可以只将Godep目录提交到项目的代码库中。这样下载了项目代码后，需要用restore下载依赖包：</p>
<pre><code>go restore
</code></pre>
<p>restore会命令将$GOPATH中的源码更新为<code>Godeps/Godeps.json</code>中指定的版本，因此最好还是使用第一种发布方式。</p>
<p>例如Godeps.json中的指定metadata的版本为<code>3b1ae45394a234c385be014e9a488f2bb6eef821</code>：</p>
<pre><code class="language-json">{
    &quot;ImportPath&quot;: &quot;k8s.io/client-go&quot;,
    &quot;GoVersion&quot;: &quot;go1.9&quot;,
    &quot;GodepVersion&quot;: &quot;v79&quot;,
    &quot;Packages&quot;: [
        &quot;./...&quot;
    ],
    &quot;Deps&quot;: [
        {
            &quot;ImportPath&quot;: &quot;cloud.google.com/go/compute/metadata&quot;,
            &quot;Rev&quot;: &quot;3b1ae45394a234c385be014e9a488f2bb6eef821&quot;
        },
    ...(省略)...
</code></pre>
<p>执行restore命令之后，<code>$GOPATH/cloud.google.com/go/compute/metadata</code>中的版本将为变成指定的版本：</p>
<pre><code class="language-bash">$ cd $GOPATH/cloud.google.com/go/compute/metadata
$ git log |head
commit 3b1ae45394a234c385be014e9a488f2bb6eef821
Author: Sarah Adams &lt;shadams@google.com&gt;
Date:   Thu Sep 8 15:39:53 2016 -0700

    datastore: adds support for loading entity values

    Adds support for conditionally loading either flattened fields or
    entity values into nested structs on read.

    Issue #75
</code></pre>
<h3 id="设置代理"><a class="header" href="#设置代理">设置代理</a></h3>
<p>godep是用go语言开发，go语言开发的程序都支持环境变量<code>http_proxy</code>。</p>
<pre><code>$ http_proxy=127.0.0.1:53100 godep restore ./...
</code></pre>
<p>godep在加载源码时，会使用git等版本管理工具，所以可能还需要给这些版本管理设置代理。</p>
<p>git可以在~/.gitconfig中设置:</p>
<pre><code class="language-ini">[https]
proxy = 127.0.0.1:53100
sslverify = false
[http]
proxy = 127.0.0.1:53100
</code></pre>
<h2 id="vendor"><a class="header" href="#vendor">Vendor</a></h2>
<p>vendor是1.5中的一个试验特性，在1.6版本中被正式引入。编译过程中，会先引用vendor目录中的代码。</p>
<p>对于同样的代码main.go:</p>
<pre><code class="language-go">package main

import (
    &quot;github.com/lijiaocn/GoPkgs/version&quot;
)

func main() {
    version.Show()
}
</code></pre>
<p>没有vendor之前，项目vendor_test目录结构如下:</p>
<pre><code class="language-bash">▾ vendor_test/
  ▾ main/
      main.go
</code></pre>
<p>main.go中引用的是<code>$GOPATH/.../version</code>中的文件。</p>
<p>使用vendor之后，目录结构如下：</p>
<pre><code class="language-bash">▾ vendor_test/
  ▸ Godeps/
  ▾ main/
      main.go
  ▾ vendor/
    ▾ github.com/
      ▾ lijiaocn/
        ▾ GoPkgs/
          ▸ version/
            LICENSE
</code></pre>
<p>main.go中引用的是本地的<code>vendor/.../version</code>中的文件。</p>
<p>不需要对main.go做任何修改。</p>
<h2 id="参考-21"><a class="header" href="#参考-21">参考</a></h2>
<ol>
<li><a href="https://github.com/tools/godep" title="godep">godep</a></li>
<li><a href="https://github.com/Masterminds/glide" title="glide">glide</a></li>
<li><a href="https://github.com/golang/dep" title="dep">dep</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-template-语法"><a class="header" href="#go-template-语法">Go Template 语法</a></h1>
<p>Go 语言提供了一个名为 <a href="https://golang.org/pkg/text/template/" title="Golang: Package template">text/template</a> 库，这个库定义实现了 go template 语言，可以用来写 html 模板。很多用 go 语言实现的软件，譬如 docker、kubernetes 支持用 go template 定义输出的内容格式。</p>
<p>基本样式如下：</p>
<pre><code class="language-go">{{ .struct成员名称 }}
</code></pre>
<p>譬如输出 docker inspect 中的指定字段：</p>
<pre><code class="language-sh">$ docker inspect b579c6a6516b -f &quot;{{.NetworkSettings.Networks.bridge.IPAddress}}&quot;
172.17.0.3
</code></pre>
<h2 id="参考-22"><a class="header" href="#参考-22">参考</a></h2>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h3 id="raw-string"><a class="header" href="#raw-string">raw string</a></h3>
<p>codes: </p>
<pre><code>package main

func main() {
    raw := `Hello,
World
    !`

    println(raw)
}
</code></pre>
<p>output: </p>
<pre><code>Hello,
World
	!
</code></pre>
<h3 id="same-string"><a class="header" href="#same-string">same string</a></h3>
<p>codes: </p>
<pre><code>package main

func main() {

    str1 := &quot;日本語&quot;                                  // UTF-8 input text
    str2 := `日本語`                                  // UTF-8 input text as a raw literal
    str3 := &quot;\u65e5\u672c\u8a9e&quot;                   // the explicit Unicode code points
    str4 := &quot;\U000065e5\U0000672c\U00008a9e&quot;       // the explicit Unicode code points
    str5 := &quot;\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e&quot; // the explicit UTF-8 bytes

    println(str1)
    println(str2)
    println(str3)
    println(str4)
    println(str5)
}
</code></pre>
<p>output:</p>
<pre><code>日本語
日本語
日本語
日本語
日本語
</code></pre>
<h3 id="constant-max-int"><a class="header" href="#constant-max-int">constant max int</a></h3>
<p>codes:</p>
<pre><code>package main

func main() {
    //2^256=115792089237316195423570985008687907853269984665640564039457584007913129639936
    i := 115792089237316195423570985008687907853269984665640564039457584007913129639936
}
</code></pre>
<p>output:</p>
<pre><code>./main.go:6: constant 115792089237316195423570985008687907853269984665640564039457584007913129639936 overflows int
</code></pre>
<h3 id="unamed-type"><a class="header" href="#unamed-type">unamed type</a></h3>
<p>codes:</p>
<pre><code>package main

type Student struct {
    name string
    age  int
}

func Display(s struct {
    name string
    age  int
}) {
    println(s.name)
    println(s.age)
}

func main() {
    alice := Student{
        name: &quot;alice&quot;,
        age:  16,
    }
    Display(alice)
}
</code></pre>
<p>output:</p>
<pre><code>alice
16
</code></pre>
<h3 id="method-sets"><a class="header" href="#method-sets">Method Sets</a></h3>
<p>codes:</p>
<pre><code>package main

type Str string

func (s Str) Show() {
    println(s)
}

func main() {
    str := Str(&quot;Hello World!&quot;)
    pstr := &amp;str
    pstr.Show()
}
</code></pre>
<p>output:</p>
<pre><code>Hello World!
</code></pre>
<h3 id="string-index"><a class="header" href="#string-index">String Index</a></h3>
<p>codes:</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    str := &quot;Hello World!&quot;
    fmt.Printf(&quot;%c\n&quot;, str[6])

    //not allow
    //ptr := &amp;str[6]

    //not allow
    //str[6] = 'w'
}
</code></pre>
<p>output:</p>
<pre><code>W
</code></pre>
<h3 id="create-slice-from-array"><a class="header" href="#create-slice-from-array">Create Slice from Array</a></h3>
<p>codes:</p>
<pre><code>package main

func main() {
    var array1 [30]int
    for i := 0; i &lt; len(array1); i++ {
        array1[i] = i
    }

    slice1 := array1[10:15]

    println(&quot;array's length: &quot;, len(array1))
    println(&quot;slice1's length: &quot;, len(slice1))
    println(&quot;slice1's capacity: &quot;, cap(slice1))

    for i := 0; i &lt; len(slice1); i++ {
        println(slice1[i])
    }
}
</code></pre>
<p>output:</p>
<pre><code>array's length:  30
slice1's length:  5
slice1's capacity:  20
10
11
12
13
14
</code></pre>
<h3 id="create-slice-by-make"><a class="header" href="#create-slice-by-make">Create Slice by make</a></h3>
<p>codes:</p>
<pre><code>package main

func main() {
    //not allow
    //slice1 := make([]int)
    //println(&quot;slice1， len is &quot;, len(slice1), &quot;capacity is &quot;, cap(slice1))

    slice2 := make([]int, 10)
    println(&quot;slice2， len is &quot;, len(slice2), &quot;capacity is &quot;, cap(slice2))

    slice3 := make([]int, 10, 20)
    println(&quot;slice3， len is &quot;, len(slice3), &quot;capacity is &quot;, cap(slice3))
}
</code></pre>
<p>output:</p>
<pre><code>slice2， len is  10 capacity is  10
slice3， len is  10 capacity is  20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-语言测试框架-ginkgo-的使用方法"><a class="header" href="#go-语言测试框架-ginkgo-的使用方法">Go 语言测试框架 GinkGo 的使用方法</a></h1>
<p>学习 <a href="https://www.lijiaocn.com/soft/k8s/ingress-nginx/" title="ingress-nginx 的使用方法">ingress-nginx</a> 时，想修改它的代码并将代码提交到社区，了解 e2e 测试时，遇到了 <a href="http://onsi.github.io/ginkgo/" title="ginkgo">GinkGo</a>。</p>
<h2 id="学习环境"><a class="header" href="#学习环境">学习环境</a></h2>
<p>这里使用的 go 版本是 go 1.13.3。</p>
<p>创建工作目录，安装 ginkgo：</p>
<pre><code class="language-sh">$ go get github.com/onsi/ginkgo/ginkgo
$ go get github.com/onsi/gomega/...
$ ginkgo version
Ginkgo Version 1.10.2
</code></pre>
<p>准备一个待测的 package：</p>
<pre><code class="language-sh">$ mkdir study-Ginkgo
$ cd study-Ginkgo
$ go mod init studyginkgo
</code></pre>
<p>在文件 target_funcs/target_funcs.go 中写几个待测的函数：</p>
<pre><code class="language-go">package target_funcs

func ReturnTrue() bool {
    return true
}

func ReturnFalse() bool {
    return false
}

func ReturnInt(v int) int {
    return v
}
</code></pre>
<h2 id="ginkgo-测试代码的运行"><a class="header" href="#ginkgo-测试代码的运行">ginkgo 测试代码的运行</a></h2>
<p>用 ginkgo 命令生成测试模板：</p>
<pre><code class="language-sh">$ cd target_funcs/
$ ginkgo bootstrap
Generating ginkgo test suite bootstrap for target_funcs in:
    target_funcs_suite_test.go
</code></pre>
<p>刚生成的 target_funcs_suite_test.go 中现在还没有任何测试代码，运行方法：</p>
<p>方法1，用 ginkgo：</p>
<pre><code class="language-sh">$ ginkgo
Running Suite: TargetFuncs Suite
================================
Random Seed: 1571986734
Will run 0 of 0 specs


Ran 0 of 0 Specs in 0.001 seconds
SUCCESS! -- 0 Passed | 0 Failed | 0 Pending | 0 Skipped
PASS

Ginkgo ran 1 suite in 5.353367082s
Test Suite Passed
</code></pre>
<p>方法2，用 go test：</p>
<pre><code class="language-sh">go test
Running Suite: TargetFuncs Suite
================================
Random Seed: 1571986747
Will run 0 of 0 specs


Ran 0 of 0 Specs in 0.000 seconds
SUCCESS! -- 0 Passed | 0 Failed | 0 Pending | 0 Skipped
PASS
ok      studyginkgo/target_funcs    0.017s
</code></pre>
<p>方法3，生成二进制文件，ginkgo 可以测试代码编译到一个二进制文件中：</p>
<pre><code class="language-sh">$ ginkgo build
Compiling target_funcs...
    compiled target_funcs.test
</code></pre>
<p>生成的二进制文件 target_funcs.test 可以直接运行：</p>
<pre><code class="language-sh">./target_funcs.test
Running Suite: TargetFuncs Suite
================================
Random Seed: 1571986954
Will run 0 of 0 specs


Ran 0 of 0 Specs in 0.000 seconds
SUCCESS! -- 0 Passed | 0 Failed | 0 Pending | 0 Skipped
PASS
</code></pre>
<h2 id="ginkgo-测试代码的编写"><a class="header" href="#ginkgo-测试代码的编写">ginkgo 测试代码的编写</a></h2>
<p>为 target_funcs_suite_test.go 生成对应的测试代码文件：</p>
<pre><code class="language-sh">$ ginkgo generate target_funcs
</code></pre>
<p>上面的命令生成测试 target_funcs_test.go。如果不在 $GOPATH 目录下，可能会遇到下面的错误，ginkgo 大概还没有支持 gomod（2019-10-25 15:23:23）。这个错误不影响使用，将 target_funcs_test.go 中的 UNKNOWN_PACKAGE_PATH 修改成所在的 package 就可以了。</p>
<pre><code>Couldn't identify package import path.

    ginkgo generate

Must be run within a package directory under $GOPATH/src/...
You're going to have to change UNKNOWN_PACKAGE_PATH in the generated file...

Generating ginkgo test for TargetFuncs in:
  target_funcs_test.go
</code></pre>
<p>target_funcs_test.go 内容如下，在 Describe 中添加测试函数：</p>
<pre><code class="language-go">package target_funcs_test

import (
    . &quot;github.com/onsi/ginkgo&quot;
    . &quot;github.com/onsi/gomega&quot;

    . &quot;studyginkgo/target_funcs&quot;
)

var _ = Describe(&quot;TargetFuncs&quot;, func() {

})
</code></pre>
<h2 id="ginkgo-提供的-block"><a class="header" href="#ginkgo-提供的-block">ginkgo 提供的 block</a></h2>
<p>ginkgo 提供了多个类型的 block（函数），上面的 Describe() 就是一个 block。</p>
<p>在 XX_suite_test.go （这里是 target_funcs_suite_test.go）中使用的 block：</p>
<pre><code class="language-sh">BeforeSuite()          :在整个测试开始之前执行的操作
AfterSuite()           :在整个测试完成之后执行的操作
</code></pre>
<p>在 XX_test.go（这里是 target_funcs_test.go）中使用的 block：</p>
<pre><code class="language-sh">BeforeEach()           :每个测试用例运行前执行的操作，位于 Describe 中，可以有多个
JustBeforeEach()       :和BeforeEach()类似，在所有的 BeforeEach()之后和It()之前执行
AfterEach()            :每个测试用例运行后执行的操作
JustAfterEach()        :紧跟在It()之后执行

Describe()             :最顶层的测试用例包裹容器，同一目标的测试用例，可以嵌套
Context()              :比 Describe 低一级的测试用例包裹容器，同一个条件下的测试用例
It()                   :单个测试用例，位于 Describe 或者 Context 中
Specify()              :It()的别名，用途和 It() 完全相同
</code></pre>
<p>专用于性能测试的 block，使用范围和 It() 相同：</p>
<pre><code class="language-sh">Measure()              :用于性能测试的 block()
</code></pre>
<p>Describe、Context、It 和 Measure 支持 P 和 X 前缀，带有 P 或 X 前缀的这几个 block 不参与测试。</p>
<p>Describe、Context 和 It 支持 F 前缀，如果有带有 F 前缀的这些 block，测试时只会运行这些 block 中的测试用例。</p>
<h2 id="结果判断"><a class="header" href="#结果判断">结果判断</a></h2>
<p>GinkGo 提供了多个用来进行数值判断的函数。</p>
<p>Expect(actual interface{}) 为传入参数创建一个断言 Assertion，Assertion 支持的以下的判断方法：</p>
<pre><code class="language-go">type Assertion interface {
    Should(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
    ShouldNot(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool

    To(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
    ToNot(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
    NotTo(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
}
</code></pre>
<p>断言的第一个参数是 matcher，在 github.com/onsi/gomega/matcher.go 中定义，例如：</p>
<pre><code class="language-go">func BeNil() types.GomegaMatcher {
    return &amp;matchers.BeNilMatcher{}
}

//BeTrue succeeds if actual is true
func BeTrue() types.GomegaMatcher {
    return &amp;matchers.BeTrueMatcher{}
}
</code></pre>
<p>使用举例，分配检测 err 和 svc 的值：</p>
<pre><code class="language-go">Expect(err).To(BeNil(), &quot;unexpected error obtaining ingress-nginx service&quot;)
Expect(svc).NotTo(BeNil(), &quot;expected a service but none returned&quot;)
</code></pre>
<h2 id="测试示例"><a class="header" href="#测试示例">测试示例</a></h2>
<p>target_funcs_suite_test.go 内容如下：</p>
<pre><code class="language-go">package target_funcs_test
import (
    &quot;testing&quot;

    . &quot;github.com/onsi/ginkgo&quot;
    . &quot;github.com/onsi/gomega&quot;
)
func TestTargetFuncs(t *testing.T) {
    RegisterFailHandler(Fail)
    RunSpecs(t, &quot;TargetFuncs Suite&quot;)
}
var _ = BeforeSuite(func() {
    println(&quot;BeforeSuite&quot;)
})
var _ = AfterSuite(func() {
    println(&quot;AfterSuite&quot;)
})
</code></pre>
<p>target_funcs_test.go 的内容如下：</p>
<pre><code class="language-go">package target_funcs_test
import (
    . &quot;github.com/onsi/ginkgo&quot;
    . &quot;github.com/onsi/gomega&quot;

    . &quot;studyginkgo/target_funcs&quot;
)

var _ = Describe(&quot;TargetFuncs&quot;, func() {
    BeforeEach(func() {
        println(&quot;BeforeEach-2&quot;)
    })
    BeforeEach(func() {
        println(&quot;BeforeEach-1&quot;)
    })
    JustBeforeEach(func() {
        println(&quot;JustBeforeEach-1&quot;)
    })
    JustBeforeEach(func() {
        println(&quot;JustBeforeEach-2&quot;)
    })
    JustAfterEach(func() {
        println(&quot;JustAfterEach-1&quot;)
    })
    JustAfterEach(func() {
        println(&quot;JustAfterEach-2&quot;)
    })
    AfterEach(func() {
        println(&quot;AfterEach-1&quot;)
    })
    AfterEach(func() {
        println(&quot;AfterEach-2&quot;)
    })
    Describe(&quot;ReturnInt&quot;, func() {
        Context(&quot;default&quot;, func() {
            var (
                input  int
                result int
            )
            BeforeEach(func() {
                println(&quot;BeforeEach in Context&quot;)
                input = 1
                result = 1
            })
            AfterEach(func() {
                println(&quot;AfterEach in Context&quot;)
                input = 0
                result = 0
            })
            It(&quot;return value&quot;, func() {
                println(&quot;Exec Test Case&quot;)
                v := ReturnInt(input)
                Expect(v).To(Equal(result))
            })
        })
    })
})
</code></pre>
<p>执行结果：</p>
<pre><code class="language-sh">$ go test
Running Suite: TargetFuncs Suite
================================
Random Seed: 1571998428
Will run 1 of 1 specs

BeforeSuite
BeforeEach-2
BeforeEach-1
BeforeEach in Context
JustBeforeEach-1
JustBeforeEach-2
Exec Test Case
JustAfterEach-1
JustAfterEach-2
AfterEach in Context
AfterEach-1
AfterEach-2
•AfterSuite

Ran 1 of 1 Specs in 0.000 seconds
SUCCESS! -- 1 Passed | 0 Failed | 0 Pending | 0 Skipped
PASS
ok      studyginkgo/target_funcs    0.018s
</code></pre>
<h2 id="参考-23"><a class="header" href="#参考-23">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go-语言深入理解"><a class="header" href="#go-语言深入理解">Go 语言深入理解</a></h1>
<p>参考：<a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2019/12/23/go-blog-10-years.html" title="Go 语言官方 10 年博文">Go 语言官方 10 年博文阅读指引</a></p>
<p>Go 语言深度入门手册，帮你更好的理解 Go 语言，写出更高效、更规范、更不易出错的代码。</p>
<p>Go 在 2012 年发布 1.0 版本，距今已经 8 年了。和历史悠久近乎一成不变的 C 等编程语言不同，8 年里从 1.0 到 1.13，Go 语言在一刻不停地进化。从语法微调到性能大幅优化，代码的组织方式和配套工具等也几经变化。这意味着我们对 Go 对认知需要不停地刷新。Go 2 的设计早已提上日程，意味着 Go 1 开始趋稳，是重新整理认知的好机会。</p>
<p>学习 C 语言的时候，林锐博士撰写的小册子<a href="https://vrlab.org.cn/~zhuq/download/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.pdf" title="林锐：《高质量 C++/C 编程指南》">《高质量 C++/C 编程指南》</a>广为流传：</p>
<p><img src="go/article/./img/c-linrui.png" alt="林锐：《高质量 C++/C 编程指南》" /></p>
<p>这本小册子让我意识到，掌握语法和能写出高质量的代码，完全是两回事。对 Go 语言来说应该是一样的，掌握了语法不等于能写出高效、不易出错的代码。并且高级语言往往让我们有一种错觉，以为用了它以后不再需要仔细考虑很多细节，实际情况却是我们需要考虑更多新的细节，旧问题装进了新瓶子。</p>
<blockquote>
<p>写纯 C 代码时从来没有想过垃圾回收的问题，得知 java 以及早期的 go 语言在 gc 时候会全局 pause 时，无比震惊！竟然还有这种事......</p>
<p>这方面的问题复杂到有一个名为 International Symposium on Memory Management (ISMM) 的专门组织。Go 的核心开发人员 Rick Hudson 曾经在该组织介绍过 Go gc 的演变过程：<a href="https://blog.golang.org/ismmkeynote" title="The Journey of Go's Garbage Collector">The Journey of Go's Garbage Collector</a>。</p>
</blockquote>
<p>Go 网站上的 <a href="https://golang.org/doc/effective_go.html" title="Effective Go">《Effective Go》</a> 和 <a href="https://blog.golang.org/index" title="The Go Blog">Go Blog</a> 上的大量文章，无疑是最好的 Go 高质量编程指南，但是正如很难通过 Go 语言的语法定义<a href="https://golang.org/ref/spec" title="The Go Programming Language Specification">《The Go Programming Language Specification》</a> 学习 Go 编程，没有一定的知识储备，从《Effective Go》和 Go Blog 中汲取营养会比较吃力。</p>
<p>所以，一本「垫脚石」手册的存在会很有意义。</p>
<p>这本手册的内容非常非常浅，像「Go 的调度器如何设计」以及「三色标记算法」这种我不会的问题不会涉及。这里更关注代码如何组织，测试用例如何写，以及传参时应该注意的事项等常识性内容。相比「编程入门」，内容又比较深，所以叫做「深度入门」。</p>
<blockquote>
<p>如果要了解 Go 的实现，还有比「面向信仰编程」大神的 <a href="https://draveness.me/golang/" title="Go 语言设计与实现">《Go 语言设计与实现》</a>更好的入门资料吗？</p>
</blockquote>
<p>绝大部分内容来自 Go 的博客（<a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2019/12/23/go-blog-10-years.html" title="Go 语言官方 10 年博文">Go 语言官方 10 年博文阅读指引</a>），不能保证这里的内容「永远正确」，也不保证更新频率，Go 的官网才应当是你永生的挚爱。</p>
<blockquote>
<p>真相时刻：所有细节都忘了，需要重新整理...... 😭 </p>
</blockquote>
<h2 id="参考-24"><a class="header" href="#参考-24">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-语言项目的代码管理"><a class="header" href="#go-语言项目的代码管理">Go 语言项目的代码管理</a></h1>
<p>为什么把这一节放在最前面？因为这就是最首要的事情。</p>
<p>Go 项目的源代码管理是一个老大难的问题，Russ Cox 在<a href="https://blog.golang.org/versioning-proposal" title="A Proposal for Package Versioning in Go">《A Proposal for Package Versioning in Go》</a>中详细介绍了整个过程：最开始毫无办法，然后鼓励社区自己解决，于是 godep、glide 等遍地开花，人人苦恼，最后 Russ Cox 灵机一动，设计了 go module。</p>
<p>从 1.13 开始，GOPATH 不再是必须的，Go 的项目代码可以位于任意位置，只要使用了 go module。Go blog 用了整整 4 篇博客介绍它的用法：</p>
<ul>
<li><a href="https://blog.golang.org/using-go-modules" title="Using Go Modules">Using Go Modules</a></li>
<li><a href="https://blog.golang.org/migrating-to-go-modules" title="Migrating to Go Modules">Migrating to Go Modules</a></li>
<li><a href="https://blog.golang.org/publishing-go-modules" title="Publishing Go Modules">Publishing Go Modules</a></li>
<li><a href="https://blog.golang.org/v2-go-modules" title="Go Modules: v2 and Beyond">Go Modules: v2 and Beyond</a></li>
</ul>
<p>把这四篇博客看完，就可以告别本页了。</p>
<h2 id="要解决的问题"><a class="header" href="#要解决的问题">要解决的问题</a></h2>
<p>最早的时候 go get 直接从 github 拉取 master 上的最新代码，问题特别大，以至于很多人的解决方法是把整个 GOPATH 目录作为项目目录，依赖代码的更新成为噩梦，不知道依赖的是哪个版本，至于依赖的依赖那就更 !@#$%^&amp;*()......</p>
<p>后来 godep、glide、dep，以及 vendor 等分别解决了依赖代码管理的问题，但是仅此而已。在大型项目中，常常会使用一套代码的不同版本，这时候前面的各种工具就「摊手」了。</p>
<p>另外，项目必须位于 GOPATH 中、代码 repo 获取缓慢并占用本地空间等问题也让人烦恼。</p>
<h2 id="问题解决方法"><a class="header" href="#问题解决方法">问题解决方法</a></h2>
<p>Russ Cox 通过引入版本管理方法 <a href="https://semver.org/" title="Semantic Versioning 2.0.0">Semantic Versioning</a> 限定了问题空间，然后重新设计了依赖代码的索引和获取方法，以及本地缓存机制。</p>
<p>依赖代码以及我们自己的 Go 语言项目需要采用 Semantic 版本命名法，也就是 <code>vMAJOR.MINOR.PATCH-suffix</code> ，约定如下：</p>
<ul>
<li>只有不向后兼容的时候，譬如修改了 API 时，才可以变更主版本</li>
<li>同一个主版本下的多个子版本，对用户而言可以无脑升级，无需重新适配</li>
<li>v0.x.x 版本是最自由的版本，v1.x.x 开始要对用户负责</li>
</ul>
<p>使用 Semantic Versioning 对 go module 来说很重要， 因为多版本依赖建立在该基础上：</p>
<ul>
<li>同一套代码的多个主版本通过 <code>/vX</code> 后缀区分（从 v2 开始需要后缀）</li>
<li>不支持同时引用同一主版本的多个小版本</li>
</ul>
<p>例如，同时依赖 rsc.io/quote 的 v1 和 v3 版本，用下面的方法：</p>
<pre><code class="language-go">import (
    &quot;rsc.io/quote&quot;
    quoteV3 &quot;rsc.io/quote/v3&quot;
)
</code></pre>
<p>这种做法有一个问题：为了向后兼容，即兼容没有使用 go module 的项目，新的主版本需要独占一个目录。</p>
<p>例如上面的 <a href="https://github.com/rsc/quote" title="rsc.io/quote">rsc.io/quote</a>：</p>
<p><img src="go/article/../img/rscquote.png" alt="rsc.io/quote" /></p>
<p>v3 不仅是真实存在的目录，而且是一个独立的 go module，它有自己的 v3/go.mod，内容如下：</p>
<pre><code class="language-go">module rsc.io/quote/v3

require rsc.io/sampler v1.3.0
</code></pre>
<p>这意味着开发 v3 的时候，需要把代码拷贝一份，代码仓库中会有很多冗余代码。
如果引用端使用了 go module，是否可以避免使用独立的主版本目录呢？下面通过试验验证，同时演示 go module 的常规用法。</p>
<h2 id="参考-25"><a class="header" href="#参考-25">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-module-多版本依赖功能验证"><a class="header" href="#go-module-多版本依赖功能验证">go module 多版本依赖功能验证</a></h1>
<p>我们这里要创建的 module，它的引用方法比较特殊又比较常见——通过别名引用。</p>
<h2 id="module-初始创建"><a class="header" href="#module-初始创建">module 初始创建</a></h2>
<p>在目录 go_mod_example_pkg 中创建名为 lijiaocn.com/go/example/mod 的 module：</p>
<pre><code class="language-sh">$ mkdir go_mod_example_pkg
$ cd go_mod_example_pkg
$ go mod init lijiaocn.com/go/example/mod
go: creating new go.mod: module lijiaocn.com/go/example/mod
</code></pre>
<p>只在 version.go 中实现一个打印版本号的函数，第一个版本是 v0.0.0：</p>
<pre><code class="language-go">package mod

func Version() {
    println(&quot;v0.0.0&quot;)
}
</code></pre>
<p>上传到 github <a href="https://github.com/introclass/go_mod_example_pkg.git" title="introclass/go_mod_example_pkg">introclass/go_mod_example_pkg</a>。</p>
<p>然后将 println(&quot;v0.0.0&quot;) 修改为 println(&quot;v1.0.0&quot;) ，发布 v1 版本：</p>
<pre><code class="language-sh">$ git add .
$ git commit -m &quot;release v1.0.0&quot;
$ git push
$ git tag v1.0.0
$ git push origin v1.0.0
</code></pre>
<p>然后按照兼容 GOPATH 的方式，创建 v2 版本：</p>
<pre><code class="language-sh">$ mkdir v2
$ cd v2
$ go mod init lijiaocn.com/go/example/mod/v2
</code></pre>
<p>在 v2 目录中重新实现 version.go：</p>
<pre><code class="language-go">package v2

func Version() {
    println(&quot;v2.0.0&quot;)
}
</code></pre>
<p>提交代码，打标签，发布 v2.0.0：</p>
<pre><code class="language-sh">$ git add .
$ git commit -m &quot;release v2.0.0&quot;
$ git push
$ git tag v2.0.0
$ git push origin v2.0.0
</code></pre>
<p>最后为了验证不使用独立主版本目录的效果，直接修改 version.go，发布 v3.0.0 版本：</p>
<pre><code class="language-sh">$ git add .
$ git commit -m &quot;release v3.0.0&quot;
$ git push
$ git tag v3.0.0
$ git push origin v3.0.0
</code></pre>
<h2 id="module-别名设置"><a class="header" href="#module-别名设置">module 别名设置</a></h2>
<p>上面创建的 module 现在还不能通过 lijiaocn.com/go/example/mod 引用，需要进行额外设置。</p>
<p>引用 github 上的代码通常使用 &quot;import github.com/xxx/xxx&quot; 的形式，import 指令后面是 repo 路径。</p>
<p>但是你一定遇到这种情况，项目在 github 上，但是 import 使用的是另一个路径（别名）。
譬如上一节中的 <a href="https://github.com/rsc/quote" title="rsc.io/quote">rsc.io/quote</a> 代码路径是 &quot;github.com/rsc/quote&quot;，引用时用的是 &quot;rsc.io/quote&quot;：</p>
<pre><code class="language-go">import (
    &quot;rsc.io/quote&quot;
    quoteV3 &quot;rsc.io/quote/v3&quot;
)
</code></pre>
<p>这是怎样做到的？</p>
<p>在浏览器中打开 <a href="https://rsc.io/quote">https://rsc.io/quote </a> 不会有任何收获，要用下面的方法才能发现端倪：</p>
<pre><code class="language-sh">$ curl  https://rsc.io/quote/v3 |grep go-import
&lt;meta name=&quot;go-import&quot; content=&quot;rsc.io/quote git https://github.com/rsc/quote&quot;&gt;
</code></pre>
<p>名为 go-import 的 meta 标签的 content 中包含 git 仓库地址，这是 go get 的能力之一：从 meta 中获取 repo 地址，详情见 <a href="https://golang.org/cmd/go/#hdr-Remote_import_paths" title="Remote import paths">Remote import paths</a>。</p>
<p>要通过 lijiaocn.com/go/example/mod 名称引用前面的 module，需要在站点 lijiaocn.com 中创建下面的文件：</p>
<pre><code class="language-sh">$ mkdir -p go/example/mod
$ cat &lt;&lt;EOF &gt; go/example/mod/index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
&lt;meta name=&quot;go-import&quot; content=&quot;lijiaocn.com/go/example/mod git https://github.com/introclass/go_mod_example_pkg&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;codes at: &lt;a href=&quot;https://github.com/introclass/go_mod_example_pkg&quot;&gt;https://github.com/introclass/go_mod_example_pkg&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
EOF
</code></pre>
<h2 id="module-引用效果"><a class="header" href="#module-引用效果">module 引用效果</a></h2>
<p>前期工作准备完成，现在验证效果。</p>
<pre><code class="language-sh">$ mkdir usemod
$ cd usemod 
$ go mod init usemod
</code></pre>
<p>代码如下：</p>
<pre><code class="language-go">package main

import &quot;lijiaocn.com/go/example/mod&quot;

func main() {
    mod.Version()
}
</code></pre>
<p>不指定版本号时：</p>
<pre><code class="language-sh">$ go get lijiaocn.com/go/example/mod
</code></pre>
<p>执行结果为 v1.0.0：</p>
<pre><code class="language-sh">$ go run main.go 
v1.0.0
</code></pre>
<p>怀疑不指定版本号时，默认使用 v1 主版本的最新版本，按上一节的步骤加一个 v1.1.0 版本后：</p>
<pre><code class="language-sh">$ go get lijiaocn.com/go/example/mod
go: finding lijiaocn.com/go/example/mod v1.1.0
</code></pre>
<p>果然，目标 module 中的 v2.0.0 和 v3.0.0 被直接无视，使用的是 v1 的最新版本。</p>
<p>尝试引用 v3.0.0 版本，结果出错，必须要有 /v3 （ <strong>第一个结论</strong> ）：</p>
<pre><code class="language-sh">$ go get lijiaocn.com/go/example/mod@v3.0.0
go: finding lijiaocn.com/go/example/mod v3.0.0
go get lijiaocn.com/go/example/mod@v3.0.0: lijiaocn.com/go/example/mod@v3.0.0: invalid version: module contains a go.mod file, so major version must be compatible: should be v0 or v1, not v3
</code></pre>
<p>使用 v2 和 v3 后缀，需要为 v2 和 v3 准备一个 index.html（ <strong>同一个 repo 不需要修改</strong> ）：</p>
<pre><code class="language-sh">$ mkdir go/example/mod/v3
$ cp go/example/mod/index.html go/example/mod/v2
$ cp go/example/mod/index.html go/example/mod/v3
</code></pre>
<p>同时引用 v1 和 v2：</p>
<pre><code class="language-go">package main

import &quot;lijiaocn.com/go/example/mod&quot;
import &quot;lijiaocn.com/go/example/mod/v2&quot;

func main() {
    mod.Version()
    v2.Version()
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-sh">$ go run main.go 
v1.1.0
v2.0.0
</code></pre>
<p>最后测试下没有独立目录的 v3 是否能引用：</p>
<pre><code class="language-go">package main

import &quot;lijiaocn.com/go/example/mod&quot;
import &quot;lijiaocn.com/go/example/mod/v2&quot;
import &quot;lijiaocn.com/go/example/mod/v3&quot;

func main() {
    mod.Version()
    v2.Version()
    v3.Version()
}
</code></pre>
<p>结论是不可以，必须要有独立目录：</p>
<pre><code class="language-sh">$ go run main.go 
go: finding lijiaocn.com/go/example/mod/v3 v3.0.0
build command-line-arguments: cannot load lijiaocn.com/go/example/mod/v3: 
    module lijiaocn.com/go/example/mod@latest (v1.1.0) found, 
    but does not contain package lijiaocn.com/go/example/mod/v3
</code></pre>
<p>上一节提出的问题答案：v1 之后的主版本都必须有独立的目录，repo 中代码冗余不可避免，至少现阶段 go 1.13 是这样的（2019-12-31 16:53:07）。</p>
<h2 id="参考-26"><a class="header" href="#参考-26">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="测试用例的覆盖率"><a class="header" href="#测试用例的覆盖率">测试用例的覆盖率</a></h1>
<p>Go 语言在设计的时候就考虑到工程实践，融入了注释文档、单元测试和基准测试等软件工程中的技术，上一节提到的代码组织方法也是软件工程思想的体现。在语言层面统一工具和方法，极大地提高了协作效率。</p>
<p>单元测试是工作代码之外最重要的内容， Go 语言天生支持。测试用例的写法只要看几个例子就学会了，譬如下面这个最简单函数功能测试。</p>
<p><strong>目标文件 funcs.go：</strong></p>
<pre><code class="language-go">package testcase

func SumSlice(nums []int) int {
    sum := 0
    for _,v := range nums{
        sum=sum+v
    }
    return sum
}

func SumArray(nums [10]int) int{
    sum := 0
    for _,v := range nums{
        sum=sum+v
    }
    return sum
}
</code></pre>
<p><strong>测试用例 funcs_test.go：</strong></p>
<pre><code class="language-go">package testcase

import (
    &quot;testing&quot;
)

func TestSumSlice(t *testing.T) {
    arrays := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    expect := 45
    sum := SumSlice(arrays[:])
    if sum != expect {
        t.Errorf(&quot;result is %d (should be %d)&quot;, sum, expect)
    }
}
</code></pre>
<p>然后重点来了，执行 go test 只会告知测试是否通过：</p>
<pre><code class="language-go">$ go test       
PASS
ok      go-code-example/testcase        0.806s
</code></pre>
<p>强大的是 -cover，可以告知测试覆盖率：</p>
<pre><code class="language-go">$ go test -cover
PASS
coverage: 50.0% of statements
ok      go-code-example/testcase        0.306s
</code></pre>
<p>上面的测试用例覆盖率只有 50%，用下面的方法查看没有覆盖的代码：</p>
<pre><code class="language-go">$ go test -coverprofile=coverage.out 
$ go tool cover -html=coverage.out  
</code></pre>
<p><img src="go/article/../img/cover.png" alt="测试覆盖情况" /></p>
<p>测试覆盖率的详细说明见 <a href="https://blog.golang.org/cover" title="The cover story">The cover story</a>。</p>
<h2 id="参考-27"><a class="header" href="#参考-27">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-语言按值传递的开销很大"><a class="header" href="#go-语言按值传递的开销很大">Go 语言按值传递的开销很大</a></h1>
<p>Go 语言所有的参数都是按值传递，Go 语言中所有的变量都是值，特别是数组也是值。</p>
<h2 id="数组也按值传递"><a class="header" href="#数组也按值传递">数组也按值传递</a></h2>
<p>如果把一个数组作为参数，那么这个数组会被完整的拷贝一份，执行效率会严重降低。</p>
<p>以前面用到的 funcs.go 为例：</p>
<pre><code class="language-go">package testcase

func SumSlice(nums []int) int {
    sum := 0
    for _,v := range nums{
        sum=sum+v
    }
    return sum
}

func SumArray(nums [10]int) int{
    sum := 0
    for _,v := range nums{
        sum=sum+v
    }
    return sum
}
</code></pre>
<p>写两个基准测试函数：</p>
<pre><code class="language-go">package testcase

import (
    &quot;testing&quot;
)

func TestSumSlice(t *testing.T) {
    arrays := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    expect := 45
    sum := SumSlice(arrays[:])
    if sum != expect {
        t.Errorf(&quot;result is %d (should be %d)&quot;, sum, expect)
    }
}

func BenchmarkSumSlice(b *testing.B) {
    arrays := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s := arrays[:]
    for i := 0; i &lt; b.N; i++ {
        SumSlice(s)
    }
}

func BenchmarkSumArray(b *testing.B) {
    arrays := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    for i := 0; i &lt; b.N; i++ {
        SumArray(arrays)
    }
}
</code></pre>
<p>基准测试结果如下结果如下：</p>
<pre><code class="language-sh">goos: darwin
goarch: amd64
pkg: go-code-example/testcase
BenchmarkSumSlice-4   	161025976	         6.67 ns/op
BenchmarkSumArray-4   	90106534	        13.9 ns/op
</code></pre>
<p>可以看到在数组长度只有 10 的情况下， SumSlice 和 SumArray 的执行效率就已经相差悬殊。</p>
<h2 id="参考-28"><a class="header" href="#参考-28">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-并发与按值传递引发的血案"><a class="header" href="#go-并发与按值传递引发的血案">Go 并发与按值传递引发的血案</a></h1>
<p>前段时间出去面试的时候，被一道题难住了，问下面这段代码的运行输出是什么：</p>
<pre><code class="language-go">func wg1() {
    wg := sync.WaitGroup{}

    for i := 0; i &lt; 10; i++ {
        go func(wg sync.WaitGroup) {
            wg.Add(1)
            println(i)
            wg.Done()
        }(wg)
    }
    wg.Wait()
}
</code></pre>
<p>当时没有搞清楚 sync.WaitGroup 的特性，结果很尴尬。面试官给的答案是没有任何输出，原因是 wg 按值传递。事实上，情况不是这么简单，正确的答案是「不确定」，可能没有输出，可能打印少于 10 个数字，可能打印了几个重复的数字。</p>
<p>这段代码的问题很大，涉及按值传递、并发，以及变量作用域等方面的内容，改了几次才改出正确的代码。</p>
<h2 id="wg2不仅仅是传值的问题"><a class="header" href="#wg2不仅仅是传值的问题">wg2()：不仅仅是传值的问题</a></h2>
<p>如果只是按值传递的问题，即 wg 被复制了 10 份导致 wg.Wait() 没有等待，那么换用指针应该能解决问题：</p>
<pre><code class="language-go">func wg2() {
    wg := sync.WaitGroup{}

    for i := 0; i &lt; 10; i++ {
        go func(wg *sync.WaitGroup) {
            wg.Add(1)
            println(i)
            wg.Done()
        }(&amp;wg)
    }
    wg.Wait()
}
</code></pre>
<p>结论是不行！运行结果不稳定，数字有重复，而且有时还会 panic：</p>
<pre><code class="language-sh">$ ./waitgroup
10
10
10
10
10

$ ./waitgroup
8
10
10
...

panic: sync: WaitGroup is reused before previous Wait has returned
</code></pre>
<h2 id="wg3简化场景直接使用-wg"><a class="header" href="#wg3简化场景直接使用-wg">wg3()：简化场景直接使用 wg</a></h2>
<p>先简化场景，把按值传递的问题排除，直接使用 wg：</p>
<pre><code class="language-go">func wg3() {
    wg := sync.WaitGroup{}

    for i := 0; i &lt; 10; i++ {
        go func() {
            wg.Add(1)
            println(i)
            wg.Done()
        }()
    }
    wg.Wait()
}
</code></pre>
<p><strong>大多数情况下</strong> 会打印 10 个数字，但是数字有重复：</p>
<pre><code class="language-go">$ ./waitgroup
4
4
4
10
10
10
10
10
10
10
</code></pre>
<p><strong>这段代码在 goroutine 方面还是有问题的，wg5() 中说明</strong></p>
<h2 id="wg4i-通过参数传递消除重复"><a class="header" href="#wg4i-通过参数传递消除重复">wg4()：i 通过参数传递，消除重复</a></h2>
<p>wg3() 有两个问题，第一输出的数字重复，第二偶尔输出的数字不足 10 个，先解决数字重复的问题。</p>
<p>数字重复是因为 goroutine 中直接使用了变量 i，打印的是 goroutine 执行时的 i 值，而不是创建 goroutine 时的 i 值。</p>
<p>将 i 改为参数传递：</p>
<pre><code class="language-go">func wg4() {
    wg := sync.WaitGroup{}

    for i := 0; i &lt; 10; i++ {
        go func(i int) {
            wg.Add(1)
            println(i)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
</code></pre>
<p>这时候，输出结果中没有重复的数字：</p>
<pre><code class="language-sh">$ ./waitgroup
1
6
5
7
0
4
2
8
3
9
</code></pre>
<p>第二个问题没有解决，有时候输出的数字不足 10 个，例如：</p>
<pre><code class="language-sh">$ ./waitgroup
0
2
1
$ ./waitgroup
1%
</code></pre>
<h2 id="wg5将-wg-的操作移出-goroutine"><a class="header" href="#wg5将-wg-的操作移出-goroutine">wg5()：将 wg 的操作移出 goroutine</a></h2>
<p>wg3() 和 wg4() 中的主函数有可能在 goroutine 之前退出，导致输出的数字不足 10 个。为什么会这样，wg.wait() 无效吗？</p>
<p>问题在于 wg.Add() 的执行时机，仔细看 wg3() 和 wg4() 中的 wg.Add()，它是在 goroutine 中执行的。</p>
<p>因为 goroutine 是并发的，wg.Add() 还没执行, 主函数可能就执行到了 wg.wait() ，从而直接退出。</p>
<p>需要将 wg.Add() 移出 goroutine，确保 wg.Wait() 有效，注意 wg.Done() 不能移出，否则主函数又会先于 goroutine 退出：</p>
<pre><code class="language-go">func wg5() {
    wg := sync.WaitGroup{}

    for i := 0; i &lt; 10; i++ {
        wg.Add(1)
        go func(i int) {
            println(i)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
</code></pre>
<p>这时候稳定输出 10 个不重复的数字，数字不是递增排列，因为 goroutine 并发执行，顺序不固定：</p>
<pre><code class="language-go">1
0
4
3
5
6
9
7
8
2
</code></pre>
<h2 id="wg6重新用指针传递"><a class="header" href="#wg6重新用指针传递">wg6()：重新用指针传递</a></h2>
<p>回顾 wg2()，因为不确定指针的效用，wg3()~wg5() 中没有使用指针，在简化的场景下解决了并发和数字重复的问题。</p>
<p>现在验证一下使用指针是否可行：</p>
<pre><code class="language-go">func wg6() {
    wg := sync.WaitGroup{}

    for i := 0; i &lt; 10; i++ {
        wg.Add(1)
        go func(i int, wg *sync.WaitGroup) {
            println(i)
            wg.Done()
        }(i, &amp;wg)
    }
    wg.Wait()
}
</code></pre>
<p>结论是可以，而且这种情况下必须使用指针，如果不用指针是有问题的。</p>
<p>如果不用指针，goroutine 中的 wg.Done() 是无效的，因为 goroutine 中的 wg 是一个副本，结果会是这样：</p>
<pre><code class="language-sh">1
0
5
2
9
6
4
8
7
3
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [semacquire]:
sync.runtime_Semacquire(0xc000068008)
	/Users/lijiao/Work/Bin/go-1.13/go/src/runtime/sema.go:56 +0x42
sync.(*WaitGroup).Wait(0xc000068000)
	/Users/lijiao/Work/Bin/go-1.13/go/src/sync/waitgroup.go:130 +0x64
main.wg7()
	/Users/lijiao/Work/go-code-example/waitgroup/waitgroup.go:97 +0xbb
main.main()
	/Users/lijiao/Work/go-code-example/waitgroup/waitgroup.go:107 +0x20

Process finished with exit code 2
</code></pre>
<h2 id="参考-29"><a class="header" href="#参考-29">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-语言程序运行时跟踪调试"><a class="header" href="#go-语言程序运行时跟踪调试">Go 语言程序运行时跟踪调试</a></h1>
<p><a href="https://github.com/go-delve/delve" title="delve">delve</a> 是现阶段最好用的跟踪调试工具，支持 Linux 和 macOS，是 GoLand 使用的调试工具。</p>
<p>（2020-01-01 19:27:25）</p>
<p>macOS 上安装 delve：</p>
<pre><code class="language-sh">$ xcode-select --install  # 如果已经安装了 xcode 工具，这一步不需要
$ go get -u github.com/go-delve/delve/cmd/dlv
</code></pre>
<pre><code class="language-sh">Usage:
  dlv [command]

Available Commands:
  attach      Attach to running process and begin debugging.
  connect     Connect to a headless debug server.
  core        Examine a core dump.
  debug       Compile and begin debugging main package in current directory, or the package specified.
  exec        Execute a precompiled binary, and begin a debug session.
  help        Help about any command
  run         Deprecated command. Use 'debug' instead.
  test        Compile test binary and begin debugging program.
  trace       Compile and begin tracing program.
  version     Prints version.
</code></pre>
<h2 id="目标程序"><a class="header" href="#目标程序">目标程序</a></h2>
<p>写一个超级简单的小程序作为跟踪调试目标：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func Write(num int, c chan int) {
    for {
        c &lt;- num
    }
}

func main() {
    c := make(chan int)
    go Write(10, c)
    go Write(20, c)
    for {
        select {
        case v := &lt;-c:
            fmt.Printf(&quot;receive %d\n&quot;, v)
            time.Sleep(2 * time.Second)
        }
    }
}
</code></pre>
<h2 id="dlv-调试"><a class="header" href="#dlv-调试">dlv 调试</a></h2>
<p>用 dlv attach 正在运行中的进程（attach 后进程会被接管，暂停运行）：</p>
<pre><code class="language-sh">$ dlv attach  7282
Type 'help' for list of commands.
(dlv)
</code></pre>
<p>help 查看 dlv 支持的调试命令：</p>
<p><img src="go/article/../img/dlv.png" alt="delve命令-help" /></p>
<p>grs 显示所有的 goroutine：</p>
<p><img src="go/article/../img/grs.png" alt="delve命令-grs" /></p>
<p>gr 显示当前的 goroutine 或者切换到指定的 goroutine：</p>
<p><img src="go/article/../img/gr.png" alt="delve命令-gr" /></p>
<p>打断点：</p>
<p><img src="go/article/../img/break.png" alt="delve命令-break" /></p>
<p>到断点位置后，用 gr 打印当前的 goroutine，会发现在 18 和 19 两个 goroutine 之间切换：</p>
<pre><code class="language-sh">(dlv) c
......
(dlv) gr
Thread 120198 at /Users/lijiao/Work/go-code-example/debug/debug.go:10
Goroutine 19:
......
(dlv) c
......
(dlv) gr
Thread 120196 at /Users/lijiao/Work/go-code-example/debug/debug.go:10
Goroutine 18:
......
</code></pre>
<p>单步执行 <code>n</code>，进入调用函数 <code>s</code>，查看调用栈 <code>bt</code>，切换调用栈位置 <code>frame POS</code> 等指令与 gdb 中的同名指令用法相似。其它指令这里不罗列了，dlv 的 help 中都有。</p>
<p>Go 1.11 和 Go 1.12 持续优化了 Go 语言程序的调试体验，详情见：<a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2019/12/23/go-blog-10-years.html#%E8%B0%83%E8%AF%95%E8%B0%83%E4%BC%98" title="Go 1.12 调试优化">Go 1.12 调试优化</a>。</p>
<h2 id="参考-30"><a class="header" href="#参考-30">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="go-语言程序运行时状态查看"><a class="header" href="#go-语言程序运行时状态查看">Go 语言程序运行时状态查看</a></h1>
<p>上一节用 dlv 调试运行中的 Go 语言程序，dlv 会打断进程的运行，在开发测试时可以用。</p>
<p>对于生产环境中运行的进程，可以用 Go 内置的性能分析工具 pprof 窥测进程的当前状况。</p>
<p><a href="https://blog.golang.org/profiling-go-programs" title="Profiling Go Programs">Profiling Go Programs</a> 很好地演示了用 pprof 找到性能瓶颈的过程，这里只演示简单用法。</p>
<h2 id="启用实时的-pprof"><a class="header" href="#启用实时的-pprof">启用实时的 pprof</a></h2>
<p>启用实时的 pprof 非常简单，只需要引入 &quot;net/http/pprof&quot;，然后启动 http server 就可以了：</p>
<pre><code class="language-go">import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    _ &quot;net/http/pprof&quot;
    &quot;time&quot;
)

func Write(num int, c chan int) {
    for {
        c &lt;- num
    }
}

func main() {
    go func() {
        log.Println(http.ListenAndServe(&quot;localhost:6060&quot;, nil))
    }()

    c := make(chan int)
    go Write(10, c)
    go Write(20, c)

    for {
        select {
        case v := &lt;-c:
            fmt.Printf(&quot;receive %d\n&quot;, v)
            time.Sleep(2 * time.Second)
        }
    }
}
</code></pre>
<p>直接用浏览器打开 http://127.0.0.1:6060/debug/pprof/ 查看：</p>
<p><img src="go/article/../img/pprof.png" alt="浏览器查看 pprof" /></p>
<p>其中 debug/pprof/profile 是 cpu 采样文件，访问时触发，用 seonds 参数控制采集持续时间：</p>
<pre><code class="language-sh"># 默认是 30 秒
http://localhost:6060/debug/pprof/profile?seconds=30
</code></pre>
<p>360 的 Zhou Yang 在分享 <a href="https://blog.golang.org/qihoo" title="Qihoo 360 and Go">Qihoo 360 and Go</a> 中提到，他们基于 pprof 做了一套 web 展示：</p>
<p><img src="go/article/../img/pprof2.png" alt="360 pprof展示" /></p>
<p>对于非常驻运行的 Go 语言程序，可以在程序添加代码，经 pprof 信息写入文件中：</p>
<pre><code class="language-go">var cpuprofile = flag.String(&quot;cpuprofile&quot;, &quot;&quot;, &quot;write cpu profile to file&quot;)

func main() {
    flag.Parse()
    if *cpuprofile != &quot;&quot; {
        f, err := os.Create(*cpuprofile)
        if err != nil {
            log.Fatal(err)
        }
        pprof.StartCPUProfile(f)
        defer pprof.StopCPUProfile()
    }
    ...
</code></pre>
<h2 id="如何使用-pprof"><a class="header" href="#如何使用-pprof">如何使用 pprof</a></h2>
<p>如何使用 pprof 才是重点，除了 profile 和 trace ，其它 url 可以直接在浏览器中查看，profile 和 trace 是两个采样文件要分别用 pprof 和 trace 工具查看。</p>
<p>对于离线文件：</p>
<pre><code class="language-sh">$ go tool pprof havlak1 havlak1.prof
Welcome to pprof!  For help, type 'help'.
(pprof)
</code></pre>
<p>对于在线地址，以 cpu 采样为例（为了采集到数据把上面程序中的 sleep 时间调整为 0）：</p>
<pre><code class="language-sh">$ go tool pprof http://localhost:6060/debug/pprof/profile   # 30-second CPU profile
</code></pre>
<p><img src="go/article/../img/cpuprofile.png" alt="pprof 查看 cpu 采样" /></p>
<p>web 命令绘制采样图并用浏览器打开 ，如果遇到下面错误，安装 graphviz：</p>
<pre><code class="language-sh">(pprof) web
failed to execute dot. Is Graphviz installed? Error: exec: &quot;dot&quot;: executable file not found in $PATH
</code></pre>
<p>macOS 上安装： </p>
<pre><code class="language-sh">$ brew install graphviz
</code></pre>
<p>绘制的采样图如下：</p>
<p><img src="go/article/../img/pprofx.png" alt="pprof 采样图" /></p>
<p>右键在单独窗口打开原始图片，svg 格式，可缩小放大：<a href="go/article/../img/pprof001.svg">原始图片</a></p>
<h2 id="trace-查看"><a class="header" href="#trace-查看">trace 查看</a></h2>
<p>trace 要将文件下载以后，用 go tool trace 查看：</p>
<pre><code class="language-sh">$ wget http://localhost:6060/debug/pprof/trace
$ go tool trace trace
</code></pre>
<p>打开效果如下：</p>
<p><img src="go/article/../img/trace.png" alt="go tool trace" /></p>
<h2 id="参考-31"><a class="header" href="#参考-31">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="有大量反序列化时目标-struct-的成员用指针"><a class="header" href="#有大量反序列化时目标-struct-的成员用指针">有大量反序列化时，目标 Struct 的成员用指针</a></h1>
<p><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2019/12/23/go-blog-10-years.html#%E5%B8%B8%E8%A7%84%E7%BB%86%E8%8A%82" title="json 序列化和反序列化">JSON and Go</a> 中介绍反序列化时说，介绍了目标 struct 中有 Reference Type 类型成员时的处理：</p>
<pre><code class="language-go">type FamilyMember struct {
    Name    string
    Age     int
    Parents []string
}

var m FamilyMember
err := json.Unmarshal(b, &amp;m)
</code></pre>
<p>FamilyMember 的 Parents 是一个 Slice，在反序列化时候，会为它分配空间。</p>
<p>重点是，如果目标字符串中没有 Parents，那么 Parents 是 nil。据此判断，反序列化的目标 struct 中应当尽可能的使用 Reference Type，在有缺失字段时，这种方式更高效且节省内存。</p>
<h2 id="两种定义方式"><a class="header" href="#两种定义方式">两种定义方式</a></h2>
<p>Obj 定义了长度为 100 的数组，ObjP 使用的是 Slice：</p>
<pre><code class="language-go">package unmarshal

import &quot;encoding/json&quot;

type Obj struct {
    Value int
    Array [100]int
}

type ObjP struct {
    Value int
    Array []int
}

func UnmarshalObj(str []byte, v interface{}) {
    json.Unmarshal(str, v)
}

func UnmarshalObjP(str []byte, v interface{}) {
    json.Unmarshal(str, v)
}
</code></pre>
<h2 id="基准测试结果"><a class="header" href="#基准测试结果">基准测试结果</a></h2>
<p>基准测试代码如下，模拟实际场景，每次反序列化都用一个新的变量，设计了 Array 有和无两种场景：</p>
<pre><code class="language-go">package unmarshal

import (
    &quot;testing&quot;
)

var objstr_noarray = []byte(`{&quot;Value&quot;:10}`)
var objstr_array = []byte(`{&quot;Value&quot;:10, &quot;Array&quot;:[1,2,3,4,5,7,8]}`)

func BenchmarkUnmarshalObjNoArray(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        obj := &amp;Obj{}
        UnmarshalObj(objstr_noarray, obj)
    }
}

func BenchmarkUnmarshalObjPNoArray(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        obj := &amp;ObjP{}
        UnmarshalObjP(objstr_noarray, obj)
    }
}

func BenchmarkUnmarshalObjArray(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        obj := &amp;Obj{}
        UnmarshalObj(objstr_array, obj)
    }
}

func BenchmarkUnmarshalObjPArray(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        obj := &amp;ObjP{}
        UnmarshalObjP(objstr_array, obj)
    }
}
</code></pre>
<p>基准测试结果显示，执行效率的差距非常明显：</p>
<pre><code class="language-sh">goos: darwin
goarch: amd64
pkg: go-code-example/unmarshal
BenchmarkUnmarshalObjNoArray-4    	 1385480	       861 ns/op
BenchmarkUnmarshalObjPNoArray-4   	 1712936	       693 ns/op
BenchmarkUnmarshalObjArray-4      	  229220	      4899 ns/op
BenchmarkUnmarshalObjPArray-4     	  367184	      2883 ns/op
PASS
</code></pre>
<h2 id="参考-32"><a class="header" href="#参考-32">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="gin-框架的学习资料"><a class="header" href="#gin-框架的学习资料">Gin 框架的学习资料</a></h1>
<p>Go 内置了 http.Server 的实现，如下：</p>
<pre><code class="language-go">package main

import (
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;time&quot;
)

type NewHandler struct{}

func (s *NewHandler) ServeHTTP(writer http.ResponseWriter, req *http.Request) {
    // 根据 req 查找对应的 handler
    if req.URL.Path == &quot;/hello2&quot; {
        writer.Write([]byte(&quot;Hello2 World!&quot;))
    }
}

func newServer(addr string) {
    s := &amp;http.Server{
        Addr:              addr,
        Handler:           nil,
        TLSConfig:         nil,
        ReadTimeout:       0,
        ReadHeaderTimeout: 0,
        WriteTimeout:      0,
        IdleTimeout:       0,
        MaxHeaderBytes:    0,
        TLSNextProto:      nil,
        ConnState:         nil,
        ErrorLog:          nil,
        BaseContext:       nil,
        ConnContext:       nil,
    }
    s.Handler = &amp;NewHandler{}
    log.Fatal(s.ListenAndServe())
}

func main() {
    // $ curl 127.0.0.1:8082/hello2
    // Hello2 World!%
    go newServer(&quot;:8082&quot;)
    time.Sleep(1000 * time.Second)
}
</code></pre>
<p>可以看到关键是：当一个 http 请求到达时，ServerHTTP() 怎样快速找到对应的处理函数进行响应。Gin 最主要功能就是实现 request 与处理函数直接映射，也就是 router 管理。</p>
<pre><code class="language-go">package main

import (
    &quot;github.com/gin-gonic/gin&quot;
    &quot;net/http&quot;
    &quot;time&quot;
)

func main() {
    r := gin.Default()
    r.GET(&quot;/ping&quot;, func(c *gin.Context) {
        c.JSON(200, gin.H{
            &quot;message&quot;: &quot;pong&quot;,
        })
    })

    //r.Run() // listen and serve on 0.0.0.0:8080
    s := &amp;http.Server{
        Addr:           &quot;:8080&quot;,
        Handler:        r,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   10 * time.Second,
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }
    s.ListenAndServe()
}
</code></pre>
<p>Gin 选用 <a href="https://en.wikipedia.org/wiki/Radix_tree" title="Radix_tree">Radix_tree</a> 管理路由表，Radis_tree 是“树”的一种，实现了不定长字符串的查找，叶子节点中存放的 handler 函数，非叶子节点指向子节点，并在“边”中标记前缀字符：</p>
<p>因为每条边中包含不止一个字符，所有 Radis_tree 的高度降低，查找效率提高。</p>
<p><img src="go/gin/../img/radis_tree.png" alt="radis_tree" /></p>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
<li><a href="https://github.com/gin-gonic/gin" title="gin-gonic/gin">gin-gonic/gin</a></li>
<li><a href="https://gin-gonic.com/zh-cn/docs/" title="gin web framework">gin web framework</a></li>
<li><a href="https://en.wikipedia.org/wiki/Radix_tree" title="Radix_tree">Radix_tree</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="gin-快速开始"><a class="header" href="#gin-快速开始">Gin 快速开始</a></h1>
<p>建议直接使用 Go 1.13 以及以上版本，用 go mod 进行依赖管理（<a href="go/gin/../article/pkg.html">代码要如何组织?</a>)。</p>
<h2 id="示范代码"><a class="header" href="#示范代码">示范代码</a></h2>
<p>示范代码下载方法：</p>
<pre><code class="language-sh">git clone https://github.com/introclass/go-code-example.git
</code></pre>
<p>然后在 IntelliJ IDEA、goLand 或其它习惯使用的 IDE 中创建一个新项目，导入目录 go-code-example，如果是 IntelliJ IDEA，注意勾选 go module。</p>
<h2 id="使用-gin-生成的-handler"><a class="header" href="#使用-gin-生成的-handler">使用 Gin 生成的 Handler</a></h2>
<p>在这里 Gin 唯一的作用就是为 http.Server 提供一个 Handler，<code>r := gin.Default()</code>，在这个 Handler 中注入了对应的 HandlerFunc：</p>
<pre><code class="language-go">	r := gin.Default()
	r.GET(&quot;/ping&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;pong&quot;,
		})
	})

	//r.Run() // listen and serve on 0.0.0.0:8080
	s := &amp;http.Server{
		Addr:           &quot;:8080&quot;,
		Handler:        r,
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   10 * time.Second,
		MaxHeaderBytes: 1 &lt;&lt; 20,
	}
	s.ListenAndServe()
</code></pre>
<p>完整代码：<a href="https://github.com/introclass/go-code-example/tree/master/ginusage/01quickstart">ginusage/01quickstart</a></p>
<h2 id="参考-33"><a class="header" href="#参考-33">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="gin-的-router-管理"><a class="header" href="#gin-的-router-管理">Gin 的 router 管理</a></h1>
<p>这里所说的路由就是就是 http 请求的 method、path 与处理函数的对应关系。</p>
<p>Gin 的路由设置方法非常简单，处理函数定义如下（只有一个传入参数）：</p>
<pre><code class="language-go">type HandlerFunc func(*Context)
</code></pre>
<p>下面的 echo 就是一个处理函数，它用 c.JSON() 向请求端发送了响应数据。</p>
<pre><code class="language-go">func echo(c *gin.Context) {
    c.JSON(200, gin.H{
        &quot;method&quot;: c.Request.Method,
        &quot;uri&quot;:    c.Request.URL.String(),
    })
}
</code></pre>
<h2 id="按照-method-设置"><a class="header" href="#按照-method-设置">按照 method 设置</a></h2>
<pre><code class="language-go">router := gin.Default()

router.GET(&quot;/get&quot;, echo)
router.POST(&quot;/post&quot;, echo)
router.PUT(&quot;/put&quot;, echo)
router.DELETE(&quot;/delete&quot;, echo)
router.PATCH(&quot;/patch&quot;, echo)
router.HEAD(&quot;/head&quot;, echo)
router.OPTIONS(&quot;/option&quot;, echo)
</code></pre>
<h2 id="router-分组"><a class="header" href="#router-分组">router 分组</a></h2>
<p>上面平铺的设置方法有时候不能满足我们的需要，譬如当 API 有版本的时候， 我们希望能够分组处理：</p>
<pre><code class="language-go">groupv1 := router.Group(&quot;/v1&quot;)
{
    groupv1.GET(&quot;/hello&quot;, echo)
}

groupv2 := router.Group(&quot;/v1&quot;)
{
    groupv2.GET(&quot;/hello&quot;, echo)
}
</code></pre>
<h2 id="参考-34"><a class="header" href="#参考-34">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="gin-的请求参数获取"><a class="header" href="#gin-的请求参数获取">Gin 的请求参数获取</a></h1>
<p>http 的请求参数通常通过以下集中方式传入。</p>
<ul>
<li>附加在 url 后面的（用 ? 分隔）的 query 参数，譬如下面的 name 和 age：</li>
</ul>
<pre><code class="language-sh">127.0.0.1:8080/query?name=XX&amp;age=11
</code></pre>
<ul>
<li>URI 中特定位置的字符认做传入参数：</li>
</ul>
<p>假设路径参数定义为：/user/NAME/ACTION</p>
<p>127.0.0.1:8080/user/xiaoming/run 传入的参数就是 NAME=xiaoming，ACTION=run</p>
<ul>
<li>
<p>在 HTTP Header 中设置的参数</p>
</li>
<li>
<p>通过 post 提交的、位于 http 请求 body 中的数据</p>
</li>
</ul>
<p>以上参数以及其它所有的请求信息，都传入的 *gin.Context 获取。</p>
<h2 id="uri-query-参数"><a class="header" href="#uri-query-参数">URI query 参数</a></h2>
<p>URL 的多个 query 参数用 &amp; 间隔，用 c.QueryXX 方法读取：</p>
<pre><code class="language-go">//匹配：127.0.0.1:8080/query?name=xiaoming&amp;age=11
func query(c *gin.Context) {
    name := c.DefaultQuery(&quot;name&quot;, &quot;Guest&quot;)
    age := c.Query(&quot;age&quot;)

    c.String(http.StatusOK, &quot;%s is %s years\n&quot;, name, age)
}
</code></pre>
<p>同名的参数被认为是数组：</p>
<pre><code class="language-go">//匹配：&quot;127.0.0.1:8080/arr?ids=A&amp;ids=B&quot;
func queryArray(c *gin.Context) {
    ids := c.QueryArray(&quot;ids&quot;)
    c.JSON(http.StatusOK, gin.H{
        &quot;ids&quot;: ids,
    })
}
</code></pre>
<p>Map 参数的传递方法：</p>
<pre><code class="language-go">//匹配：&quot;127.0.0.1:8080/map?ids[a]=1234&amp;ids[b]=hello&quot;
func queryMap(c *gin.Context) {
    ids := c.QueryMap(&quot;ids&quot;)
    c.JSON(http.StatusOK, gin.H{
        &quot;ids&quot;: ids,
    })
}
</code></pre>
<p>除了上面的参数读取方法，还可以通过 c.ShouldBindQuery 直接将参数解析到变量中：</p>
<pre><code class="language-go">type UserInfo struct {
	Name     string            `form:&quot;name&quot;`
	Age      int               `form:&quot;age&quot;`
	Message  []string          `form:&quot;message&quot;`
	MoreInfo map[string]string `form:&quot;moreinfo&quot;`
}

func queryBind(c *gin.Context) {
	var userInfo UserInfo
	c.BindQuery(&amp;userInfo)
	//gin 1.5 的 BindQuery 似乎不支持 map，单独获取
	userInfo.MoreInfo = c.QueryMap(&quot;moreinfo&quot;)
	c.JSON(http.StatusOK, userInfo)
}

</code></pre>
<h2 id="http-header"><a class="header" href="#http-header">Http Header</a></h2>
<p>用 c.GetHeader() 获取：</p>
<pre><code class="language-go">func header(c *gin.Context) {
	token := c.GetHeader(&quot;TOKEN&quot;)
	c.JSON(http.StatusOK, gin.H{
		&quot;TOKEN&quot;: token,
	})
}
</code></pre>
<p>用 c.BindHeader 直接解析到变量中：</p>
<pre><code class="language-go">type Token struct {
	Token string `header:&quot;token&quot;`
}

func headerBind(c *gin.Context) {
	var token Token
	c.BindHeader(&amp;token)
	c.JSON(http.StatusOK, token)
}
</code></pre>
<h2 id="uri-路径参数"><a class="header" href="#uri-路径参数">URI 路径参数</a></h2>
<p>路径参数需要定义路由时，在路径中进行注明，用 c.Param() 读取：</p>
<pre><code class="language-go">func userName(c *gin.Context) {
    name := c.Param(&quot;name&quot;)
    c.String(http.StatusOK, &quot;Hello %s\n&quot;, name)
}

func userNameAction(c *gin.Context) {
    name := c.Param(&quot;name&quot;)
    action := c.Param(&quot;action&quot;)
    c.String(http.StatusOK, &quot;%s is %s\n&quot;, name, action)
}

func main() {
    router := gin.Default()

    // curl  127.0.0.1:8080/user/xiaoming
    // :name 必须存在
    // 匹配 /user/NAME
    // 不匹配 /user 或者 /user/
    router.GET(&quot;/user/:name&quot;, userName)

    // curl 127.0.0.1:8080/user/xiaoming/run
    // *action 是可选的
    // 匹配 /user/NAME/
    // 匹配 /user/NAME/ACTION
    // 如果 /user/NAME 没有对应的 router，重定向到 /user/NAME/
    router.GET(&quot;/user/:name/*action&quot;, userNameAction)

    // curl -X POST 127.0.0.1:8080/user/xiaoming/run
    // POST 也可以使用路径参数
    router.POST(&quot;/user/:name/*action&quot;, userNameAction)

    router.Run()
}
</code></pre>
<p>用 c.BindUri 直接解析到变量中：</p>
<pre><code class="language-go">type UserInfo struct {
	Name   string `uri:&quot;name&quot;`
	Action string `uri:&quot;action&quot;`
}

func bindURI(c *gin.Context) {
	var userInfo UserInfo
	c.BindUri(&amp;userInfo)
	c.JSON(http.StatusOK, userInfo)
}
</code></pre>
<h2 id="postform-表单数据"><a class="header" href="#postform-表单数据">POST：form 表单数据</a></h2>
<p>post 提交的参数位于 http 请求的 body 中，可以是任意字符，这里以 form 表单数据为例。</p>
<p>form 表单参数用 c.PostXX 读取，格式与 URL query 参数相同，也支持数组和 map。</p>
<pre><code class="language-go">func postForm(c *gin.Context) {
    message := c.PostForm(&quot;message&quot;)
    name := c.DefaultPostForm(&quot;name&quot;, &quot;guest&quot;)
    c.String(http.StatusOK, &quot;%s %s&quot;, name, message)
}

func postFormMap(c *gin.Context) {
    ids := c.PostFormMap(&quot;ids&quot;)
    c.JSON(http.StatusOK, gin.H{
        &quot;ids&quot;: ids,
    })
}

func postFormArray(c *gin.Context) {
    ids := c.PostFormArray(&quot;ids&quot;)
    c.JSON(http.StatusOK, gin.H{
        &quot;ids&quot;: ids,
    })
}

func main() {
    router := gin.Default()

    // curl -XPOST 127.0.0.1:8080/form -d &quot;name=xiaoming&amp;message=welcome!&quot;
    router.POST(&quot;/form&quot;, postForm)

    // curl -XPOST 127.0.0.1:8080/map -d &quot;ids[first]=100&amp;ids[second]=200&quot;
    router.POST(&quot;/map&quot;, postFormMap)

    // curl -XPOST 127.0.0.1:8080/map -d &quot;ids=100&amp;ids=200&quot;
    router.POST(&quot;/arr&quot;, postFormArray)

    router.Run()
}
</code></pre>
<h2 id="postjsonxmlyaml"><a class="header" href="#postjsonxmlyaml">POST：json/xml/yaml</a></h2>
<p>前面例子读取了 form 表单参数，在实际开发中，post 提交的参数还经常是 json、xml 格式。</p>
<p>Gin 内置了 json、xml 数据的解析方法，不需要额外写转换代码。Gin 可以把 form 表单、json、xml 数据直接解析到对应的变量中。</p>
<p>在定义变量的类型时，需要在 struct tag 中指定对应的参数名：</p>
<pre><code class="language-go">type Login struct {
    User     string `form:&quot;user&quot; json:&quot;user&quot; xml:&quot;user&quot; binding:&quot;required&quot;`
    Password string `form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot; `
}
</code></pre>
<p>解析 JSON 数据：</p>
<pre><code class="language-go">func bindXML(c *gin.Context) {
    var login Login
    if err := c.ShouldBindXML(&amp;login); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        return
    }
    c.JSON(http.StatusOK, login)
}
</code></pre>
<p>解析 XML 数据：</p>
<pre><code class="language-go">func bindXML(c *gin.Context) {
    var login Login
    if err := c.ShouldBindXML(&amp;login); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        return
    }
    c.JSON(http.StatusOK, login)
}
</code></pre>
<p>支持 yaml 格式的数据，使用 c.ShouldBindYAML()。</p>
<h2 id="post同时支持多种格式"><a class="header" href="#post同时支持多种格式">POST：同时支持多种格式</a></h2>
<p>c.ShouldBind() 支持多种格式的数据，如果请求方法是 GET，那么它按照 form 规则解析 query 参数，如果请求方法是 POST，根据请求头中的 Content-Type 自动选择对应的方法：</p>
<pre><code class="language-go">func bindALL(c *gin.Context) {
    var login Login
    if err := c.ShouldBind(&amp;login); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        return
    }
    c.JSON(http.StatusOK, login)
}
</code></pre>
<p>Gin 支持的 Content-Type：</p>
<pre><code class="language-go">MIMEJSON              = &quot;application/json&quot;
MIMEHTML              = &quot;text/html&quot;
MIMEXML               = &quot;application/xml&quot;
MIMEXML2              = &quot;text/xml&quot;
MIMEPlain             = &quot;text/plain&quot;
MIMEPOSTForm          = &quot;application/x-www-form-urlencoded&quot;
MIMEMultipartPOSTForm = &quot;multipart/form-data&quot;
MIMEPROTOBUF          = &quot;application/x-protobuf&quot;
MIMEMSGPACK           = &quot;application/x-msgpack&quot;
MIMEMSGPACK2          = &quot;application/msgpack&quot;
MIMEYAML              = &quot;application/x-yaml&quot;
</code></pre>
<h2 id="参考-35"><a class="header" href="#参考-35">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="gin-如何返回响应数据"><a class="header" href="#gin-如何返回响应数据">Gin 如何返回响应数据</a></h1>
<p>Http 访问就是“请求-响应”，Gin 提供了丰富的返回响应数据的方法。</p>
<h2 id="参考-36"><a class="header" href="#参考-36">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua编程速查手册常用操作"><a class="header" href="#lua编程速查手册常用操作">Lua编程速查手册（常用操作)</a></h1>
<p>这里记录一些常用的lua操作，在长时间不编程后，可能会忘记很多基本的操作，这一章节的内容用于帮助快速回忆起这些基本的操作，从手冷快速热身到手热。</p>
<p>以往的笔记对 lua 的安装、代码管理等有比较详细的记录：</p>
<ul>
<li><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2018/10/22/language-lua-study.html">编程语言Lua（一）：入门介绍、学习资料、项目管理与调试方法</a></li>
<li><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2018/10/28/language-lua-02-syntax.html">编程语言Lua（二）：基本语法学习</a></li>
<li><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2018/11/02/language-lua-03-systax-detail.html">编程语言Lua（三）：Lua的语法细节</a></li>
<li><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2018/12/10/lua-programm-performance-tip.html">使用Lua编程时需要注意的一些影响性能的操作</a></li>
</ul>
<p>Lua 官方文档：</p>
<ul>
<li><a href="https://www.lua.org/docs.html">Lua Documentation</a></li>
<li><a href="https://www.lua.org/gems/">Lua Programming Gems</a>中收集了一些Lua编程文章</li>
<li><a href="https://www.lua.org/gems/sample.pdf">Lua Performance Tips</a></li>
</ul>
<h2 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h2>
<p>安装 Lua，可以用下面命令安装：</p>
<pre><code class="language-sh">$ brew install lua        # for mac
$ yum  install -y lua     # for centos
</code></pre>
<p>或者编译安装：</p>
<pre><code class="language-sh">$ curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gz
$ tar zxf lua-5.3.5.tar.gz
$ cd lua-5.3.5
$ make linux test    # for linux
$ make macosx test   # for mac
</code></pre>
<h2 id="lua-代码的运行"><a class="header" href="#lua-代码的运行">lua 代码的运行</a></h2>
<p>在命令行交互式运行：</p>
<pre><code class="language-sh">$ lua
Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio
&gt; print(&quot;hello world!&quot;)
hello world!
&gt;
</code></pre>
<p>运行 lua 代码文件：</p>
<pre><code class="language-lua">#! /usr/bin/env lua
--
-- 01-hello-world.lua
-- Copyright (C) 2018 lijiaocn &lt;lijiaocn@foxmail.com&gt;
--
-- Distributed under terms of the GPL license.

print(&quot;Hello World 1!&quot;)
</code></pre>
<pre><code class="language-sh">$ lua 01-hello-world.lua
Hello World 1!
</code></pre>
<h2 id="参考-37"><a class="header" href="#参考-37">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua的基本数据类型"><a class="header" href="#lua的基本数据类型">Lua的基本数据类型</a></h1>
<p>Lua是动态类型语言，函数<code>type()</code>返回一个变量或者一个值的类型：</p>
<pre><code>$ lua5.1
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&gt; print(type(&quot;hello world&quot;))
string
</code></pre>
<p>Lua的基本类型有：</p>
<pre><code>nil       空类型，表示无效值，变量在被赋值前都是nil，将nil赋给一个全局变量等同将其删除
boolean   布尔类型，值为true/false，只有nil和false为“假”，其它如0和&quot;&quot;都是真，这一点要特别特别注意！
number    数字，值为实数，Lua默认为double，LuaJIT会根据上下文选择用整型或者浮点型存储
string    字符串，支持单引号、双引号和长括号的方式
table     表，关联数组
function  函数
userdata  用来保存应用程序或者C语言写的函数库创建的新类型。
</code></pre>
<h2 id="nil"><a class="header" href="#nil">nil</a></h2>
<p>nil类型需要注意的是： 变量在被赋值前都是nil，将nil赋给一个全局变量等同将其删除。</p>
<h2 id="boolean"><a class="header" href="#boolean">boolean</a></h2>
<p>布尔类型需要注意的是： 只有nil和false为“假”，其它如0和&quot;&quot;都是真。</p>
<h2 id="number"><a class="header" href="#number">number</a></h2>
<p>Lua默认为double，LuaJIT会根据上下文选择整型或者浮点型。</p>
<p>整数和浮点数的类型都是number：</p>
<blockquote>
<p>type(3)    --&gt; number
type(3.5)  --&gt; number
type(3.0)  --&gt; number</p>
</blockquote>
<p>如果非要区分整型和浮点数，可以用math中的type函数：</p>
<blockquote>
<p>math.type(3)     --&gt; integer
math.type(3.0)   --&gt; float</p>
</blockquote>
<h2 id="string"><a class="header" href="#string">string</a></h2>
<p>支持单引号、双引号和长括号的方式。</p>
<p>长括号的形式要特别说明，长括号是分正反的，正长括号就是两个<code>[</code>中间有任意个“=”，一个“=”表示一级，例如：</p>
<pre><code>[[          0级正长括号
[=[         1级正长括号
[===[       3级正长括号
</code></pre>
<p>它们分别和反长括号对应：</p>
<pre><code>]]          0级反长括号
]=]         1级反长括号
]===]       3级反长括号
</code></pre>
<p>一个字符串可以用任意级别的长括号开始，遇到同级别的反长括号时结束，<code>长括号中的所有字符不被转义</code>，包括其它级别的长括号，例如：</p>
<blockquote>
<p>print([==[ string have a [=[ in ]=] ]==])
string have a [=[ in ]=]</p>
</blockquote>
<p>Lua中<code>字符串不能被修改</code>，如果要修改只能在原值的基础上新建一个字符串，也<code>不能通过下标访问字符串中的字符</code>。操作字符串可以用<code>String模块</code>中的方法。</p>
<p>所有的字符串都存放在一个全局的哈希表中，<code>相同的字符串只会存储一份</code>，因此创建多个内容相同的字符串，不会多占用存储空间，字符串比较是O(1)的。</p>
<h2 id="table"><a class="header" href="#table">table</a></h2>
<p>table是Lua唯一支持的数据结构，它是一个<code>关联数组</code>，一种有特殊索引的数组，索引可以是nil以外的任意类型的值。</p>
<p>下面是一个table的定义和使用：</p>
<pre><code class="language-lua">local corp = {
    web = &quot;www.google.com&quot;,   --索引是字符串，key = &quot;web&quot;, value = &quot;www.google.com&quot;
    staff = {&quot;Jack&quot;, &quot;Scott&quot;, &quot;Gary&quot;}, --索引是字符串，值是一个table
    100876,              --相当于 [1] = 100876，索引为数字1，key = 1, value = 100876
    100191,              --相当于 [2] = 100191，索引为数字2
    [10] = 360,          --明确指定数字索引10
    [&quot;city&quot;] = &quot;Beijing&quot; --索引为字符串的另一种书写形式
}

print(corp.web)               --&gt;output:www.google.com
print(corp.staff[1])          --&gt;output:Jack
print(corp[2])                --&gt;output:100191
print(corp[10])               --&gt;output:360
print(corp[&quot;city&quot;])           --&gt;output:&quot;Beijing&quot;
</code></pre>
<p>Lua的table可能是用哈希表实现的，也可能是用数组实现的，或者两者的混合，根据table中的数值决定。</p>
<p>操作table的函数：</p>
<pre><code>table.remove
table.concat
</code></pre>
<h2 id="array"><a class="header" href="#array">array</a></h2>
<p>Lua虽然只有一种数据结构<code>table</code>，但是可以通过为table添加数字索引的方式，实现数组。</p>
<p>一个新数组就是一个空的table，无法指定大小，可以不停的写入：</p>
<pre><code class="language-lua">local a = {}    -- new array
for i = 1, 1000 do
    a[i] = 0 end
end
</code></pre>
<p>通过<code>a[i]</code>的方式读取，如果i超范围，返回nil。</p>
<p>通过<code>#</code>操作符，获得数组的长度：</p>
<pre><code class="language-lua">print(#a) --&gt; 1000
</code></pre>
<h2 id="function"><a class="header" href="#function">function</a></h2>
<p>函数Lua的基本类型，可以存储在变量中。</p>
<pre><code class="language-lua">local function foo()
    print(&quot;in the function&quot;)
    --dosomething()
    local x = 10
    local y = 20
    return x + y
end

local a = foo    --把函数赋给变量

print(a())
</code></pre>
<p><code>有名函数</code>就是将一个匿名函数赋给同名变量，下面的函数定义：</p>
<pre><code class="language-lua">function foo()
end
</code></pre>
<p>等同于：</p>
<pre><code class="language-lua">foo = function ()
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua的关键字和操作符"><a class="header" href="#lua的关键字和操作符">Lua的关键字和操作符</a></h1>
<h2 id="关键字"><a class="header" href="#关键字">关键字</a></h2>
<p>Lua区分大小写，例如and是保留关键字，但是And、AND等不是，可以作为标记符使用。</p>
<pre><code>and       break     do        else      elseif
end       false     for       function  if
in        local     nil       not       or
repeat    return    then      true      until     while
</code></pre>
<h2 id="操作符"><a class="header" href="#操作符">操作符</a></h2>
<pre><code>+     -     *     /     %     ^     #
==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
(     )     {     }     [     ]
;     :     ,     .     ..    ...
</code></pre>
<h2 id="注释符"><a class="header" href="#注释符">注释符</a></h2>
<p>注释用<code>--</code>标记，一直作用到行尾。多行注释，在<code>--</code>后面跟随<code>[[</code>，一直作用到<code>]]</code>，例如：</p>
<pre><code class="language-lua">--[[A multi-line
     long comment
]]
</code></pre>
<p>多行注释通常采用下面的样式：</p>
<pre><code class="language-lua">--[[
    print(1)
    print(2)
    print(3)
--]]
</code></pre>
<h2 id="语句分隔符"><a class="header" href="#语句分隔符">语句分隔符</a></h2>
<p>Lua语句之间可以使用“;”作为分隔符，但分隔符不是必须的，可以没有，另外换行符对lua来说不具备语法上的意义。</p>
<pre><code class="language-lua">a = 1  b = a * 2    -- ugly, but valid
</code></pre>
<h2 id="算术运算符"><a class="header" href="#算术运算符">算术运算符</a></h2>
<p>算术运算符有：</p>
<pre><code>+  -  *  /  ^（指数）  %（取模）
</code></pre>
<p>需要特别注意的是除法运算符<code>/</code>，它的结果是浮点数：</p>
<pre><code class="language-lua">print(5/10)      --结果是0.2，不是0
</code></pre>
<p>Lua5.3引入了新的算数运算符<code>//</code>，取整除法（floor division），确保返回的是一个整数：</p>
<blockquote>
<p>3 // 2        --&gt; 1
3.0 // 2      --&gt; 1.0
6 // 2        --&gt; 3
6.0 // 2.0    --&gt; 3.0
-9 // 2       --&gt; -5
1.5 // 0.5    --&gt; 3.0</p>
</blockquote>
<h2 id="关系运算符"><a class="header" href="#关系运算符">关系运算符</a></h2>
<p>关系运算符有：</p>
<pre><code>&lt;   &gt;  &lt;=  &gt;=  ==  ~=（不等于）
</code></pre>
<p>特别注意，不等于用<code>~=</code>表示。</p>
<p>Lua中的<code>==</code>和<code>~=</code>，比较的是变量绑定对象是否相同，而不是比较绑定的对象的值。</p>
<p>下面两个变量a、b绑定的是两个相同值的对象，a和b是不等的：</p>
<pre><code class="language-lua">local a = { x = 1, y = 0}
local b = { x = 1, y = 0}
if a == b then
  print(&quot;a==b&quot;)
else
  print(&quot;a~=b&quot;)
end

---output:
a~=b
</code></pre>
<h2 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h2>
<p>逻辑运算符包括：</p>
<pre><code>and   or   not
</code></pre>
<p>逻辑运算符<code>and</code>和<code>or</code>的也需要特别注意，它们的结果不是0和1，也不是true和false，而是运算符两边的操作数中的一个：</p>
<pre><code class="language-lua">a and b       -- 如果 a 为 nil，则返回 a，否则返回 b;
a or b        -- 如果 a 为 nil，则返回 b，否则返回 a。
</code></pre>
<p>总结一下就是：对于and和or，返回第一个使表达式的结果确定的操作数。</p>
<p>not的返回结果是true或者false。</p>
<h2 id="字符串拼接"><a class="header" href="#字符串拼接">字符串拼接</a></h2>
<p>字符串拼接运算符是<code>..</code>，如果一个操作数是数字，数字被转换成字符串。</p>
<p>需要特别注意的是<code>..</code>每执行一次，都会创建一个新的字符串。</p>
<p>如果要将多个字符串拼接起来，为了高效，应当把它们写在一个table中，然后用<code>table.concat()</code>方法拼接。</p>
<pre><code class="language-lua">local pieces = {}
for i, elem in ipairs(my_list) do
    pieces[i] = my_process(elem)
end
local res = table.concat(pieces)
</code></pre>
<h2 id="运算符优先级"><a class="header" href="#运算符优先级">运算符优先级</a></h2>
<p>优先级如下，由高到底排序，同一行的优先级相同：</p>
<pre><code>^
not  #   -
*    /   %
+    -
..
&lt; &gt;  &lt;=  &gt;=  ==  ~=
and
or
</code></pre>
<h2 id="冒号语法糖"><a class="header" href="#冒号语法糖">冒号语法糖</a></h2>
<p>模块Account中实现了一个函数withdraw：</p>
<pre><code class="language-lua">Account = {balance = 0}
function Account.withdraw (v)
  Account.balance = Account.balance - v
end
</code></pre>
<p>这个withdraw()函数中操作的是Account.balance，绑死了Account，这个方法只有Account能用。</p>
<p>实现一个能够操作任意调用者中的balance变量的方法，可以用下面的方法：</p>
<pre><code class="language-lua">function Account.withdraw (self, v)
    self.balance = self.balance - v
end
</code></pre>
<p>可以用&quot;:&quot;语法糖进行简化，省去self：</p>
<pre><code class="language-lua">function Account:withdraw (v)
    self.balance = self.balance - v
end
</code></pre>
<p>冒号语法糖自动添加一个self形参，指向当前的调用者。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua的条件语句控制结构"><a class="header" href="#lua的条件语句控制结构">Lua的条件语句控制结构</a></h1>
<p>Lua支持下列控制结构：</p>
<pre><code>if
while
repeat
for
break
return
</code></pre>
<h2 id="if"><a class="header" href="#if">if</a></h2>
<p><code>if-then-end</code>:</p>
<pre><code class="language-lua">x = 10
if x &gt; 0 then
    print(&quot;x is a positive number&quot;)
end
</code></pre>
<p><code>if-then-else-end</code>：</p>
<pre><code class="language-lua">x = 10
if x &gt; 0 then
    print(&quot;x is a positive number&quot;)
else
    print(&quot;x is a non-positive number&quot;)
end
</code></pre>
<p><code>if-then-[elseif-then...]-else-end</code>：</p>
<pre><code class="language-lua">score = 90
if score == 100 then
    print(&quot;Very good!Your score is 100&quot;)
elseif score &gt;= 60 then
    print(&quot;Congratulations, you have passed it,your score greater or equal to 60&quot;)
--此处可以添加多个elseif
else
    print(&quot;Sorry, you do not pass the exam! &quot;)
end
</code></pre>
<h2 id="while"><a class="header" href="#while">while</a></h2>
<p>注意Lua中没有<code>continue</code>语句， 只有<code>break</code>语句可以在循环结构中使用。</p>
<pre><code class="language-lua">x = 1
sum = 0

while x &lt;= 5 do
    sum = sum + x
    x = x + 1
end
print(sum)  --&gt;output 15
</code></pre>
<h2 id="repeat"><a class="header" href="#repeat">repeat</a></h2>
<p>可以在循环结构中使用<code>break</code>：</p>
<pre><code class="language-lua">x = 10
repeat
    print(x)
until false    -- 一直false，死循环
</code></pre>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>for分数值for（numeric for）和范型for（generic for）。</p>
<h3 id="numeric-for"><a class="header" href="#numeric-for">numeric for</a></h3>
<p>数值for，就是设定一个开始数值，按照指定的跨度递增，直到结束值：</p>
<pre><code class="language-lua">for i = 1, 5 do       -- 从1增长到5，默认每次增加1
  print(i)
end

for i = 1, 10, 2 do   -- 从1增长到10，明确设置每次增加2
  print(i)
end
</code></pre>
<p>如果跨度是负数，则递减：</p>
<pre><code class="language-lua">for i = 10, 1, -1 do  -- 从10递减到1，每一次减去1
  print(i)
end
</code></pre>
<h3 id="generic-for"><a class="header" href="#generic-for">generic for</a></h3>
<p>范型for，就是用于迭代器（iterator）：</p>
<pre><code class="language-lua">local a = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
for i, v in ipairs(a) do
  print(&quot;index:&quot;, i, &quot; value:&quot;, v)
end
</code></pre>
<p><code>ipairs()</code>是遍历数组的迭代器函数，i是索引值，v是索引对应的数值。</p>
<p>for支持的迭代器还有：</p>
<pre><code>io.lines         迭代每行
paris            迭代table
ipairs           迭代数组元素
string.gmatch    迭代字符串中的单词
</code></pre>
<p><a href="https://www.lua.org/manual/5.3/manual.html#pdf-ipairs">ipairs</a>是直接迭代，而<a href="https://www.lua.org/manual/5.3/manual.html#pdf-pairs">pairs</a>是调用元方法<code>__pairs</code>，如果没有设置该原方法，则用next函数取下一个数值。</p>
<blockquote>
<p>在 LuaJIT 2.1 中，ipairs() 函数是可以被 JIT 编译执行的，而 pairs() 则只能被解释执行。</p>
</blockquote>
<h2 id="break"><a class="header" href="#break">break</a></h2>
<p>break用于终止循环。</p>
<h2 id="return"><a class="header" href="#return">return</a></h2>
<p>return用于从函数中返回结果，在函数中使用return的时候，需要用<code>do-end</code>：</p>
<pre><code class="language-lua">local function foo()
    print(&quot;before&quot;)
    do return end
    print(&quot;after&quot;)  -- 这一行语句永远不会执行到
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua的函数定义传参注意事项和返回值"><a class="header" href="#lua的函数定义传参注意事项和返回值">Lua的函数定义，传参注意事项和返回值</a></h1>
<h2 id="常用内置函数"><a class="header" href="#常用内置函数">常用内置函数</a></h2>
<p><a href="https://www.lua.org/manual/5.3/manual.html#pdf-table.insert">table.insert</a>： 将 value 插入 list[pos]，同时将后面的数值向后移动一位，如果没有指定 pos 添加到 list 尾部，post 默认为 #list+1。</p>
<pre><code class="language-lua">table.insert (list, [pos,] value)
</code></pre>
<p><a href="https://www.lua.org/manual/5.3/manual.html#pdf-ipairs">ipairs (t)</a>：迭代器，遍历数组：</p>
<pre><code class="language-lua">for i,v in ipairs(t) do body end  -- ipaires(t) 返回  (1,t[1]), (2,t[2]), ...,
</code></pre>
<p><a href="https://www.lua.org/manual/5.3/manual.html#pdf-next">next</a>：返回 table 中指定位置的元素。</p>
<pre><code class="language-sh">next (table [, index])
</code></pre>
<h2 id="声明定义"><a class="header" href="#声明定义">声明定义</a></h2>
<p>函数用关键字<code>function</code>定义，默认为全局的。</p>
<p>全局函数保存在全局变量中，会增加性能损耗，应当尽量使用局部函数，前面加上local：</p>
<pre><code class="language-lua">local function function_name (arc)
  -- body
end
</code></pre>
<p>函数要定义后才能使用，定义代码在前面的。</p>
<p>可以函数定义时，直接设置为table的成员，如下：</p>
<pre><code class="language-lua">function foo.bar(a, b, c)
    -- body ...
end
</code></pre>
<p>等同于：</p>
<pre><code class="language-lua">foo.bar = function (a, b, c)
    print(a, b, c)
end
</code></pre>
<h2 id="参数传递"><a class="header" href="#参数传递">参数传递</a></h2>
<p>非table类型的参数是<code>按值传递</code>的，table类型的参数传递的是引用。</p>
<p>调用函数时，如果传入的参数超过函数定义中的形参个数，多出的实参被忽略，如果传入的参数少于定义中的形参个数，没有被实参初始化的形参默认为nil。</p>
<p>变长参数用<code>...</code>表示，访问的时候也使用<code>...</code>：</p>
<pre><code class="language-lua">local function func( ... )                -- 形参为 ... ,表示函数采用变长参数

   local temp = {...}                     -- 访问的时候也要使用 ...
   local ans = table.concat(temp, &quot; &quot;)    -- 使用 table.concat 库函数对数
                                          -- 组内容使用 &quot; &quot; 拼接成字符串。
   print(ans)
end
</code></pre>
<p>table类型的参数按引用传递，可以在函数修改它的值：</p>
<pre><code class="language-lua">local function change(arg)             --change函数，改变长方形的长和宽，使其各增长一倍
  arg.width = arg.width * 2      --表arg不是表rectangle的拷贝，他们是同一个表
  arg.height = arg.height * 2
end                              -- 没有return语句了

local rectangle = { width = 20, height = 15 }

change(rectangle)
</code></pre>
<h2 id="函数返回值"><a class="header" href="#函数返回值">函数返回值</a></h2>
<p>函数是多值返回的：</p>
<pre><code class="language-lua">local function swap(a, b)   -- 定义函数 swap，实现两个变量交换值
   return b, a              -- 按相反顺序返回变量的值
end

local x = 1
local y = 20
x, y = swap(x, y)    
</code></pre>
<p>接收返回值的变量数量少于函数返回的值的数量时，多出的返回值被忽略，大于的时候，多出的接收变量被设置为nil。</p>
<p>在多变量赋值的列表表达式中，如果多值返回的函数不在最后一个，那么只有它的第一个返回值会被接收：</p>
<pre><code class="language-lua">local function init()       -- init 函数 返回两个值 1 和 &quot;lua&quot;
    return 1, &quot;lua&quot;
end

local x, y, z = init(), 2   -- init 函数的位置不在最后，此时只返回 1
print(x, y, z)              -- output  1  2  nil

local a, b, c = 2, init()   -- init 函数的位置在最后，此时返回 1 和 &quot;lua&quot;
print(a, b, c)              -- output  2  1  lua
</code></pre>
<p>注意函数的传入参数也是列表表达式，遵循同样的规则，如下：</p>
<pre><code class="language-lua">local function init()
    return 1, &quot;lua&quot;
end

print(init(), 2)   --&gt;output  1  2
print(2, init())   --&gt;output  2  1  lua
</code></pre>
<p>列表表达式中，如果要确保函数只返回一个值，用括号将函数包裹：</p>
<pre><code class="language-lua">local function init()
    return 1, &quot;lua&quot;
end

print((init()), 2)   --&gt;output  1  2
print(2, (init()))   --&gt;output  2  1
</code></pre>
<h2 id="函数回调"><a class="header" href="#函数回调">函数回调</a></h2>
<p>函数回调时，用unpack处理传入的变长参数：</p>
<pre><code class="language-lua">local function run(x, y)
    print('run', x, y)
end

local function attack(targetId)
    print('targetId', targetId)
end

local function do_action(method, ...)
    local args = {...} or {}
    method(unpack(args, 1, table.maxn(args)))
end

do_action(run, 1, 2)         -- output: run 1 2
do_action(attack, 1111)      -- output: targetId    1111
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua的代码组织方式模块"><a class="header" href="#lua的代码组织方式模块">Lua的代码组织方式：模块</a></h1>
<p>模块在[编程语言Lua（一）：入门介绍、学习资料、项目管理与调试方法-Lua Module][2]中有介绍。</p>
<p>Lua创建一个模块最简单的方法是：创建一个table，并将所有需要导出的函数放入其中，返回这个table。</p>
<p>例如模块my对应的my.lua文件内容如下：</p>
<pre><code class="language-lua">local foo={}

local function getname()
    return &quot;Lucy&quot;
end

function foo.greeting()
    print(&quot;hello &quot; .. getname())
end

return foo
</code></pre>
<p>模块my的greeting函数可以被调用：</p>
<pre><code class="language-lua">local fp = require(&quot;my&quot;)
fp.greeting()     --&gt;output: hello Lucy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua的元表使用"><a class="header" href="#lua的元表使用">Lua的元表使用</a></h1>
<p>Lua5.1中，元表相当于重新定义操作符，类似于C++中的操作符重载。</p>
<h2 id="元方法"><a class="header" href="#元方法">元方法</a></h2>
<p>元表是一组<code>元方法</code>组成的table，一些函数或模块的实现中调用的是元方法，可以实现不同的元方法实现不同的行为，而不更改调用这些元方法的函数或者模块的实现以及使用方式。</p>
<p>元方法有点类似于“接口”，lua支持以下元方法：</p>
<pre><code>&quot;__add&quot;         + 操作
&quot;__sub&quot;         - 操作 其行为类似于 &quot;add&quot; 操作
&quot;__mul&quot;         * 操作 其行为类似于 &quot;add&quot; 操作
&quot;__div&quot;         / 操作 其行为类似于 &quot;add&quot; 操作
&quot;__mod&quot;         % 操作 其行为类似于 &quot;add&quot; 操作
&quot;__pow&quot;         ^ （幂）操作 其行为类似于 &quot;add&quot; 操作
&quot;__unm&quot;         一元 - 操作
&quot;__concat&quot;      .. （字符串连接）操作
&quot;__len&quot;         # 操作
&quot;__eq&quot;          == 操作 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作 仅在两个对象类型相同且有对应操作相同的元方法时才起效
&quot;__lt&quot;          &lt; 操作
&quot;__le&quot;          &lt;= 操作
&quot;__index&quot;       取下标操作用于访问 table[key]
&quot;__newindex&quot;    赋值给指定下标 table[key] = value
&quot;__tostring&quot;    转换成字符串
&quot;__call&quot;        当 Lua 调用一个值时调用
&quot;__mode&quot;        用于弱表(week table)
&quot;__metatable&quot;   用于保护metatable不被访问
</code></pre>
<p><code>元方法</code>中第一个参数是<code>self</code>，下面是包含__index元方法的元表：</p>
<pre><code class="language-lua">{__index = function(self, key)            --元表中重新实现了__index
    if key == &quot;key2&quot; then
      return &quot;metatablevalue&quot;
    end
  end
}
</code></pre>
<h2 id="设置元表"><a class="header" href="#设置元表">设置元表</a></h2>
<p>元表要绑定到table变量，用函数<code>setmetatable(table, metatable)</code>设置，以设置__index元方法为例：</p>
<pre><code class="language-lua">mytable = setmetatable({key1 = &quot;value1&quot;},   --原始表
  {__index = function(self, key)            --元表中重新实现了__index
    if key == &quot;key2&quot; then
      return &quot;metatablevalue&quot;
    end
  end
})
</code></pre>
<p>print(mytable.key1,mytable.key2)            --&gt; output：value1 metatablevalue</p>
<p><code>__index</code>元方法有点特殊，它可以是一个函数，也可以是一个table：</p>
<pre><code class="language-lua">t = setmetatable({[1] = &quot;hello&quot;}, {__index = {[2] = &quot;world&quot;}})
print(t[1], t[2])   --&gt;hello world
</code></pre>
<p>上面名为t的table中,t[2]是存放在元方法<code>__index</code>中的，当在t中找不到对应的key时，到<code>__index</code>中查找。
这个特性在面向对象编程用到。</p>
<p>函数<code>getmetatable(table)</code>可以读取table的元表。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua的面向对象设计方法"><a class="header" href="#lua的面向对象设计方法">Lua的面向对象设计方法</a></h1>
<p>Lua的面向对象设计方法很不直观，Lua中的类就是模块，借助元表使模块具有了类的属性，能够实例化。</p>
<h2 id="类的实现"><a class="header" href="#类的实现">类的实现</a></h2>
<p>Lua中类的实现方法，一个模块文件account.lua内容如下：</p>
<pre><code class="language-lua">local _M = {}

local mt = { __index = _M }

function _M.deposit (self, v)
    self.balance = self.balance + v
end

function _M.withdraw (self, v)
    if self.balance &gt; v then
        self.balance = self.balance - v
    else
        error(&quot;insufficient funds&quot;)
    end
end

function _M.new (self, balance)
    balance = balance or 0
    return setmetatable({balance = balance}, mt)
end

return _M
</code></pre>
<p>类的方法在<code>_M</code>表中，而_M表又被赋给了元方法<code>__index</code>，包含__index方法的元表mt被绑定到类实例化时创建的table变量，绑定了元表mt的table变量就是类的对象。</p>
<p>模块account.lua返回的是<code>_M</code>，调用_M中的new方法的时候，模块中的元表mt绑定到到一个新的table变量，传入的参数也被写入了这个新的table变量中（{balance = balance}），返回的table就可以调用mt中的方法和传入的参数。</p>
<pre><code class="language-lua">local account = require(&quot;account&quot;)

local a = account:new()
a:deposit(100)

local b = account:new()
b:deposit(50)

print(a.balance)  --&gt; output: 100
print(b.balance)  --&gt; output: 50
</code></pre>
<p>总结一下，在Lua中类的实现方法：</p>
<pre><code>1. 创建一个模块
2. 在模块中创建一个元表，__index元方法就是模块本身
3. 在模块中创建一个new()函数，返回绑定了模块中的元表的table类型的变量。
</code></pre>
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<p>继承的实现就更麻烦了....</p>
<p>实现一个父类，就是一个普通的类，实现了方法<code>upper()</code>：</p>
<pre><code class="language-lua">-- 父类 s_base.lua
local _M = {}

local mt = { __index = _M }

function _M.upper (s)
    return string.upper(s)
end

return _M
</code></pre>
<p>子类的实现，子类引用父类所在的模块，将父类作为子类__index元方法，子类只实现了方法<code>lower()</code>：</p>
<pre><code class="language-lua">--子类 s_more.lua，引入了父类对应的模块
local s_base = require(&quot;s_base&quot;)

local _M = {}
_M = setmetatable(_M, { __index = s_base })


function _M.lower (s)
    return string.lower(s)
end

return _M
</code></pre>
<p>子类的对象既能使用子类中的<code>lower()</code>，也能使用父类中的<code>upper()</code>。</p>
<pre><code class="language-lua">local s_more = require(&quot;s_more&quot;)

print(s_more.upper(&quot;Hello&quot;))   -- output: HELLO
print(s_more.lower(&quot;Hello&quot;))   -- output: hello
</code></pre>
<h2 id="私有成员"><a class="header" href="#私有成员">私有成员</a></h2>
<p>私有成员的实现非常trick，下面的例子中实现了私有成员balance：</p>
<pre><code class="language-lua">function newAccount (initialBalance)
    local self = {balance = initialBalance}
    local withdraw = function (v)
        self.balance = self.balance - v
    end
    local deposit = function (v)
        self.balance = self.balance + v
    end
    local getBalance = function () return self.balance end
    return {
        withdraw = withdraw,
        deposit = deposit,
        getBalance = getBalance
    }
end

a = newAccount(100)
a.deposit(100)
print(a.getBalance()) --&gt; 200
print(a.balance)      --&gt; nil
</code></pre>
<p>newAccount()返回的table中只有<code>withdraw</code>、<code>deposit</code>和<code>getBalance</code>，这三个方法都操作同一个隐藏的table，这个隐藏的table中的成员就是私有成员。感觉很不直观，但是似乎揭示了面向对象的本质...</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua的标准输出"><a class="header" href="#lua的标准输出">Lua的标准输出</a></h1>
<p>在写代码的过程中，特别是开始学习一门语言的时候，最常用的功能就是“标准输出”：将变量的数值或者类型等，打印到屏幕上或者日志中，看一下是否符合预期。</p>
<p>下面的使用函数大多数都在第一次出现的时候，设置了超链接，连接到 <a href="https://www.lua.org/manual/5.3/">Lua5.3 Reference Manual</a>，如果你使用的Lua版本是5.1，可以到 <a href="https://www.lua.org/manual/5.1/">Lua 5.1 Reference Manual</a> 中查找这些函数的说明。</p>
<h2 id="直接输出"><a class="header" href="#直接输出">直接输出</a></h2>
<p><a href="https://www.lua.org/manual/5.3/manual.html#pdf-print">print(···)</a> 函数是最简单的标准输出函数，它将所有出入参数打印出来，参数可以是任意类型，print函数用 <a href="https://www.lua.org/manual/5.3/manual.html#pdf-tostring">tostring</a> 函数将输入参数转换成字符串。</p>
<blockquote>
<p>需要注意的是print函数不支持格式化输出。</p>
</blockquote>
<p>下面这段代码展示了Lua中的不同类型的变量，用print输出是的效果：</p>
<pre><code class="language-lua">local number=0.2
local string=&quot;this is a string&quot;
local table = {first=&quot;value1&quot;,second=&quot;value2&quot;}
local array = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}

print(&quot;parameter is nil(&quot;, type(nil),&quot;)&quot;,nil)
print(&quot;parameter is boolen(&quot;, type(true),&quot;)&quot;,true)
print(&quot;parameter is number(&quot;, type(number),&quot;)&quot;, number)
print(&quot;parameter is string(&quot;, type(string),&quot;)&quot;, string)
print(&quot;parameter is function(&quot;, type(print),&quot;)&quot;,print)
print(&quot;parameter is userdata(&quot;, type(io.stdin),&quot;)&quot;, io.stdin)
print(&quot;parameter is table(&quot;, type(table),&quot;)&quot;, table)
print(&quot;parameter is array(&quot;, type(array),&quot;)&quot;, array)
</code></pre>
<p>输出如下：</p>
<pre><code class="language-sh">parameter is nil(	nil	)	nil
parameter is boolen(	boolean	)	true
parameter is number(	number	)	0.2
parameter is string(	string	)	this is a string
parameter is table(	table	)	table: 0x7f828ec08860
parameter is array(	table	)	table: 0x7f828ec08930
parameter is function(	function	)	function: 0x7f828ec03e70
parameter is userdata(	userdata	)	file (0x7fffaa221110)
</code></pre>
<p>array是一种特殊的table，它们的区别在数据结构章节讲解，需要注意的是<code>table</code>、<code>function</code>和<code>userdata</code>类型，输出的都是地址。</p>
<h2 id="格式化输出"><a class="header" href="#格式化输出">格式化输出</a></h2>
<p><a href="https://www.lua.org/manual/5.3/manual.html#pdf-string.format">string.format</a>函数，与ISO C的sprintf函数的用法基本相同，但是不支持修饰符<code>*</code>、<code>h</code>、 <code>L</code>、 <code>l</code>、 <code>n</code>、 <code>p</code>，增加了一个新的修饰符<code>q</code>。</p>
<p><code>q</code>修饰符表示为字符串中字符添加转义字符，转换成可以被lua安全读取的样式：</p>
<pre><code class="language-lua">print(&quot;-- format output&quot;)
v = string.format('%q', 'a string with &quot;quotes&quot; and \n new line')
print(v)
</code></pre>
<p>执行结果如下：</p>
<pre><code>-- format output
&quot;a string with \&quot;quotes\&quot; and \
 new line&quot;
</code></pre>
<h2 id="table的输出"><a class="header" href="#table的输出">table的输出</a></h2>
<p>对于table类型，我们更希望看到的是它里面存放的值，而不是它本身的地址。在Lua中输出table的内容比较麻烦，需要用 <a href="https://www.lua.org/manual/5.3/manual.html#pdf-pairs">pairs</a> 函数遍历。</p>
<p><code>pairs(t)</code>函数调用传入参数的名为<code>__pairs</code>的元方法遍历table中的成员，pairs可以遍历所有类型的table，另一个遍历函数 <a href="https://www.lua.org/manual/5.3/manual.html#pdf-ipairs">ipairs</a> 只能遍历数组类型的table。</p>
<p>用pairs和ipairs遍历table：</p>
<pre><code class="language-lua">local table = {first=&quot;value1&quot;,second=&quot;value2&quot;}

print(&quot;--- iterate table by pairs  &quot;)
for i, v in pairs(table) do
    print(i ,v)
end

print(&quot;--- iterate table by ipairs  &quot;)
for i, v in ipairs(table) do
    print(i ,v)
end
</code></pre>
<p>结果如下，ipairs没有遍历输出：</p>
<pre><code>--- iterate table by pairs
second	value2
first	value1
--- iterate table by ipairs
</code></pre>
<p>用pairs和ipairs遍历array类型的table：</p>
<pre><code class="language-lua">	local array = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}
	
	print(&quot;--- iterate array by pairs &quot;)
	for i, v in pairs(array) do
	    print(i ,v)
	end
	
	print(&quot;--- iterate array by ipairs &quot;)
	for i, v in ipairs(array) do
	    print(i ,v)
	end
</code></pre>
<p>结果如下，输出相同：</p>
<pre><code>--- iterate array by pairs 
1	a
2	b
3	c
--- iterate array by ipairs 
1	a
2	b
3	c
</code></pre>
<p>ipairs事实是在用从1开始的下标，取出array类型table中的成员。</p>
<h2 id="转换成json字符串输出"><a class="header" href="#转换成json字符串输出">转换成json字符串输出</a></h2>
<p>lua有很多个<a href="http://lua-users.org/wiki/JsonModules">json模块</a>，可以考虑将table等类型的变量转换成json字符串后输出。</p>
<p><a href="http://lua-users.org/wiki/JsonModules">json模块</a>中的多个json模块，以及用luarocks命令找到的多个json模块，孰优孰略，我不能判定，</p>
<pre><code class="language-bash">$ luarocks search json
json - Search results for Lua 5.1:
==================================

Rockspecs and source rocks:
---------------------------

dkjson
   2.5-2 (rockspec) - https://luarocks.org

...(省略)...
</code></pre>
<p>下面只演示&quot;luajson&quot;的用，安装方法如下：</p>
<pre><code class="language-bash">$ luarocks install luajson
Installing https://luarocks.org/luajson-1.3.4-1.src.rock
...(省略)...
</code></pre>
<p>使用方法如下：</p>
<pre><code class="language-lua">local json = require &quot;json&quot;

local table={first=&quot;value1&quot;, second=&quot;value2&quot;}
v = json.encode(table)
print(v)

local array={&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,1,2,3}
v = json.encode(array)
print(v)
</code></pre>
<p>执行结果如下：</p>
<pre><code class="language-json">{&quot;second&quot;:&quot;value2&quot;,&quot;first&quot;:&quot;value1&quot;}
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,1,2,3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua的字符串操作"><a class="header" href="#lua的字符串操作">Lua的字符串操作</a></h1>
<p>操作字符串，大概是比“标准输出”更常用的操作，朴素地讲，写代码就是在处理数字和字符串。</p>
<p>Lua有一个名为<code>string</code>的标准库：<a href="https://www.lua.org/manual/5.3/manual.html#6.4" title="Lua 5.3: String Manipulation">String Manipulation</a>。</p>
<p>在OpenResty中，除了可以使用Lua的标准库，还可以使用<a href="https://github.com/openresty/lua-nginx-module#nginx-api-for-lua">Nginx API for Lua</a>中的<code>ngx.re.match</code>、<code>ngx.re.find</code>、<code>ngx.re.gmatch</code>、<code>ngx.re.sub</code>和<code>ngx.re.gsub</code>。</p>
<h2 id="lua的正则表达式语法"><a class="header" href="#lua的正则表达式语法">Lua的正则表达式语法</a></h2>
<p>正则表达式不是一种标准的表示方法，不同语言、不同工具的正则表达式语法可能有差异。</p>
<p>Lua的<a href="https://www.lua.org/manual/5.3/manual.html#6.4" title="Lua 5.3: String Manipulation">string标准库</a>使用的正则表达式的语法在<a href="https://www.lua.org/manual/5.3/manual.html#6.4.1" title="Lua 5.3: Patterns">6.4.1 Patterns</a>中有详细说明。</p>
<p>Lua的正则表达式支持以下字符集合（Character Class）：</p>
<pre><code>^$()%.[]*+-?   这些字符以外的字符匹配的都是字符自身
.              匹配所有字符
%a             匹配所有字母
%c             匹配所有控制字符
%d             匹配所有数字
%g             匹配空白字符以外的所有可打印字符
%l             匹配所有的小写字母
%p             匹配所有的标点符号
%s             匹配所有的空白字符
%u             匹配所有的大写字母
%w             匹配所欲的字母和数字
%x             匹配所有的十六进制数字
%x             如果x不是字母和数字，那么匹配x本身，可以用这种方式匹配具有特殊含义的字符
[set]          匹配set中出现过的字符，set中可以前面的字符匹配，例如%a等        
[^set]         匹配set以外的字符，[set]字符集合的补集
</code></pre>
<p>对于用<code>%小写字母</code>表示的字符集合，对应的<code>%大写字母</code>是对应字符集合的补集。</p>
<p>Lua的正则表达式支持下面的模式单位（Pattern Item）：</p>
<pre><code>*              前面的字符出现0次以上，最长匹配 
+              前面的字符出现1次以上，最长匹配
-              前面的字符出现0次以上，最短匹配
?              前面的字符出现1次
%n             n为1-9的数字，分别表示第n个捕获的内容
%bxy           x,y为不同的字符，匹配以x开头以y结尾的字符串，x和y是配对出现的，比如%b()
%f[set]        匹配set中的字符第一次出现的地方
</code></pre>
<p>一个或多个模式单位组合成模式（Pattern），用<code>^</code>表示目标字符串的开始位置，用<code>$</code>表示目标字符串的结束位置。</p>
<p>正则表达式中可以嵌套正则，嵌套的正则位于<code>()</code>中，被嵌套的正则匹配的内容可以被捕获(Captures)，可以用%n提取第n个<code>(</code>对应的嵌套正则表达式匹配的内容。</p>
<p>例如<code>(a*(.)%w(%s*))</code>，%1是<code>a*(.)%w(%s*)</code>匹配的内容，%2是<code>(.)</code>匹配的内容，%3是<code>(%s*)</code>匹配的内容。</p>
<h2 id="字符串正则匹配"><a class="header" href="#字符串正则匹配">字符串正则匹配</a></h2>
<p><a href="https://www.lua.org/manual/5.3/manual.html#pdf-string.gmatch" title="Lua 5.3: string.gmatch">string.gmatch</a>用来对字符串做全局匹配，会对匹配后剩余的字符串继续匹配，直到字符串结束，以迭代器的方式返回每次匹配中捕获的字符串，如果正则表达式中没有捕获，返回整个正则表达式匹配的内容。</p>
<p>下面的代码，正则中没有有嵌套的正则：</p>
<pre><code class="language-lua">print(&quot;-- single capature&quot;)
s = &quot;hello world from Lua&quot;
for w in string.gmatch(s, &quot;%a+&quot;) do
    print(w)
end
</code></pre>
<p>执行结果如下：</p>
<pre><code>-- single capature
hello
world
from
Lua
</code></pre>
<p>正则表达式中有嵌套的正则，迭代器每次返回捕获的字符串：</p>
<pre><code class="language-lua">print(&quot;-- multi capature&quot;)
s = &quot;from=world, to=Lua, abc=1&quot;
for k, v in string.gmatch(s, &quot;(%w+)=(%w+)&quot;) do
    print(k,v)
end
</code></pre>
<p>执行结果如下：</p>
<pre><code>-- multi capature
from	world
to	Lua
abc	1
</code></pre>
<p>与<a href="https://www.lua.org/manual/5.3/manual.html#pdf-string.gmatch" title="Lua 5.3: string.gmatch">string.gmatch</a>相对的是<a href="https://www.lua.org/manual/5.3/manual.html#pdf-string.match" title="Lua 5.3: string.match">string.match</a>，<code>string.match (s, pattern [, init])</code>只匹配一次，不对剩余的字符串继续匹配，可以通过第三个参数指定开始查找匹配的位置。</p>
<pre><code class="language-lua">print(&quot;-- match at pos 5&quot;)
s= &quot;123456789&quot;
v=string.match(s,&quot;%d*&quot;, 5)
print(v)
</code></pre>
<p>执行结果如下：</p>
<pre><code>-- match at pos 5
56789
</code></pre>
<h2 id="字符串正则替换"><a class="header" href="#字符串正则替换">字符串正则替换</a></h2>
<p><a href="https://www.lua.org/manual/5.3/manual.html#pdf-string.gsub" title="Lua 5.3: string.gsub">string.gsub</a>，<code>string.gsub (s, pattern, repl [, n])</code>，将s中全部或者前n个匹配了pattern的字符串用repl替换，并作为一个新的字符串返回。</p>
<p>repl可以是字符串，字符串中可以使用<code>%n</code>指代捕获的内容，<code>%0</code>表示完整匹配，<code>%%</code>将%转义成普通字符。</p>
<p>repl可以是table，这时候替换的内容，是以捕获的字符串为key，从repl中读取出来的内容。</p>
<p>repl可以是function，这时候替换的内容，是以捕获的字符串为参数时，repl指代的函数的返回结果。</p>
<p>repl是table或者function时，如果得到的替换内容是false或nil，则不替换。</p>
<p>repl是字符串时：</p>
<pre><code class="language-lua">print(&quot;-- repeat each word&quot;)
x = string.gsub(&quot;hello world&quot;, &quot;(%w+)&quot;, &quot;%1 , %1 |&quot;)
print(x)

print(&quot;-- repeat first word&quot;)
x = string.gsub(&quot;hello world&quot;, &quot;(%w+)&quot;, &quot;%1 , %1 |&quot;,1 )
print(x)
</code></pre>
<p>输出结果如下：</p>
<pre><code>-- repeat each word
hello , hello | world , world |
-- repeat first word
hello , hello | world
</code></pre>
<p>reple是table时：</p>
<pre><code class="language-lua">	print(&quot;-- repel is table&quot;)
	local t = {name=&quot;lua&quot;, version=&quot;5.3&quot;}
	x = string.gsub(&quot;$name-$version.tar.gz&quot;, &quot;%$(%w+)&quot;, t)
	print(x)
</code></pre>
<p>输出结果如下：</p>
<pre><code>-- reple is table
lua-5.3.tar.gz
</code></pre>
<p>repl是函数时：</p>
<pre><code class="language-lua">print(&quot;-- repel is a function&quot;)
x = string.gsub(&quot;home = $HOME, user = $USER&quot;, &quot;%$(%w+)&quot;, os.getenv)
print(x)
</code></pre>
<p>输出结果如下：</p>
<pre><code>-- repel is a function
home = /Users/lijiao, user = lijiao
</code></pre>
<p>需要注意的是<a href="https://www.lua.org/manual/5.3/manual.html#pdf-string.sub" title="Lua 5.3: string.sub">string.sub</a>和这里的<a href="https://www.lua.org/manual/5.3/manual.html#pdf-string.gsub" title="Lua 5.3: string.gsub">string.gsub</a>不是相对的关系，<code>string.sub (s, i [, j])</code>是取出s的第i个到第j个字符。</p>
<h2 id="取字符串的子串"><a class="header" href="#取字符串的子串">取字符串的子串</a></h2>
<p><a href="https://www.lua.org/manual/5.3/manual.html#pdf-string.sub" title="Lua 5.3: string.sub">string.sub</a>，<code>string.sub (s, i [, j])</code>取出字符串s的第i到j个字符，下标是从1开始计数的，j默认是-1 表示字符串的完整长度，i如果是负数，表示字符串的后|i|个字符：</p>
<pre><code class="language-lua">print(&quot;-- sub string 0-3, 1-3, 2-3&quot;)
s=&quot;123456789&quot;
v=string.sub(s,0,3)
print(v)
v=string.sub(s,1,3)
print(v)
v=string.sub(s,2,3)
print(v)
v=string.sub(s,2,-1)
print(v)
v=string.sub(s,-2)
print(v)
</code></pre>
<p>执行结果如下：</p>
<pre><code>-- sub string 0-3, 1-3, 2-3
123
123
23
23456789
89
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="lua编程时性能方面的注意事项"><a class="header" href="#lua编程时性能方面的注意事项">Lua编程时性能方面的注意事项</a></h1>
<p><a href="https://www.lua.org/gems/sample.pdf">Lua Performance Tips</a>给出了很重要的性能优化建议，这些建议都是用Lua编程时需要注意的事项。</p>
<ul>
<li><a href="lua/chapter1/03-lua-performance-local-var.html">局部变量比全局变量快30%</a></li>
<li><a href="lua/chapter1/03-lua-performance-load-dynamic.html">动态加载代码非常慢</a></li>
<li><a href="lua/chapter1/03-lua-performance-table-space.html">table的自动扩容代价很高</a></li>
<li><a href="lua/chapter1/03-lua-performance-table-space-1.html">清理操作不会触发rehash</a></li>
<li><a href="lua/chapter1/03-lua-performance-string.html">慎用字符串拼接</a></li>
<li><a href="lua/chapter1/03-lua-performance-less-var.html">尽量少创建变量</a></li>
<li><a href="lua/chapter1/03-lua-performance-cache-result.html">缓存运算结果</a></li>
<li><a href="lua/chapter1/03-lua-performance-garbage-collect.html">主动控制垃圾回收</a></li>
</ul>
<h2 id="参考-38"><a class="header" href="#参考-38">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com/nginx/">Nginx、OpenResty、Lua与Kong</a></li>
<li><a href="https://stackoverflow.com/questions/154672/what-can-i-do-to-increase-the-performance-of-a-lua-program">What can I do to increase the performance of a Lua program?</a></li>
<li><a href="http://www.lua.org/gems/sample.pdf">Lua Performance Tips</a></li>
<li><a href="http://lua-users.org/wiki/OptimisationTips">Lua Optimisation Tips</a></li>
<li><a href="https://www.cnblogs.com/zwywilliam/p/5992737.html">luajit官方性能优化指南和注解</a></li>
<li><a href="http://wiki.luajit.org/Numerical-Computing-Performance-Guide">Numerical Computing Performance Guide</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lua的局部变量比全局变量快30"><a class="header" href="#lua的局部变量比全局变量快30">Lua的局部变量比全局变量快30%</a></h1>
<p>Lua代码是被解释执行的，Lua代码被解释成Lua虚拟机的指令，交付给Lua虚拟机执行。</p>
<p>Lua虚拟机不是对常见的物理计算机的模拟，而是完全定义了自己的规则。Lua虚拟机中虚拟了寄存器，但是它的寄存器是和函数绑定的一起的，并且每个函数可以使用高达250个虚拟寄存器（使用栈的方式实现的）。</p>
<p>操作局部变量时，使用的指令非常少，例如<code>a=a+b</code>只需要一条指令<code>ADD 0 0 1</code>。</p>
<p>如果<code>a</code>和<code>b</code>是全局变量，则需要四条指令：</p>
<pre><code>GETGLOBAL       0 0     ; a
GETGLOBAL       1 1     ; b
ADD             0 0 1
SETGLOBAL       0 0     ; a
</code></pre>
<p>下面两段代码var_global.lua和var_local.lua性能相差30%：</p>
<p>var_global.lua：</p>
<pre><code class="language-lua">for i = 1, 1000000 do
local x = math.sin(i)
end
</code></pre>
<p>var_local.lua：</p>
<pre><code class="language-lua">local sin = math.sin
for i = 1, 1000000 do
local x = sin(i)
end
</code></pre>
<p>运行耗时占比：</p>
<pre><code class="language-bash">➜  03-performance git:(master) ✗ time lua5.1 ./var_global.lua
lua5.1 ./var_global.lua  8.02s user 0.01s system 99% cpu 8.036 total

➜  03-performance git:(master) ✗ time lua5.1 ./var_local.lua
lua5.1 ./var_local.lua  6.01s user 0.01s system 99% cpu 6.026 total
</code></pre>
<p>因此在阅读使用lua代码时，经常看到下面的做法，将其它包中的变量赋值给本地变量：</p>
<pre><code class="language-lua">local sin = math.sin
function foo (x)
  for i = 1, 1000000 do
    x = x + sin(i)
  end
  return x
end

print(foo(10))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在lua程序中动态加载代码非常慢"><a class="header" href="#在lua程序中动态加载代码非常慢">在Lua程序中动态加载代码非常慢</a></h1>
<p>Lua中可以用<a href="http://www.lua.org/manual/5.1/manual.html#pdf-load">load</a>、<a href="http://www.lua.org/manual/5.1/manual.html#pdf-loadfile">load</a>和<a href="http://www.lua.org/manual/5.1/manual.html#pdf-loadstring">loadstring</a>动态加载代码并执行。应当尽量避免这种用法，动态加载代码需要被立即编译，编译开销很大。</p>
<p>load_dynamic.lua：</p>
<pre><code class="language-lua">local lim = 10000000
local a = {}
for i = 1, lim do
	a[i] = loadstring(string.format(&quot;return %d&quot;, i))
end
print(a[10]())  --&gt; 10
</code></pre>
<p>load_static.lua：</p>
<pre><code class="language-lua">function fk (k)
	return function () return k end
end

local lim = 10000000
local a = {}
for i = 1, lim do
	a[i] = fk(i)
end

print(a[10]())  --&gt; 10
</code></pre>
<p>上面两段代码的性能完全不同，后者耗时只有前者的十分之一：</p>
<pre><code class="language-bash">➜  03-performance git:(master) ✗ time lua-5.1 ./load_dynamic.lua
10
lua-5.1 ./load_dynamic.lua  47.99s user 3.81s system 99% cpu 52.069 total

➜  03-performance git:(master) ✗ time lua-5.1 ./load_static.lua
10
lua-5.1 ./load_static.lua  4.66s user 0.62s system 99% cpu 5.308 total
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lua中table类型变量的容量扩增代价很高"><a class="header" href="#lua中table类型变量的容量扩增代价很高">Lua中table类型变量的容量扩增代价很高</a></h1>
<p>Lua的table是由<code>数组部分（array part）</code>和<code>哈希部分（hash part）</code>组成。数组部分索引的key是1~n的整数，哈希部分是一个哈希表（open address table）。</p>
<p>向table中插入数据时，如果已经满了，Lua会重新设置数据部分或哈希表的大小，容量是成倍增加的，哈希部分还要对哈希表中的数据进行整理。</p>
<p>需要特别注意的没有赋初始值的table，数组和部分哈希部分默认容量为0。</p>
<pre><code class="language-lua">local a = {}     --容量为0
a[1] = true      --重设数组部分的size为1
a[2] = true      --重设数组部分的size为2
a[3] = true      --重设数组部分的size为4

local b = {}     --容量为0
b.x = true       --重设哈希部分的size为1
b.y = true       --重设哈希部分的size为2
b.z = true       --重设哈希部分的size为4
</code></pre>
<p>因为容量是成倍增加的，因此越是容量小的table越容易受到影响，每次增加的容量太少，很快又满。</p>
<p>对于存放少量数据的table，要在创建table变量时，就设置它的大小，例如：</p>
<p>table_size_predefined.lua：</p>
<pre><code class="language-lua">for i = 1, 1000000 do
  local a = {true, true, true}   -- table变量a的size在创建是确定
  a[1] = 1; a[2] = 2; a[3] = 3   -- 不会触发容量重设
end
</code></pre>
<p>如果创建空的table变量，插入数据时，会触发容量重设，例如：</p>
<p>table_size_undefined.lua：</p>
<pre><code class="language-lua">for i = 1, 1000000 do
  local a = {}                   -- table变量a的size为0
  a[1] = 1; a[2] = 2; a[3] = 3   -- 触发3次容量重设
end
</code></pre>
<p>后者耗时几乎是前者的两倍：</p>
<pre><code class="language-bash">➜  03-performance git:(master) ✗ time lua-5.1 table_size_predefined.lua
lua-5.1 table_size_predefined.lua  4.17s user 0.01s system 99% cpu 4.190 total

➜  03-performance git:(master) ✗ time lua-5.1 table_size_undefined.lua
lua-5.1 table_size_undefined.lua  7.63s user 0.01s system 99% cpu 7.650 total
</code></pre>
<p>对于哈希部分也是如此，用下面的方式初始化:</p>
<pre><code>local b = {x = 1, y = 2, z = 3}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="只有向table插入数据时才有可能触发rehash"><a class="header" href="#只有向table插入数据时才有可能触发rehash">只有向table插入数据时，才有可能触发rehash</a></h1>
<p>table只有在满的情况下，继续插入的数据的时候，才会触发rehash。如果将一个table中的数据全部设置为nil，后续没有插入操作，这个table的大小会继续保持原状，不会收缩，占用的内存不会释放。
除非不停地向table中写入nil，写入足够多的次数后，重新触发rehash，才会发生收缩：</p>
<pre><code class="language-lua">a = {}
lim = 10000000

for i = 1, lim do a[i] = i end            --  create a huge table
print(collectgarbage(&quot;count&quot;))            --&gt; 196626

for i = 1, lim do a[i] = nil end          --  erase all its elements
print(collectgarbage(&quot;count&quot;))            --&gt; 196626，不会收缩

for i = lim + 1, 2*lim do a[i] = nil end  --  create many nil element
print(collectgarbage(&quot;count&quot;))            --&gt; 17，添加足够多nil之后才会触发rehash
</code></pre>
<p><strong>不要用这种方式触发rehash</strong>，如果想要释放内存，就直接释放整个table，不要通过清空它包含的数据的方式进行。</p>
<p>将table中的成员设置为nil的时候，不触发rehash，是为了支持下面的用法：</p>
<pre><code class="language-lua">for k, v in pairs(t) do
  if some_property(v) then
    t[k] = nil    -- erase that element
  end
end
</code></pre>
<p>如果每次设置nil都触发rehash，那么上面的操作就是一个灾难。</p>
<h2 id="清理table中的所有数据时用pairs不要用next"><a class="header" href="#清理table中的所有数据时用pairs不要用next">清理table中的所有数据时，用pairs，不要用next</a></h2>
<p>如果要在保留table变量的前提下，清理table中的所有数据，一定要用<a href="http://www.lua.org/manual/5.1/manual.html#pdf-pairs">pairs()</a>函数，不能用<a href="http://www.lua.org/manual/5.1/manual.html#pdf-next">next()</a>。</p>
<p>next()函数是返回中的table第一个成员，如果使用下面方式，next()每次从头开始查找第一个非nil的成员：</p>
<pre><code class="language-lua">while true do
	local k = next(t)
	if not k then break end
	t[k] = nil
end
</code></pre>
<p>正确的做法是用<code>pairs</code>：</p>
<pre><code class="language-lua">for k in pairs(t) do
	t[k] = nil
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lua编程时慎用字符串拼接"><a class="header" href="#lua编程时慎用字符串拼接">Lua编程时慎用字符串拼接</a></h1>
<p>Lua中的字符串是非常不同的，它们全部是内置的（internalized），或者说是全局的，变量中存放的是字符串的地址，并且每个变量索引的都是全局的字符串，没有自己的存放空间。</p>
<p>例如下面的代码，为变量a和变量b设置了同样的内容的字符串&quot;abc&quot;，&quot;abc&quot;只有一份存在，a和b引用的是同一个：</p>
<pre><code>local a = &quot;abc&quot;
local b = &quot;abc&quot;
</code></pre>
<p>如果要为a索引的字符串追加内容，那么会创建一个新的全局字符串：</p>
<pre><code>a = &quot;abc&quot; .. &quot;def&quot;
</code></pre>
<p>创建全局字符串的开销是比较大的，在lua中慎用字符串拼接。</p>
<p>如果一定要拼接，将它们写入table，然后用<code>table.contat()</code> 连接起来，如下：</p>
<pre><code class="language-lua">local t = {}
for line in io.lines() do
  t[#t + 1] = line
end

s = table.concat(t, &quot;\n&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lua编程时尽量少创建变量"><a class="header" href="#lua编程时尽量少创建变量">Lua编程时尽量少创建变量</a></h1>
<p>假设要存放多边形的多个顶点，每个顶点一个x坐标，一个y坐标。</p>
<p>方式一，每个顶点分配一个table变量：</p>
<pre><code class="language-lua">polyline = { { x = 10.3, y = 98.5 },
             { x = 10.3, y = 18.3 },
             { x = 15.0, y = 98.5 },
             ...
           }
</code></pre>
<p>方式二，每个顶点分配一个数组变量，开销要比第一种方式少：</p>
<pre><code class="language-lua">polyline = { { 10.3, 98.5 },
             { 10.3, 18.3 },
             { 15.0, 98.5 },
             ...
           }
</code></pre>
<p>方式三，将x坐标和y坐标分别存放到两个数组的中，一共只需要两个数组变量，开销更少：</p>
<pre><code class="language-lua">polyline = { x = { 10.3, 10.3, 15.0, ...},
             y = { 98.5, 18.3, 98.5, ...}
           }
</code></pre>
<p>要有意思的的优化代码，尽量少创建变量。</p>
<h2 id="在循环外部创建变量"><a class="header" href="#在循环外部创建变量">在循环外部创建变量</a></h2>
<p>如果在循环内创建变量，那么每次循环都会创建变量，导致不必要的创建、回收：</p>
<p>在循环内创建变量，var_inloop.lua：</p>
<pre><code class="language-lua">function foo ()
	for i = 1, 10000000 do
		local t = {0}
		t[1]=i
	end
end

foo()

</code></pre>
<p>在循环外创建变量，var_outloop.lua：</p>
<pre><code class="language-lua">local t={0}
function foo ()
	for i = 1, 10000000 do
		t[1] = i
	end
end

foo()
</code></pre>
<p>这两段代码的运行时间不是一个数量级的：</p>
<pre><code class="language-bash">➜  03-performance git:(master) ✗ time lua-5.1 var_inloop.lua
lua-5.1 var_inloop.lua  3.41s user 0.01s system 99% cpu 3.425 total

➜  03-performance git:(master) ✗ time lua-5.1 var_outloop.lua
lua-5.1 var_outloop.lua  0.22s user 0.00s system 99% cpu 0.224 total
	
</code></pre>
<p>变量是这样的，函数也是如此：</p>
<pre><code class="language-lua">local function aux (num)
	num = tonumber(num)
	if num &gt;= limit then return tostring(num + delta) end
end
	
for line in io.lines() do
	line = string.gsub(line, &quot;%d+&quot;, aux)
	io.write(line, &quot;\n&quot;)
end
</code></pre>
<p>不要用下面的这种方式：</p>
<pre><code class="language-lua">for line in io.lines() do
	line = string.gsub(line, &quot;%d+&quot;, 
	     function (num)
	         num = tonumber(num)
	         if num &gt;= limit then return tostring(num + delta) 
	     end
	)
	io.write(line, &quot;\n&quot;)
end
</code></pre>
<h2 id="尽量在字符串上创建分片"><a class="header" href="#尽量在字符串上创建分片">尽量在字符串上创建分片</a></h2>
<p>能用分片表示字符串，就不要创建新的字符串。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="缓存运行结果减少运算"><a class="header" href="#缓存运行结果减少运算">缓存运行结果，减少运算</a></h1>
<pre><code class="language-lua">function memoize (f)
    local mem = {}                       -- memoizing table
    setmetatable(mem, {__mode = &quot;kv&quot;})   -- make it weak
    return function (x)       -- new version of ’f’, with memoizing
        local r = mem[x]
        if r == nil then      -- no previous result?
            r = f(x)          -- calls original function
            mem[x] = r        -- store result for reuse
        end
        return r
    end
end
</code></pre>
<p>用<code>memoize()</code>创建的函数的运算结果可以被缓存：</p>
<pre><code class="language-lua">loadstring = memoize(loadstring)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="主动控制lua的垃圾回收过程"><a class="header" href="#主动控制lua的垃圾回收过程">主动控制Lua的垃圾回收过程</a></h1>
<p>可以通过<code>collectgarbage</code>干预垃圾回收过程，通过collectgarbage可以停止和重新启动垃圾回收。</p>
<p>可以在需要被快速运行完成的地方，关闭垃圾回收，等运算完成后再重启垃圾回收。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-编程速查手册"><a class="header" href="#python3-编程速查手册">Python3 编程速查手册</a></h1>
<p>Python2 马上不被支持了，现在（2019-08-06 22:28:10）最好坚持用 python3。</p>
<p>主要参考资料，Python 官网上的入门教程：<a href="https://docs.python.org/3/tutorial/index.html" title="官方文档：The Python Tutorial">The Python Tutorial</a>，菜鸟教程：<a href="https://www.runoob.com/python3/python3-tutorial.html" title="菜鸟教程：Python 3 教程">Python 3 教程</a>。前者更好一些，后者是中文易读一些。<a href="https://docs.python.org/3/reference/" title="The Python Language Reference">The Python Language Reference</a> 是一份高难度，但是信息最完整全面的文档，它是 python 语言的设计手册。</p>
<p>学习资料：</p>
<ul>
<li><a href="https://docs.python.org/3/tutorial/index.html" title="官方文档：The Python Tutorial">官方文档：The Python Tutorial</a></li>
<li><a href="https://docs.python.org/3/library/index.html#library-index" title="The Python Standard Library">The Python Standard Library</a></li>
<li><a href="https://docs.python.org/3/reference/index.html#reference-index" title="The Python Language Reference">The Python Standard Library</a></li>
<li><a href="https://docs.python.org/3/extending/index.html#extending-index" title="Extending and Embedding the Python Interpreter">Extending and Embedding the Python Interpreter</a></li>
<li><a href="https://docs.python.org/3/c-api/index.html#c-api-index" title="Python/C API Reference Manual">Python/C API Reference Manual</a></li>
<li><a href="https://www.runoob.com/python3/python3-tutorial.html" title="菜鸟教程：Python 3 教程">菜鸟教程：Python 3 教程</a></li>
</ul>
<h2 id="参考-39"><a class="header" href="#参考-39">参考</a></h2>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python2代码转换成python3代码"><a class="header" href="#python2代码转换成python3代码">Python2代码转换成Python3代码</a></h1>
<p>Python提供了一个名为<a href="https://docs.python.org/2/library/2to3.html">2to3</a>的命令，将pyton2代码转换成python3代码。</p>
<pre><code>$ 2to3 -w example.py
</code></pre>
<p>参数<code>-w</code>表示改写原文件，传入的参数可以是文件名，也可以是目录。如果目录，2to3会遍历整个目录以及子目录。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="pyhont3-的运行环境与依赖管理"><a class="header" href="#pyhont3-的运行环境与依赖管理">Pyhont3 的运行环境与依赖管理</a></h1>
<h2 id="virtualenv"><a class="header" href="#virtualenv">virtualenv</a></h2>
<p>用 virtualenv 创建独立的 python 运行环境是一个非常好的做法，不干扰本地的 python 环境也不受本地 python 环境影响。</p>
<p>安装 virutalenv：</p>
<pre><code class="language-sh">pip install virtualenv
</code></pre>
<p>创建 python 运行环境：</p>
<pre><code class="language-sh">virtualenv -p python3 env  # 创建一个名为env的目录，存放python文件
                           # -p 指定 python 的版本
</code></pre>
<p>进入独立的 python 环境：</p>
<pre><code class="language-sh">source bin/activate
</code></pre>
<p>这时在当前 shell 窗口用 pip 安装的 python 包都被存放在 env 目录中，完全不影响本地的 python 环境。</p>
<p>退出时，输入下面的命令即可：</p>
<pre><code class="language-sh">deactivate
</code></pre>
<h2 id="依赖包管理"><a class="header" href="#依赖包管理">依赖包管理</a></h2>
<p>依赖包记录到 requirements.txt 文件中。</p>
<p>导出当前项目依赖的 python 包：</p>
<pre><code class="language-sh">pip freeze &gt; requirements.txt
</code></pre>
<p>安装依赖的 python 包：</p>
<pre><code class="language-sh">pip install -r requirements.txt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-代码文件"><a class="header" href="#python3-代码文件">Python3 代码文件</a></h1>
<p>Python 的代码文件默认是 UTF-8 编码，可以用在 python 代码文件的第一行添加注释的方式更给默认编码，例如 使用 windows-1252  编码：</p>
<pre><code class="language-python"># -*- coding: cp1252 -*-
</code></pre>
<p>编码声明注释需要位于文件的第一行，除非第一行是指定解释器的注释：</p>
<pre><code class="language-python">#!/usr/bin/env python3
# -*- coding: cp1252 -*-
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的基本数据结构"><a class="header" href="#python3-的基本数据结构">Python3 的基本数据结构</a></h1>
<p><a href="https://docs.python.org/3/library/stdtypes.html" title="Python3: Built-in Types">Python3: Built-in Types</a> 介绍了 Python3 支持的所有数据类型，以及适用的操作符：</p>
<pre><code class="language-sh">boolean
numeric         --&gt; int、float、complex
iterator        --&gt; generator
sequence        --&gt; list、tuple、range
text sequence   --&gt; str
binary sequence --&gt; bytes、bytearray、memoryview
set             --&gt; set、frozenset
map             --&gt; dict
</code></pre>
<p>string、numeric 等基本类型的定义语法见 <a href="https://docs.python.org/3/reference/lexical_analysis.html#literals" title="Python3: Literals">Python3: Literals</a>。</p>
<p>最常关注和使用的是 <a href="https://docs.python.org/3/library/stdtypes.html#typesseq" title="Sequence Types — list, tuple, range">sequence</a> 类型的数据结构：</p>
<ul>
<li>list（列表/数组）</li>
<li>tuple（元组）</li>
<li>sequence（序列）</li>
<li>set （集合）</li>
<li>dictionary （字典/map）</li>
</ul>
<h2 id="参考-40"><a class="header" href="#参考-40">参考</a></h2>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的数据结构list-列表"><a class="header" href="#python3-的数据结构list-列表">Python3 的数据结构：List 列表</a></h1>
<p>List 是可以修改的数组，支持嵌套。</p>
<h2 id="list-的创建"><a class="header" href="#list-的创建">List 的创建</a></h2>
<pre><code class="language-python">list1 = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
list2 = []
</code></pre>
<p>用下面的方式创建 list 时需要一个命名变量 x：</p>
<pre><code class="language-python">&gt;&gt;&gt; squares = []
&gt;&gt;&gt; for x in range(10):
...     squares.append(x**2)
...
&gt;&gt;&gt; squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>可以用下面两种方式消除命名变量 x：</p>
<pre><code class="language-python">squares = list(map(lambda x: x**2, range(10)))
squares = [x**2 for x in range(10)]
</code></pre>
<p><code>[]</code> 支持多个 for 循环和条件判断，例如：</p>
<pre><code class="language-python">&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</code></pre>
<p>等同于：</p>
<pre><code class="language-python">&gt;&gt;&gt; combs = []
&gt;&gt;&gt; for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
&gt;&gt;&gt; combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</code></pre>
<h2 id="list-支持的方法"><a class="header" href="#list-支持的方法">List 支持的方法</a></h2>
<p>list 支持下面的方法：</p>
<pre><code class="language-sh">list.append(x)         # 追加单个成员
list.extend(iterable)  # 将迭代器中成员全部追加到 list
list.insert(i, x)      # 在指定为未知插入成员，i 从 0 开始
list.remove(x)         # 删除 list 的第一个成员，如果为空，抛异常 ValueError
list.pop([i])          # 删除指定位置的成员并将其返回，如果没有指定 i 操作最后一个成员
list.clear()           # 清空
list.index(x,[start, [end])   # 返回相对于 start 的第 x 个成员，从 0 开始编号，end 是查找结束的位置
list.count(x)          # 返回 x 在列表中出现的次数
list.sort(key=None，reverse=False)  # 列表原地排序
list.reverse()         # 列表原地反转
list.copy()            # 复制列表
</code></pre>
<p>del 语句也能删除 list 的成员，例如：</p>
<pre><code class="language-sh">del a[0]    # 删除 index 为 0 的成员
del a[2:4]  # 删除 index 为 2、3、4 的成员
del a[:]    # 清空 list
</code></pre>
<h2 id="遍历-list"><a class="header" href="#遍历-list">遍历 list</a></h2>
<p>获取 索引和值，使用 enumerate()：</p>
<pre><code class="language-python">&gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
</code></pre>
<p>同时遍历两个 list，用 zip()：</p>
<pre><code class="language-python">&gt;&gt;&gt; questions = ['name', 'quest', 'favorite color']
&gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue']
&gt;&gt;&gt; for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的数据结构tuple-元组"><a class="header" href="#python3-的数据结构tuple-元组">Python3 的数据结构：Tuple 元组</a></h1>
<p>Tuple，元组，类似于 list，是用逗号分隔的一组值，在输出时，tuple 是用 () 包裹的一组值。Tuple 与 List 非常相似，但是 tuple 时不可改写的，通常用来存放不同类型的数据，list 通常用来存放相同类型的数据（只是习惯做法，语法上没有强制要求）。</p>
<p>tuple 的声明：</p>
<pre><code class="language-python">t = 12345, 54321, 'hello!'
empty = ()
singleton = 'hello',
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-数据结构set"><a class="header" href="#python3-数据结构set">Python3 数据结构：set</a></h1>
<p>Set 是一组没有顺序并且没有重复的值，支持交集、并集、差集、对称差集运算。</p>
<p>Set 创建：</p>
<pre><code class="language-python">basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
a = set('abracadabra')
b = {x for x in 'abracadabra' if x not in 'abc'}
</code></pre>
<p>Set 运算：</p>
<pre><code class="language-python">a - b       # 差集
a | b       # 并集
a &amp; b       # 交集
a ^ b       # 对称差集，去掉同时位于 a 和 b 中的成员后剩余的成员
</code></pre>
<p>遍历排序的 set ：</p>
<pre><code class="language-python">&gt;&gt;&gt; basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
&gt;&gt;&gt; for f in sorted(set(basket)):
...     print(f)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python-数据结构dictionary"><a class="header" href="#python-数据结构dictionary">Python 数据结构：dictionary</a></h1>
<p>Dictionary，就是 map，key-value 对。</p>
<p>字典的创建：</p>
<pre><code class="language-python">dic1 = {'jack': 4098, 'sape': 4139}
dic2 = dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
dic3 = {x: x**2 for x in (2, 4, 6)}
dic4 = dict(sape=4139, guido=4127, jack=4098)
</code></pre>
<p>可以用 list 列出字典中的所有 key ，如果需要排序用 sorted：</p>
<pre><code class="language-python">&gt;&gt;&gt; list(tel)
['jack', 'guido', 'irv']
&gt;&gt;&gt; sorted(tel)
['guido', 'irv', 'jack']
</code></pre>
<p>判断一个 key 是否存在用 in：</p>
<pre><code class="language-python">&gt;&gt;&gt; 'guido' in tel
True

&gt;&gt;&gt; 'jack' not in tel
False
</code></pre>
<p>遍历字典时，使用 items() 获取  key-value：</p>
<pre><code class="language-python">&gt;&gt;&gt; knights = {'gallahad': 'the pure', 'robin': 'the brave'}
&gt;&gt;&gt; for k, v in knights.items():
...     print(k, v)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-字符串处理方法"><a class="header" href="#python3-字符串处理方法">Python3 字符串处理方法</a></h1>
<h2 id="字符串处理-1"><a class="header" href="#字符串处理-1">字符串处理</a></h2>
<p>List 拼接成字符串：</p>
<pre><code class="language-python">list = ['a','b','c']
','.join(list)
</code></pre>
<p>字符串内容替换：</p>
<pre><code class="language-python">str = 'abc123 / / 123'
str.replace('/',' ')
</code></pre>
<p>字符串正则替换：</p>
<pre><code class="language-python">import re
...

str = 'abc123 / / 123'
res.sub('/s+',' ',str)
</code></pre>
<p>正则提取：</p>
<pre><code class="language-python">content = &quot;【hello】world&quot;
match = re.match('【(.*)】', content, re.UNICODE)
if match:
	print match.group(1)
</code></pre>
<h2 id="字符串转换"><a class="header" href="#字符串转换">字符串转换</a></h2>
<p>字符串转换成 byte 数组：</p>
<pre><code class="language-python">s = &quot;Hello, world!&quot;   # str object 

print('str --&gt; bytes')
print(bytes(s, encoding=&quot;utf8&quot;))

b = b&quot;Hello, world!&quot;  # bytes object
print('\nbytes --&gt; str')
print(str(b, encoding=&quot;utf-8&quot;))
</code></pre>
<h2 id="json-字符串处理"><a class="header" href="#json-字符串处理">json 字符串处理</a></h2>
<p>序列化为 json 字符串：</p>
<pre><code class="language-python">import json
di = dict(name='BOb', age=20, score=93)
json.dumps(di)
</code></pre>
<p>json 字符串反序列化：</p>
<pre><code class="language-python">import json
json_str = '{&quot;name&quot;: &quot;BOb&quot;, &quot;age&quot;: 20, &quot;score&quot;: 93}'
json.loads(json_str)
</code></pre>
<h2 id="参考-41"><a class="header" href="#参考-41">参考</a></h2>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python-的时间处理"><a class="header" href="#python-的时间处理">Python 的时间处理</a></h1>
<h2 id="秒转化成日期"><a class="header" href="#秒转化成日期">秒转化成日期</a></h2>
<pre><code class="language-python">import time

def Second2Date(seconds):
    t = time.localtime(seconds)
    return time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,t)

if __name__ == &quot;__main__&quot;:
    print(Second2Date(1567672240))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的数值处理"><a class="header" href="#python3-的数值处理">Python3 的数值处理</a></h1>
<h2 id="字符串转化成数值"><a class="header" href="#字符串转化成数值">字符串转化成数值</a></h2>
<pre><code class="language-python">def String2Num(str):
    return int(str)

if __name__ == &quot;__main__&quot;:
    print(String2Num(&quot;123456&quot;))
</code></pre>
<h2 id="参考-42"><a class="header" href="#参考-42">参考</a></h2>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的内置函数"><a class="header" href="#python3-的内置函数">Python3 的内置函数</a></h1>
<p>Python3 的内置函数见 <a href="https://docs.python.org/3/library/functions.html" title="Python3: Built-in Functions">Python3: Built-in Functions</a>。</p>
<p>内置的特殊属性见：<a href="https://docs.python.org/3/library/stdtypes.html#special-attributes" title="Python3: Special Attributes">Python3: Special Attributes</a>。</p>
<p>Python3 内置的操作符号见 <a href="https://docs.python.org/3/reference/lexical_analysis.html#operators" title="Python3：Operators">Python3：Operators</a>：</p>
<pre><code>+       -       *       **      /       //      %      @
&lt;&lt;      &gt;&gt;      &amp;       |       ^       ~
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python-的作用域"><a class="header" href="#python-的作用域">Python 的作用域</a></h1>
<p>Python 的命名空间（namespace）包括：</p>
<ol>
<li>内置的命名框架，包含内置的函数、变量、内置的异常</li>
<li>module 的 global namespace </li>
<li>函数的局部 namespace</li>
</ol>
<h2 id="变量的作用域"><a class="header" href="#变量的作用域">变量的作用域</a></h2>
<p>作用域（scope） 是具体的代码段，namespace 投射到 scope，</p>
<p>如果要使用上层作用域的变量，需要用 nonlocal 声明，否则只是在当前作用域创建一个同名变量，声明全局变量使用 global：</p>
<pre><code class="language-python">spam = &quot;&quot;       # 当前作用域中的变量
nonlocal spam   # 上层作用域中的变量
global span     # 全局作用域中的变量
</code></pre>
<p>示例：</p>
<pre><code class="language-python">def scope_test():
    def do_local():
        spam = &quot;local spam&quot;

    def do_nonlocal():
        nonlocal spam
        spam = &quot;nonlocal spam&quot;

    def do_global():
        global spam
        spam = &quot;global spam&quot;

    spam = &quot;test spam&quot;
    do_local()
    print(&quot;After local assignment:&quot;, spam)
    do_nonlocal()
    print(&quot;After nonlocal assignment:&quot;, spam)
    do_global()
    print(&quot;After global assignment:&quot;, spam)

scope_test()
print(&quot;In global scope:&quot;, spam)
</code></pre>
<p>运行输出为：</p>
<pre><code>After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
</code></pre>
<h2 id="类中变量的作用域"><a class="header" href="#类中变量的作用域">类中变量的作用域</a></h2>
<p>类属性的作用域是类，该类的所有实例使用同一份类属性，实例属性作用域是单个实例，每个实例一份。</p>
<p>例如下面的 kind 是类属性，name 是实例属性：</p>
<pre><code class="language-python3">class Dog:

    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

&gt;&gt;&gt; d = Dog('Fido')
&gt;&gt;&gt; e = Dog('Buddy')
&gt;&gt;&gt; d.kind                  # shared by all dogs
'canine'
&gt;&gt;&gt; e.kind                  # shared by all dogs
'canine'
&gt;&gt;&gt; d.name                  # unique to d
'Fido'
&gt;&gt;&gt; e.name                  # unique to e
'Buddy'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-的命令行参数读取"><a class="header" href="#python3-的命令行参数读取">Python3 的命令行参数读取</a></h1>
<p>命令行参数从 sys.argv[] 中读取，sys.argv[0] 是文件名，sys.arg[1] 是第一个命令行参数，以此类推：</p>
<pre><code class="language-python">import sys

if __name__ == &quot;__main__&quot;:
    print(&quot;%d %s %s&quot; % (sys.argv.__len__(), sys.argv[0], sys.argv[1]))
</code></pre>
<ul>
<li>如果文件名是 <code>-</code> （标注输入），sys.argv[0] 是 <code>-</code>；</li>
<li>如果使用了 -c 参数，sys.argv[0] 是 -c；</li>
<li>如果使用了 -m 参数，sys.argv[0] 是 -m 指定的 module 的完整名称</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的模块"><a class="header" href="#python3-的模块">Python3 的模块</a></h1>
<p>Python3 的代码以模块方式组织，一个模块对应一个以模块名命名的 py 文件，当前模块名存放在全局遍历 <code>__name__</code> 中。</p>
<h2 id="模块的初始化"><a class="header" href="#模块的初始化">模块的初始化</a></h2>
<p>模块中包含直接执行的语句和函数定义，直接执行的语句在模块第一次导入的时候执行，相当于模块的初始化代码。</p>
<p>模块有单独私有符号表，模块的私有的符号表被模块内的函数当作全局的符号表。</p>
<p>导入模块：</p>
<pre><code class="language-python">from fibo import fib, fib2
from fibo import *
import fibo as fib
from fibo import fib as fibonacci
</code></pre>
<h2 id="模块的直接运行"><a class="header" href="#模块的直接运行">模块的直接运行</a></h2>
<p>直接执行模块文件时，从下面的 if 条件之后的语句开始执行：</p>
<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    import sys
    fib(int(sys.argv[1]))
</code></pre>
<h2 id="模块的查找路径"><a class="header" href="#模块的查找路径">模块的查找路径</a></h2>
<p>python3 解析器遇到导入模块的语句时，首先查看导入的模块是否是 python3 的内置模块，然后到变量 sys.path 指定的目录中查找。</p>
<p>sys.path 中包含多个目录，默认目录顺序是：</p>
<ul>
<li>当前模块文件所在的目录</li>
<li>环境变量 PYTHONPATH 指定的路径，默认是 prefix/lib/pythonversion，prefix 是 python 的安装路径</li>
<li>python 的安装路径</li>
</ul>
<p>当前目录中的模块如果与 python 标准库中的模块重名，后者被前者覆盖。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的-package-用法"><a class="header" href="#python3-的-package-用法">Python3 的 Package 用法</a></h1>
<p>Package 由一组位于同一目录下的 module 组成，这些 module 纳入 Package 的 namespace 中。不同 Package 中的同名模块因为位于不同的 namespace 中，所以能够被区分。</p>
<h2 id="package-的创建"><a class="header" href="#package-的创建">Package 的创建</a></h2>
<p>Package 的目录中必须有  <code>__init__.py</code> 文件，该文件确保 Package 目录不会被当作普通目录处理：</p>
<pre><code class="language-sh">sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</code></pre>
<p><code>__init__.py</code> 文件内容可以为空，也可以设置 <code>__all__</code> 变量，导入 package 时如果使用 <code>*</code>，导入的是 <code>__all__</code> 中的符号：</p>
<pre><code class="language-python">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre>
<h2 id="导入-package"><a class="header" href="#导入-package">导入 Package</a></h2>
<p>Package 的导入方法和 module 相同：</p>
<pre><code class="language-python">import sound.effects.echo
from sound.effects import echo
from sound.effects.echo import echofilter
from sound.effects import *

from . import echo
from .. import formats
from ..filters import equalizer
</code></pre>
<p><code>import *</code> 导入的是 sound.effects 目录中 <code>__init__.py</code> 中的 <code>__all__</code> 变量里的内容。</p>
<h2 id="通过-__path__-属性跨目录"><a class="header" href="#通过-__path__-属性跨目录">通过 <code>__path__</code> 属性跨目录</a></h2>
<p><code>__path__</code> 属性初始值是包含 <code>__init__.py</code> 文件的 package 目录，修改这个属性，可以影响后续的 module 和 package 的查找范围。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的-io-操作--格式化输出"><a class="header" href="#python3-的-io-操作--格式化输出">Python3 的 IO 操作 —— 格式化输出</a></h1>
<p>Python3 支持多种格式化输出方法。</p>
<h2 id="格式字符串"><a class="header" href="#格式字符串">格式字符串</a></h2>
<p>以 f 或者 F 开头的字符串中可以使用 python 表达式：</p>
<pre><code class="language-sh">&gt;&gt;&gt; year = 2016
&gt;&gt;&gt; event = 'Referendum'
&gt;&gt;&gt; f'Results of the {year} {event}'
'Results of the 2016 Referendum'
</code></pre>
<h2 id="strformat"><a class="header" href="#strformat">str.format()</a></h2>
<p>str.format() 可以用于格式化输出：</p>
<pre><code class="language-sh">&gt;&gt;&gt; yes_votes = 42_572_654
&gt;&gt;&gt; no_votes = 43_132_495
&gt;&gt;&gt; percentage = yes_votes / (yes_votes + no_votes)
&gt;&gt;&gt; '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)
' 42572654 YES votes  49.67%'
</code></pre>
<h2 id="变量转换成字符串"><a class="header" href="#变量转换成字符串">变量转换成字符串</a></h2>
<p>str() 和 repr() 可以将任意变量转换成字符串，前者转换成可读的字符串，后者转换成可以被 解析执行的字符串：</p>
<pre><code class="language-python">&gt;&gt;&gt; s = 'Hello, world.'
&gt;&gt;&gt; str(s)
'Hello, world.'
&gt;&gt;&gt; repr(s)
&quot;'Hello, world.'&quot;
</code></pre>
<p>str() 的输出格式是  <code>__str__</code> 属性决定的：</p>
<pre><code class="language-python">&gt;&gt;&gt; class Point:
...     def __init__(self, x, y):
...         self.x, self.y = x, y
...     def __str__(self):
...         return 'Point({self.x}, {self.y})'.format(self=self)
...
&gt;&gt;&gt; str(Point(4, 2))
'Point(4, 2)'
</code></pre>
<h2 id="使用-"><a class="header" href="#使用-">使用 %</a></h2>
<p>%  的效果类似于 sprintf：</p>
<pre><code class="language-python">&gt;&gt;&gt; import math
&gt;&gt;&gt; print('The value of pi is approximately %5.3f.' % math.pi)
The value of pi is approximately 3.142.
</code></pre>
<p>% 支持的占位符见 <a href="https://docs.python.org/3/library/stdtypes.html#old-string-formatting" title="printf-style String Formatting">printf-style String Formatting</a>：</p>
<h2 id="格式化字符串使用的占位符"><a class="header" href="#格式化字符串使用的占位符">格式化字符串使用的占位符</a></h2>
<p>f 字符串和 str.format() 都用到{XX} 样式的占位符，python3 的占位符语法如下：</p>
<pre><code class="language-sh">format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]
fill            ::=  &lt;any character&gt;
align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;
sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;
width           ::=  digit+
grouping_option ::=  &quot;_&quot; | &quot;,&quot;
precision       ::=  digit+
type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;
</code></pre>
<p>占位符用法比较多（详情见 <a href="https://docs.python.org/3/library/string.html#formatspec" title="Format Specification Mini-Language">Format Specification Mini-Language</a>），下面是几个例子：</p>
<p>变量匹配：</p>
<pre><code class="language-python">&gt;&gt;&gt; '{0}, {1}, {2}'.format('a', 'b', 'c')
'a, b, c'

&gt;&gt;&gt; '{}, {}, {}'.format('a', 'b', 'c')  # 3.1+ only
'a, b, c'

&gt;&gt;&gt; '{2}, {1}, {0}'.format('a', 'b', 'c')
'c, b, a'

&gt;&gt;&gt; '{2}, {1}, {0}'.format(*'abc')      # unpacking argument sequence
'c, b, a'

&gt;&gt;&gt; '{0}{1}{0}'.format('abra', 'cad')   # arguments' indices can be repeated
'abracadabra'

&gt;&gt;&gt; coord = (3, 5)
&gt;&gt;&gt; 'X: {0[0]};  Y: {0[1]}'.format(coord)
'X: 3;  Y: 5'

&gt;&gt;&gt; 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W')
'Coordinates: 37.24N, -115.81W'

&gt;&gt;&gt; coord = {'latitude': '37.24N', 'longitude': '-115.81W'}
&gt;&gt;&gt; 'Coordinates: {latitude}, {longitude}'.format(**coord)
'Coordinates: 37.24N, -115.81W'

&gt;&gt;&gt; c = 3-5j
&gt;&gt;&gt; ('The complex number {0} is formed from the real part {0.real} '
...  'and the imaginary part {0.imag}.').format(c)
'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.'

&gt;&gt;&gt; &quot;repr() shows quotes: {!r}; str() doesn't: {!s}&quot;.format('test1', 'test2')
&quot;repr() shows quotes: 'test1'; str() doesn't: test2&quot;
</code></pre>
<p>对齐填充：</p>
<pre><code class="language-python">&gt;&gt;&gt;{:&lt;30}'.format('left aligned')
'left aligned                '

&gt;&gt;&gt; '{:&lt;30}'.format('left aligned')
'left aligned                  '

&gt;&gt;&gt; '{:&gt;30}'.format('right aligned')
'                 right aligned'

&gt;&gt;&gt; '{:^30}'.format('centered')
'           centered           '

&gt;&gt;&gt; '{:*^30}'.format('centered')  # use '*' as a fill char
'***********centered***********'
</code></pre>
<p>显示精度：</p>
<pre><code class="language-python">&gt;&gt;&gt; '{:+f}; {:+f}'.format(3.14, -3.14)  # show it always
'+3.140000; -3.140000'
&gt;&gt;&gt; '{: f}; {: f}'.format(3.14, -3.14)  # show a space for positive numbers
' 3.140000; -3.140000'
&gt;&gt;&gt; '{:-f}; {:-f}'.format(3.14, -3.14)  # show only the minus -- same as '{:f}; {:f}'
'3.140000; -3.140000'
</code></pre>
<p>格式转换：</p>
<pre><code class="language-python">&gt;&gt;&gt; # format also supports binary numbers
&gt;&gt;&gt; &quot;int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}&quot;.format(42)
'int: 42;  hex: 2a;  oct: 52;  bin: 101010'

&gt;&gt;&gt; # with 0x, 0o, or 0b as prefix:
&gt;&gt;&gt; &quot;int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}&quot;.format(42)
'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'

&gt;&gt;&gt; '{:,}'.format(1234567890)
'1,234,567,890'

&gt;&gt;&gt; import datetime
&gt;&gt;&gt; d = datetime.datetime(2010, 7, 4, 12, 15, 58)
&gt;&gt;&gt; '{:%Y-%m-%d %H:%M:%S}'.format(d)
'2010-07-04 12:15:58'
</code></pre>
<h2 id="参考-43"><a class="header" href="#参考-43">参考</a></h2>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的-io-操作--文件读写"><a class="header" href="#python3-的-io-操作--文件读写">Python3 的 IO 操作 —— 文件读写</a></h1>
<p>Python3 内置的 open() 函数打开指定文件，并返回文件对象。</p>
<h2 id="open-建议用法"><a class="header" href="#open-建议用法">open() 建议用法</a></h2>
<p>open() 函数建议和 with 一起使用，使用 with 时，文件会在读写完成后自动关闭：</p>
<pre><code class="language-python">&gt;&gt;&gt; with open('workfile') as f:
...     read_data = f.read()
&gt;&gt;&gt; f.closed
True
</code></pre>
<h2 id="文件对象支持的方法"><a class="header" href="#文件对象支持的方法">文件对象支持的方法</a></h2>
<p>文件对象支持的方法:</p>
<pre><code class="language-python">f.read()
f.readline()

for line in f:
    print(line, end='')

f.write('This is a test\n')
f.seek(5)      # Go to the 6th byte in the file
f.read(1)
f.seek(-3, 2)  # Go to the 3rd byte before the end
f.tell()       # 返回当前位置
</code></pre>
<h2 id="json-格式内容写入加载"><a class="header" href="#json-格式内容写入加载">json 格式内容写入加载</a></h2>
<p>json.dump(x,f) 将 x 序列化后写入文件 f，json.load(f) 将文件 f 中的 json 字符串加载并反序列化：</p>
<pre><code class="language-python">import json
json.dump(x, f)
x = json.load(f)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的错误和异常处理方法"><a class="header" href="#python3-的错误和异常处理方法">Python3 的错误和异常处理方法</a></h1>
<p>Python3 的运行错误以异常的方式抛出。</p>
<h2 id="捕获异常"><a class="header" href="#捕获异常">捕获异常</a></h2>
<p>用 try...except...except...else...finally  捕获异常，支持同时处理多种类型的异常：</p>
<pre><code class="language-python">import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print(&quot;OS error: {0}&quot;.format(err))
except ValueError:
    print(&quot;Could not convert data to an integer.&quot;)
except:
    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])
    raise
</code></pre>
<p>else 后面的语句是在没有异常时执行的语句，该语句必须在 except 之后：</p>
<pre><code class="language-python">for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except OSError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()
</code></pre>
<p>finally 中的语句无论是否发生异常，都要在离开 try 语句前执行，通常是清理操作：</p>
<pre><code class="language-python">&gt;&gt;&gt; try:
...     raise KeyboardInterrupt
... finally:
...     print('Goodbye, world!')
...
Goodbye, world!
KeyboardInterrupt
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
</code></pre>
<h2 id="抛出异常"><a class="header" href="#抛出异常">抛出异常</a></h2>
<p>用 raise 主动抛出异常，抛出异常时，可以传入参数，之后通过异常变量的 args 获取：</p>
<pre><code class="language-python">try:
    raise Exception('spam', 'eggs')
except Exception as inst:
    print(type(inst))    # the exception instance
    print(inst.args)     # arguments stored in .args
    print(inst)          # __str__ allows args to be printed directly,
                         # but may be overridden in exception subclasses
    x, y = inst.args     # unpack args
    print('x =', x)
    print('y =', y)
</code></pre>
<h2 id="异常的种类"><a class="header" href="#异常的种类">异常的种类</a></h2>
<p>所有的异常源自 <a href="https://docs.python.org/3/library/exceptions.html#Exception" title="exception Exception">Exception</a> 类，可以自定义异常：</p>
<pre><code class="language-python">class InputError(Error):
    &quot;&quot;&quot;Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    &quot;&quot;&quot;

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message
</code></pre>
<h2 id="带有自动清理的变量"><a class="header" href="#带有自动清理的变量">带有自动清理的变量</a></h2>
<p>有一些变量具有自我清理功能，配合 with 使用，例如下面的文件对象 f 会自动关闭：</p>
<pre><code class="language-python">with open(&quot;myfile.txt&quot;) as f:
    for line in f:
        print(line, end=&quot;&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-的类的使用"><a class="header" href="#python3-的类的使用">Python3 的类的使用</a></h1>
<p>和其它语言一样，Class 是 Python3 中语法最复杂的类型。</p>
<p>类的定义称为 Class，类的实例称为 Instance。</p>
<p>Python3 的内置函数 isinstance() 和 issubclass() 分别用来检查对象与类的关系、类的继承关系（对象所属的类记录在 <code>__class__</code> 属性中）。</p>
<h2 id="类的定义"><a class="header" href="#类的定义">类的定义</a></h2>
<p><code>__init__</code> 方法相当于构造函数，</p>
<pre><code class="language-python">class MyClass:
    &quot;&quot;&quot;A simple example class&quot;&quot;&quot;
    i = 12345

    def f(self):
        return 'hello world'

    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart
</code></pre>
<p>类的实例化：</p>
<pre><code class="language-python">x = MyClass(3.0, -4.5)
</code></pre>
<h2 id="类属性"><a class="header" href="#类属性">类属性</a></h2>
<p>直接在类中定义的属性属于类变量：</p>
<pre><code class="language-python3">class Dog:

    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

&gt;&gt;&gt; d = Dog('Fido')
&gt;&gt;&gt; e = Dog('Buddy')
&gt;&gt;&gt; d.kind                  # shared by all dogs
'canine'
&gt;&gt;&gt; e.kind                  # shared by all dogs
'canine'
&gt;&gt;&gt; d.name                  # unique to d
'Fido'
&gt;&gt;&gt; e.name                  # unique to e
'Buddy'
</code></pre>
<h2 id="类的继承"><a class="header" href="#类的继承">类的继承</a></h2>
<p>Python3 中的类支持多重继承：</p>
<pre><code class="language-python">class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre>
<p>在子类中，用 <a href="https://docs.python.org/3/library/functions.html#super" title="super">super()</a> 方法调用父类的属性：</p>
<pre><code class="language-python">class C(B):
    def __init__(self,url):
        super().__init__(url)
    def method(self, arg):
        super().method(arg)    # This does the same thing as:
                               # super(C, self).method(arg)
</code></pre>
<p><a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" title="Python’s super() considered super!">Python’s super() considered super!</a> 对 super 有更多介绍。</p>
<h2 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h2>
<p>类的迭代器行为在 <code>__iter__</code> 和 <code>__next__</code> 中定义，<code>__iter__</code> 返回带有 <code>__next__</code>
的迭代器对象，<code>__next__</code> 返回下一个对象：</p>
<pre><code class="language-python">class Reverse:
    &quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
</code></pre>
<h2 id="参考-44"><a class="header" href="#参考-44">参考</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python3-的生成器"><a class="header" href="#python3-的生成器">Python3 的生成器</a></h1>
<p>使用 yield 语句构造的 Generator 可以被迭代：</p>
<pre><code class="language-python">def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
</code></pre>
<p>Generator 执行到 yield 语句时会暂停，直到遇到迭代时继续执行到下一个 yield 语句处暂停：</p>
<pre><code class="language-python">&gt;&gt;&gt; for char in reverse('golf'):
...     print(char)
...
f
l
o
g
</code></pre>
<p>Python3 的内置函数 range()、zip() 是生成器：</p>
<pre><code class="language-python">&gt;&gt;&gt; sum(i*i for i in range(10))                 # sum of squares
285

&gt;&gt;&gt; xvec = [10, 20, 30]
&gt;&gt;&gt; yvec = [7, 5, 3]
&gt;&gt;&gt; sum(x*y for x,y in zip(xvec, yvec))         # dot product
260
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3-爬虫开发"><a class="header" href="#python3-爬虫开发">Python3 爬虫开发</a></h1>
<p>Python2 马上就要不维护了，现在要尽量使用 Python3，正好<code>崔庆才</code>写了一本<a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtYFAcXBFIZWR0yEgRXGVkRBxM3EUQDS10iXhBeGlcJDBkNXg9JHU4YDk5ER1xOGRNLGEEcVV8BXURFUFdfC0RVU1JRUy1OVxUBEAVXH14UMlYDHU8Sd19AYigcI0NLSQEKezN3QmILWStaJQITBlQbWRUHEwJlK1sSMkBpja3tzaejG4Gx1MCKhTdUK1sRBRcOXR1dHQsQAlYrXBULIkUQXw5dbFdZA08eTFZRN2UrWCUyIgdlGGtXbBpVBk4JHAARDgBMDhALRQMGGA4RCkIDVkxYRwEQU1dJaxcDEwNc" title="崔庆才：《Python 3网络爬虫开发实战 》">《Python 3网络爬虫开发实战》</a>，介绍了 Requests、Selenium、PhantomJS、Beautiful Soup 等 python 库的用法。</p>
<p>用 virtualenv 创建的 python 运行环境，指定用 python3，并安装要用到的库：</p>
<pre><code class="language-sh">pip install virtualenv
mkdir spider3
cd spider3

virtualenv -p python3 env
source env/bin/activate
pip3 install django mysqlclient requests beautifulsoup4
</code></pre>
<p>随时将依赖的 python 包更新到 requirements.txt 文件中：</p>
<pre><code class="language-sh">pip3 freeze &gt; requirements.txt
</code></pre>
<h2 id="参考-45"><a class="header" href="#参考-45">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
<li><a href="https://cuiqingcai.com/5052.html" title="Python3网络爬虫开发实战教程">Python3网络爬虫开发实战教程</a></li>
<li><a href="https://www.seleniumhq.org/" title="What is Selenium?">What is Selenium?</a></li>
<li><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtYFAcXBFIZWR0yEgRXGVkRBxM3EUQDS10iXhBeGlcJDBkNXg9JHU4YDk5ER1xOGRNLGEEcVV8BXURFUFdfC0RVU1JRUy1OVxUBEAVXH14UMlYDHU8Sd19AYigcI0NLSQEKezN3QmILWStaJQITBlQbWRUHEwJlK1sSMkBpja3tzaejG4Gx1MCKhTdUK1sRBRcOXR1dHQsQAlYrXBULIkUQXw5dbFdZA08eTFZRN2UrWCUyIgdlGGtXbBpVBk4JHAARDgBMDhALRQMGGA4RCkIDVkxYRwEQU1dJaxcDEwNc" title="崔庆才：《Python 3网络爬虫开发实战 》">崔庆才：《Python 3网络爬虫开发实战》</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3爬虫开发----请求库"><a class="header" href="#python3爬虫开发----请求库">Python3爬虫开发 -- 请求库</a></h1>
<p>请求库用来发送 http 请求，获取目标页面。</p>
<h2 id="urllib"><a class="header" href="#urllib">urllib</a></h2>
<p><a href="https://docs.python.org/3/library/urllib.html">urllib</a> 是 Python3 内置的 HTTP 请求库。</p>
<p>GET 请求：</p>
<pre><code class="language-python">import urllib.request as request

if __name__ == &quot;__main__&quot;:
    try:
        resp = request.urlopen(url=&quot;http://www.baidu.com&quot;)
    except Exception as e:
        print(str(e))
    else:
        print(type(resp))
        print(resp.info())
        if resp.readable:
            data = resp.read()
            print(type(data))
            print(&quot;%s&quot; % data.decode(&quot;utf-8&quot;))
        resp.close()
    finally:
        None
</code></pre>
<p>POST 请求，带有 data：</p>
<pre><code class="language-python">pagesize=1
result = ''
url = 'http://irm.cninfo.com.cn/ircs/index/search'
data = f'pageNo=0&amp;pageSize={pagesize}&amp;searchTypes=1%2C11%2C&amp;keyWord=&amp;market=&amp;industry=&amp;stockCode='
try:
    resp = request.urlopen(url=url, data=bytes(data,encoding=&quot;utf8&quot;))
except Exception as e:
   print(str(e))
else:
    if resp.readable:
        result = json.loads(resp.read())
    resp.close()
finally:
   return result
</code></pre>
<p>Post 请求的时候，data 需要是 bytes 数组，不能是字符串：</p>
<pre><code>POST data should be bytes, an iterable of bytes, or a file object. It cannot be of type str.
</code></pre>
<h2 id="requests"><a class="header" href="#requests">Requests</a></h2>
<p><a href="https://github.com/requests/requests">Requests</a> 是一个发送 http 请求的 python 库，<a href="https://2.python-requests.org/en/master/">英文文档</a>，<a href="http://2.python-requests.org/zh_CN/latest/">中文文档</a>：</p>
<pre><code>pip3 install requests
</code></pre>
<h2 id="selenium"><a class="header" href="#selenium">Selenium</a></h2>
<p><a href="https://github.com/SeleniumHQ/selenium/tree/master/py">Selenium</a> 是一个用于 Web 自动化测试的浏览器，能够用代码控制浏览器内操作的特性使 Selenium 具有更广阔的应用空间，<a href="https://selenium-python.readthedocs.io/">英文文档</a>、<a href="https://selenium-python-zh.readthedocs.io/en/latest/">中文文档</a>：</p>
<pre><code>pip3 install selenium
</code></pre>
<h2 id="chrome-driver"><a class="header" href="#chrome-driver">Chrome Driver</a></h2>
<p><a href="https://sites.google.com/a/chromium.org/chromedriver">Chrome Driver</a> 和 <a href="https://github.com/mozilla/geckodriver">Gecko Driver</a> 是配合 Selenium 使用的，分别用来驱动 Chrome 浏览器和 Firefox 浏览器，安装方法见：<a href="https://cuiqingcai.com/5135.html">chromedriver</a> 和 <a href="https://cuiqingcai.com/5153.html">geckodriver</a> 。</p>
<h2 id="phantomjs"><a class="header" href="#phantomjs">Phantomjs</a></h2>
<p><a href="http://phantomjs.org">Phantomjs</a> 是无界面的 WebKit 浏览器，无界面运行效率高，需要 <a href="https://phantomjs.org/download.html">下载安装</a> 。可以被 Selenium 驱动，如下：</p>
<pre><code class="language-python">from selenium import webdriver
browser = webdriver.PhantomJS()
browser.get('https://www.baidu.com')
print(browser.current_url)
</code></pre>
<h2 id="aiohttp"><a class="header" href="#aiohttp">aiohttp</a></h2>
<p><a href="https://github.com/aio-libs/aiohttp">aiohttp</a> 是一个异步发送 http 请求的 python 库，<a href="https://aiohttp.readthedocs.io/en/stable/">英文文档</a>，采用异步机制，效率大大提高。</p>
<pre><code>pip3 install aiohttp
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3爬虫开发----解析库"><a class="header" href="#python3爬虫开发----解析库">Python3爬虫开发 -- 解析库</a></h1>
<p><a href="https://github.com/lxml/lxml">lxml</a> 支持 HTML、XML 解析，支持 XPath 解析方式。</p>
<pre><code>pip3 install lxml
</code></pre>
<p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc">Beautiful Soup</a> 支持 HTML、XML 解析，API 强大，解析方法多，依赖前面的 lxml。</p>
<pre><code>pip3 install beautifulsoup4
</code></pre>
<pre><code class="language-python">import urllib.request as request
from bs4 import BeautifulSoup

if __name__ == &quot;__main__&quot;:
    try:
        resp = request.urlopen(url=&quot;http://www.btbtdy.me/hot/month/&quot;)
        resp = request.urlopen(url=&quot;http://www.baidu.com&quot;)
    except Exception as e:
        print(str(e))
    else:
        if not resp.readable:
            resp.close()
            exit(0)

        data = resp.read()
        soup = BeautifulSoup(data,features=&quot;html.parser&quot;)
        print(&quot;%s&quot; % soup.title)

    finally:
        None
</code></pre>
<p><a href="https://github.com/gawel/pyquery">pyquery</a> 使用类似 jQuery 的语法解析 HTML。</p>
<pre><code>pip3 install pyquery
</code></pre>
<p><a href="https://github.com/sirfz/tesserocr">tesserocr</a>  是一个 OCR 识别库 <a href="https://github.com/tesseract-ocr/tesseract">tesserac</a> 的 Python API，可以用来识别图片中的文字。</p>
<pre><code>yum install -y tesseract
pip3 install tesserocr pillow
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3爬虫开发----移动端工具"><a class="header" href="#python3爬虫开发----移动端工具">Python3爬虫开发 -- 移动端工具</a></h1>
<p>用于对接 Mysql、Redis 等存储系统的 Python 库就不提了，重点介绍几个抓包和移动端工具，通过这些抓包工具可以抓取 APP 的通信数据，从而分析出协议规则。</p>
<p><a href="https://www.charlesproxy.com">Charles</a> 是一款相当强大的抓包工具，具备代理功能， <a href="https://www.lijiaocn.com/%E6%8A%80%E5%B7%A7/2018/02/05/pkt-capture.html">用charles和Fiddler抓取、破解、改写（请求拦截）PC端、手机移动端通信数据</a> 中有简单介绍。</p>
<p><a href="https://github.com/mitmproxy/mitmproxy">mitmproxy</a> 是一个支持 HTTP 和 HTTPS 抓包的控制台工具。</p>
<p><a href="htttps://github.com/appium/appium">Appium</a> 是移动端的自动化工具，相当于移动端 Selenium，可以驱动 Android、iOS 等移动设备，模拟点击、滑动、输入等操作，非常强大。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="python3爬虫开发----爬虫框架"><a class="header" href="#python3爬虫开发----爬虫框架">Python3爬虫开发 -- 爬虫框架</a></h1>
<p>爬虫框架集成了必须的爬取、解析、提取、存放工具，按照框架规则填写代码即可。</p>
<p><a href="https://github.com/binux/pyspider">pyspider</a> 国人开发的带有 Web 页面的开源爬虫框架。</p>
<p><a href="https://github.com/scrapy/scrapy">Scrapy</a> 是一个强大的爬虫框架，<a href="https://docs.scrapy.org/en/master/intro/overview.html">英文文档</a>、<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/overview.html0">中文文档</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="django开发手册"><a class="header" href="#django开发手册">Django开发手册</a></h1>
<p><a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2014/12/05/Python.html#virutalenv">Python编程入门</a></p>
<p><a href="https://www.djangoproject.com/start/">Getting started with Django</a></p>
<p><a href="https://docs.djangoproject.com/en/2.2/intro/install/">Quick install guide</a></p>
<p><a href="https://docs.djangoproject.com/en/2.2/intro/tutorial01/">Writing your first Django app, part 1</a></p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django环境安装"><a class="header" href="#django环境安装">Django环境安装</a></h1>
<p>确保有python命令和pip命令，python分为python2和python3，建议直接上手<a href="https://docs.python.org/3/contents.html">python3</a>，python2.7是python2的最后一个版本。</p>
<p><a href="https://wiki.python.org/moin/Python2orPython3">Should I use Python 2 or Python 3 for my development activity?</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-port-python-2-code-to-python-3">How To Port Python 2 Code to Python 3 </a></p>
<p>安装virtualenv：</p>
<pre><code>pip install virtualenv
</code></pre>
<p>用virtualenv创建python运行环境：</p>
<pre><code>mkdir django-py3
cd django-py3
virtualenv  -p python3 env
</code></pre>
<p>进入virtualenv创建的python运行环境：</p>
<pre><code>source env/bin/activate
</code></pre>
<p>用pip安装django：</p>
<pre><code>pip install Django
</code></pre>
<p>也可以下载django源代码安装：</p>
<pre><code>git clone https://github.com/django/django.gi
pip install -e django/
</code></pre>
<p>验证django环境：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import django
print(django.get_version())
2.2</p>
</blockquote>
</blockquote>
</blockquote>
<p>或者：</p>
<pre><code>$python -m django --version
2.2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="第一个django项目"><a class="header" href="#第一个django项目">第一个Django项目</a></h1>
<p><a href="https://docs.djangoproject.com/en/2.2/intro/tutorial01/">Writing your first Django app, part 1</a></p>
<h2 id="django项目的创建与目录结构"><a class="header" href="#django项目的创建与目录结构">Django项目的创建与目录结构</a></h2>
<p>创建项目，注意项目名称不能是django和test，避免引发命名冲突:</p>
<pre><code>django-admin startproject mysite
</code></pre>
<p>自动生成的项目文件：</p>
<pre><code class="language-sh">(env) lijiaos-mbp:django-py3 lijiao$ tree mysite/
mysite/
├── manage.py
└── mysite
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py

1 directory, 5 files
</code></pre>
<p><a href="https://docs.djangoproject.com/en/2.2/ref/django-admin/">manage.py</a>是用来管理django项目的命令。</p>
<p><code>mysite/mysite</code>：项目的代码目录，它是一个标准的python package。</p>
<p><code>__init__.py</code>：一个空文件，表示所在目录为python package，<a href="https://docs.python.org/3/tutorial/modules.html#tut-packages">python package说明</a>。</p>
<p><code>settings.py</code>：Django项目的配置文件, <a href="https://docs.djangoproject.com/en/2.2/topics/settings/">Django settings</a>。</p>
<p><code>urls.py</code>：Django项目的url声明，<a href="https://docs.djangoproject.com/en/2.2/topics/http/urls/">URL dispatcher</a>。</p>
<p><code>wsgi.py</code>：面向使用WSGI的web server的入口，<a href="https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/">How to deploy with WSGI</a>。</p>
<h2 id="启动开发模式下的django-server"><a class="header" href="#启动开发模式下的django-server">启动开发模式下的Django Server</a></h2>
<p>开发模式下，可以用下面的方法启动Django Server：</p>
<pre><code>cd mysite
python ./manage.py runserver 0:8080
</code></pre>
<p>这种方式启动的server会自动加载最新的代码，代码变更后不需要重新启动。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="第一个django应用"><a class="header" href="#第一个django应用">第一个Django应用</a></h1>
<p>前面创建了一个Django项目，接下来在项目中创建Django应用。</p>
<h2 id="创建一个名为poll的应用"><a class="header" href="#创建一个名为poll的应用">创建一个名为poll的应用</a></h2>
<p>在Django项目目录中运行下面的命令：</p>
<pre><code>python manage.py startapp polls
</code></pre>
<p>自动生成的polls应用代码如下：</p>
<pre><code class="language-sh">(env) lijiaos-mbp:mysite lijiao$ tree polls/
polls/
├── __init__.py
├── admin.py
├── apps.py
├── migrations
│   └── __init__.py
├── models.py
├── tests.py
└── views.py

1 directory, 7 files
</code></pre>
<h2 id="开发应用的视图"><a class="header" href="#开发应用的视图">开发应用的视图</a></h2>
<p><code>views.py</code>中是应用的视图（views)，视图是与url一一对应的。</p>
<p>例如在views.py中添加一个名为index的视图，它的传入参数就是用户的请求：</p>
<pre><code class="language-python">from django.shortcuts import render

# Create your views here.

from django.http import HttpResponse

def index(request):
    return HttpResponse(&quot;Hello, world. You're at the polls index.&quot;)
</code></pre>
<p>request的类型是<a href="https://docs.djangoproject.com/en/2.2/ref/request-response/">HttpRequest</a>。</p>
<p>需要创建<code>polls/urls.py</code>文件，并在其中添加下面的内容：</p>
<pre><code class="language-python">from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
]
</code></pre>
<p>最后在django项目文件<code>mysite/urls.py</code>中设置polls应用的url：</p>
<pre><code class="language-python">from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('polls/', include('polls.urls')),
    path('admin/', admin.site.urls),
]
</code></pre>
<p>上面设置的含义是<code>/polls/XX</code>样式的请求被转发给polls应用处理，在polls/urls.py中找到对应的处理函数，也就是view。</p>
<p>path函数的定义：<a href="https://docs.djangoproject.com/en/2.2/ref/urls/#django.urls.path">path(route, view, kwargs=None, name=None)</a></p>
<h2 id="访问应用视图"><a class="header" href="#访问应用视图">访问应用视图</a></h2>
<p>用python ./manage.py runserver 启动项目后，访问polls应用的视图<code>/polls/</code>：</p>
<pre><code class="language-sh">$ curl http://127.0.0.1:8000/polls/
Hello, world. You're at the polls index.
</code></pre>
<p>现在应用polls之后一个视图，如果使用其它的url会返回404，即页面没找到的错误：</p>
<pre><code>Page not found (404)
Request Method:	GET
Request URL:	http://127.0.0.1:8000/polls/ab
Using the URLconf defined in mysite.urls, Django tried these URL patterns, in this order:

admin/
polls/ [name='index']
The current path, polls/ab, didn't match any of these.

You're seeing this error because you have DEBUG = True in your Django settings file. Change that to False, and Django will display a standard 404 page.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django对接数据库"><a class="header" href="#django对接数据库">Django对接数据库</a></h1>
<p><a href="https://docs.djangoproject.com/en/2.2/ref/settings/">settings.py</a>是项目的配置文件，其中包含数据库相关的配置。</p>
<h2 id="配置项目的数据库"><a class="header" href="#配置项目的数据库">配置项目的数据库</a></h2>
<p>项目的数据库在项目目录中的settings.py中设置，数据库相关的<a href="https://docs.djangoproject.com/en/2.2/ref/settings/#databases">配置样式</a>如下：</p>
<pre><code class="language-python"># Database
# https://docs.djangoproject.com/en/2.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
</code></pre>
<p><code>ENGINE</code>是数据库类型，Django支持以下四种数据库：</p>
<pre><code>'django.db.backends.postgresql'
'django.db.backends.mysql'
'django.db.backends.sqlite3'
'django.db.backends.oracle'
</code></pre>
<p>默认使用sqlite，这是一个文件数据库，只需要在<code>NAME</code>参数指定数据库文件，如果用其它类型的数据库还需要指定<code>NAME</code>、<code>USER</code>、<code>PASSWORD</code>等参数，例如：</p>
<pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
</code></pre>
<p>数据库需要提前部署创建，根据自己的实际情况选择合适的数据库。只需要创建数据库不需要创建表，数据库表在下一节中用Django代码定义，并自动完成创建。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django数据库初始化"><a class="header" href="#django数据库初始化">Django数据库初始化</a></h1>
<p>Django 支持直接在代码中定义数据库的表结构，然后用 django 命令完成数据库的初始化，不需要写 sql 语句。在 Django 中一个数据库表对应一个 Model。</p>
<h2 id="创建-model"><a class="header" href="#创建-model">创建 Model</a></h2>
<p>Model 的定义文件 models.py 位于 Django 应用目录中，在 models.py 中为每张数据库表创建一个对应的类：</p>
<pre><code class="language-python">from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
</code></pre>
<p>上面的创建的两个类 Question 和 Choice，分别对应同名的数据库表，类成员对应表中的字段。</p>
<p>需要特别关注的是每个字段的类型，<code>models.IntegerField</code>、<code>models.CharField</code>分别对应不同的数据库表字段类型，并且通过传入参数控制字段的特性。</p>
<p>Models 可以说是 Django 中最重要的部分，Django 文档中有 <a href="https://docs.djangoproject.com/en/2.2/topics/db/models/">Models 的专题介绍</a>，内容比较多。</p>
<h2 id="类型成员类型与数据库字段类型"><a class="header" href="#类型成员类型与数据库字段类型">类型成员类型与数据库字段类型</a></h2>
<pre><code class="language-python"># 定长字符串
stock = models.CharField(max_length=20)

# 不定长字符串
main_content = models.TextField()

# 整数
votes = models.IntegerField(default=0)

# 时间
update_date = models.TimeField(null=False)
</code></pre>
<h2 id="field-options"><a class="header" href="#field-options">Field Options</a></h2>
<p>Field Options 是在声明类成员时传入的参数（例如 max_length=20），<a href="https://docs.djangoproject.com/en/2.2/topics/db/models/#field-options" title="Django Model Field options">Django Model Field options</a> 列出了 Django 支持的所有 Field Options。</p>
<p>例如：</p>
<pre><code class="language-python"># 声明为主键
index_id = models.CharField(max_length=40,null=False, primary_key=True)
</code></pre>
<h2 id="在-meta-中设置联合主键等属性"><a class="header" href="#在-meta-中设置联合主键等属性">在 Meta 中设置联合主键等属性</a></h2>
<p>在 Model 的子类中，也就是上面 Question 等类中，添加一个 Meta 类，覆盖父类中的对应设置。Meta 类的属性在 <a href="https://docs.djangoproject.com/en/2.2/ref/models/options/">Model Meta options</a> 中可以找到，其中 <a href="https://docs.djangoproject.com/en/2.2/ref/models/options/#unique-together">unique-together</a> 是用来设置联合主键的，如下：</p>
<pre><code class="language-python">class Movie(models.Model):
    name = models.CharField(max_length=200)
    site = models.CharField(max_length=50)
    page_url = models.TextField()
    cover_url = models.TextField()
    description = models.TextField()
    description_extra = models.TextField()
    date = models.CharField(max_length=50)
    class Meta:
        unique_together = ['name', 'site']
</code></pre>
<h2 id="激活-model"><a class="header" href="#激活-model">激活 Model</a></h2>
<blockquote>
<p>这里以 Django 应用 poll 为例，它在 <a href="django/./first-app.html">第一个Django应用</a> 中创建。</p>
</blockquote>
<p>如果使用的是 mysql 数据库，需要安装 mysqlclient（安装时如果报错 ld: library not found for -lssl...command 'clang' failed with exit status 1，是因为没有找到 ssl 连接库）：</p>
<pre><code class="language-sh">export LDFLAGS=&quot;-L/usr/local/opt/openssl/lib&quot;
export CPPFLAGS=&quot;-I/usr/local/opt/openssl/include&quot;
pip install mysqlclient
</code></pre>
<p>在 models.py 中定义的 Model 不会立即生效，首先要在项目的 settings.py 中引入应用的配置：</p>
<pre><code class="language-python">INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'polls.apps.PollsConfig',
]
</code></pre>
<p>然后运行下面的命令，将应用 polls 中定义的 Model 刷到数据库中，即创建对应的数据库表：</p>
<pre><code class="language-sh">python manage.py makemigrations polls
python manage.py migrate
</code></pre>
<p>如果没有在 settings.py 中引入应用 polls，会遇到下面的错误：</p>
<pre><code class="language-sh">(env) lijiaos-mbp:mysite lijiao$ python manage.py makemigrations polls
No installed app with label 'polls'.
</code></pre>
<p>激活时使用的第一个命令是 <code>makemigrations polls</code>，生成对应的数据库初始化文件 polls/migrations/0001_initial.py：</p>
<pre><code class="language-sh">(env) 192:mysite lijiao$ python manage.py makemigrations polls
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Question
    - Create model Choice
</code></pre>
<p>第二个命令<code>migrate</code>是将所有还没有应用到数据库中变更刷到数据库中：</p>
<pre><code class="language-sh">(env) 192:mysite lijiao$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying polls.0001_initial... OK
  Applying sessions.0001_initial... OK
</code></pre>
<p>可以用下面的命令查看对应的SQL语句：</p>
<pre><code class="language-sh">python manage.py sqlmigrate polls 0001
</code></pre>
<h2 id="更新-model"><a class="header" href="#更新-model">更新 Model</a></h2>
<p>在 models.py 中修改了 Model 的定义之后，重新执行下面的命令，就会将最新的定义刷新到数据库中：</p>
<pre><code class="language-sh">python manage.py makemigrations polls
python manage.py migrate
</code></pre>
<h2 id="参考-46"><a class="header" href="#参考-46">参考</a></h2>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django数据库查询写入"><a class="header" href="#django数据库查询写入">Django：数据库查询写入</a></h1>
<p>写入新的记录：</p>
<pre><code class="language-python">from movie.models import Movie
...
m = Movie()
m.XXX = XXX
m.save()
</code></pre>
<p>查询记录：</p>
<pre><code class="language-python">m = Movie.objects.get(name=i.name,site=i.site)
m = Movie.objects.get(name=i.name,site=i.site)
</code></pre>
<p>条件查询，<a href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/" title="Django: QuerySet API reference">QuerySet API reference</a>：</p>
<pre><code class="language-python">items = Movie.objects.filter()
items = Movie.objects.filter().order_by('name')
</code></pre>
<p>查询结果排序：</p>
<pre><code class="language-python">from django.db.models.functions import Coalesce

items = Question.objects.filter(market=&quot;sz&quot;).order_by(Coalesce('stock_code', 'answer_date').desc())
</code></pre>
<h2 id="参考-47"><a class="header" href="#参考-47">参考</a></h2>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="在命令行操作数据库"><a class="header" href="#在命令行操作数据库">在命令行操作数据库</a></h1>
<p>Django提供了一个<a href="https://docs.djangoproject.com/en/2.2/intro/tutorial02/#playing-with-the-api">shell命令</a>，可以直接和数据库交互：</p>
<pre><code class="language-sh">python manage.py shell
</code></pre>
<p>这个命令实际上是启动了python，并导入了django项目，从而可以直接引用Django的项目代码，尽进行操作，例如：</p>
<pre><code class="language-sh">(env) 192:mysite lijiao$ python manage.py shell
Python 3.7.2 (default, Feb 12 2019, 08:15:36)
[Clang 10.0.0 (clang-1000.11.45.5)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
(InteractiveConsole)
&gt;&gt;&gt; from polls.models import Choice, Question
&gt;&gt;&gt; Question.objects.all()
&lt;QuerySet []&gt;
&gt;&gt;&gt; from django.utils import timezone
&gt;&gt;&gt; q = Question(question_text=&quot;What's new?&quot;, pub_date=timezone.now())
&gt;&gt;&gt; q.save()
&gt;&gt;&gt; q.id
1
&gt;&gt;&gt; q.question_text
&quot;What's new?&quot;
&gt;&gt;&gt; q.pub_date
datetime.datetime(2019, 4, 5, 7, 20, 13, 842645, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; q.question_text = &quot;What's up?&quot;
&gt;&gt;&gt; q.save()
&gt;&gt;&gt; Question.objects.all()
&lt;QuerySet [&lt;Question: Question object (1)&gt;]&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django创建站点管理后台"><a class="header" href="#django创建站点管理后台">Django创建站点管理后台</a></h1>
<p>Django提供了<a href="https://docs.djangoproject.com/en/2.2/intro/tutorial02/#creating-an-admin-user">后台管理模版</a>，可以直接创建网站后台，减少开发工作.</p>
<h2 id="创建管理员账号"><a class="header" href="#创建管理员账号">创建管理员账号</a></h2>
<p>在前面设置第一个应用polls的时候，应该注意到项目目录的urls.py中是有一个admin/路径的，访问该路径时（<code>http://127.0.0.1:8000/admin/</code>），会看到一个<code>Django administration</code>的登录页面。</p>
<p>还没有管理员账号的时候需要用manager.py创建一个：</p>
<pre><code class="language-sh">python manage.py createsuperuser
</code></pre>
<p>设置过程如下：</p>
<pre><code class="language-sh">(env) 192:mysite lijiao$ python manage.py createsuperuser
Username (leave blank to use 'lijiao'): admin
Email address: admin@example.com
Password:   # 这里输入密码
Password (again):
This password is too short. It must contain at least 8 characters.
This password is too common.
This password is entirely numeric.
Bypass password validation and create user anyway? [y/N]: y
Superuser created successfully.
</code></pre>
<p>然后就可以用新创建的用户名和密码登录Django后台了。</p>
<h2 id="在后台中添加应用页面"><a class="header" href="#在后台中添加应用页面">在后台中添加应用页面</a></h2>
<p>Django的后台其实就是一个数据库网页，可以在里面直接操作数据库中的数据，默认情况下里面只有了Groups和Users的数据，应用的数据不在其中。</p>
<p>如果要在Django后台中管理应用，需要在应用的admin.py中注册对应的Model，例如在polls/admin.py中注册Question：</p>
<pre><code class="language-python">from django.contrib import admin

# Register your models here.

from .models import Question

admin.site.register(Question)
</code></pre>
<p>代码添加之后，刷新后台就会看到多出了一个Question页面，可以查看编辑里面的数据。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django中view的创建"><a class="header" href="#django中view的创建">Django中view的创建</a></h1>
<p>view就是一个一个页面，前面在创建应用的时候创建了一个简单的index view。这里演示更多view的用法。每个view有一个独立无二的url，对应一个python函数，这个python函数负责渲染页面并返回给请求端。</p>
<p>urls和views的对应关系用<a href="https://docs.djangoproject.com/en/2.2/topics/http/urls/">URL dispatcher</a>描述。</p>
<h2 id="带路径参数的views"><a class="header" href="#带路径参数的views">带路径参数的views</a></h2>
<p>在Django应用polls的views.py中创建几个带有传入参数的views：</p>
<pre><code class="language-python">def detail(request, question_id):
    return HttpResponse(&quot;You're looking at question %s.&quot; % question_id)

def results(request, question_id):
    response = &quot;You're looking at the results of question %s.&quot;
    return HttpResponse(response % question_id)

def vote(request, question_id):
    return HttpResponse(&quot;You're voting on question %s.&quot; % question_id)
</code></pre>
<p>注意这几个views的传入参数除了request，还有一个question_id，question_id是从url中解析出来的，是在设置urls和views的对应关系是设定的，例如，在polls/urls.py中设置如下：</p>
<pre><code class="language-python">from django.urls import path

from . import views

urlpatterns = [
    # ex: /polls/
    path('', views.index, name='index'),
    # ex: /polls/5/
    path('&lt;int:question_id&gt;/', views.detail, name='detail'),
    # ex: /polls/5/results/
    path('&lt;int:question_id&gt;/results/', views.results, name='results'),
    # ex: /polls/5/vote/
    path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),
]
</code></pre>
<p>urls中的<code>&lt;int:question_id&gt;</code>就是解析给question_id的数值，类型是int。</p>
<p>在url中带的参数，被解析给view的参数，然后在view的处理函数中被返回，例如：</p>
<pre><code>$ curl 127.0.0.1:8000/polls/3/
You're looking at question 3.

$ curl 127.0.0.1:8000/polls/3/results/
You're looking at the results of question 3.

$ curl 127.0.0.1:8000/polls/3/vote/
You're voting on question 3.
</code></pre>
<h2 id="views中的准备响应数据"><a class="header" href="#views中的准备响应数据">views中的准备响应数据</a></h2>
<p>views最终要返回一个HttpResponse类型的变量或者抛出Http404等异常，在views对应的函数中，可以用各种方式生成要返回的数据，譬如读取数据库、通过运算计算出等。</p>
<p>例如把index的view进行扩展，返回从数据库中查询到数据：</p>
<pre><code class="language-python">from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    output = ', '.join([q.question_text for q in latest_question_list])
    return HttpResponse(output)
</code></pre>
<p>这个views方法的实现同时演示了在Django中如何引用models，并通过models查询数据库。</p>
<h2 id="views中使用页面模版"><a class="header" href="#views中使用页面模版">views中使用页面模版</a></h2>
<p>前面的几个views都是硬编码了返回的数据，没有数据和样式分开，这样会导致要修改返回的数据的样式时，必须修改代码。可以用页面模版(templates)功能将数据和样式分开。</p>
<p>Django项目的<a href="https://docs.djangoproject.com/en/2.2/ref/settings/#std:setting-TEMPLATES">settings.py</a>中配置了页面模版类型，例如：</p>
<pre><code class="language-python">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'APP_DIRS': True,
    },
]
</code></pre>
<p>Django支持的页面模版有：</p>
<pre><code>'django.template.backends.django.DjangoTemplates'
'django.template.backends.jinja2.Jinja2'
</code></pre>
<p>页面模版文件默认位于Django应用的templates目录中，创建一个页面模版文件polls/templates/polls/index.html：</p>
<pre><code class="language-django">{% if latest_question_list %}
    &lt;ul&gt;
    {% for question in latest_question_list %}
        &lt;li&gt;&lt;a href=&quot;/polls/{{ question.id }}/&quot;&gt;{{ question.question_text }}&lt;/a&gt;&lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
{% else %}
    &lt;p&gt;No polls are available.&lt;/p&gt;
{% endif %}
</code></pre>
<p>页面模版文件中可以进行逻辑判断，根据传入的参数值生成不同的内容。</p>
<p>然后在views中加载页面模版文件，并在渲染后返回：</p>
<pre><code class="language-python">from django.http import HttpResponse
from django.template import loader

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls/index.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))
</code></pre>
<p>这时候请求index view，返回下面的数据：</p>
<pre><code class="language-sh">$ curl http://127.0.0.1:8000/polls/

    &lt;ul&gt;

        &lt;li&gt;&lt;a href=&quot;/polls/1/&quot;&gt;What&amp;#39;s up?&lt;/a&gt;&lt;/li&gt;

    &lt;/ul&gt;
</code></pre>
<p>可以用render()函数简化views中的代码：</p>
<pre><code class="language-python">from django.shortcuts import render

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)
</code></pre>
<h2 id="views中抛出404异常"><a class="header" href="#views中抛出404异常">views中抛出404异常</a></h2>
<p>当没有找到对应的数据时，抛出404异常：</p>
<pre><code class="language-python">from django.http import Http404
from django.shortcuts import render

from .models import Question

def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404(&quot;Question does not exist&quot;)
    return render(request, 'polls/detail.html', {'question': question})
</code></pre>
<p>可以用<code>get_object_or_404()</code>函数简化代码：</p>
<pre><code class="language-python">from django.shortcuts import get_object_or_404, render

from .models import Question
# ...
def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': question})
</code></pre>
<p>对应的模版文件polls/detail.html：</p>
<pre><code class="language-django">&lt;h1&gt;{{ question.question_text }}&lt;/h1&gt;
&lt;ul&gt;
{% for choice in question.choice_set.all %}
    &lt;li&gt;{{ choice.choice_text }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</code></pre>
<h2 id="去掉模版文件中硬编码"><a class="header" href="#去掉模版文件中硬编码">去掉模版文件中硬编码</a></h2>
<p>前面使用的模版文件中，有对url的硬编码，例如：</p>
<pre><code class="language-django">&lt;li&gt;&lt;a href=&quot;/polls/{{ question.id }}/&quot;&gt;{{ question.question_text }}&lt;/a&gt;&lt;/li&gt;
</code></pre>
<p>这样会降低模版文件的自适应能力，可以用urls.py中的定义动态生成路径，例如：</p>
<pre><code class="language-django">&lt;li&gt;&lt;a href=&quot;{% url 'detail' question.id %}&quot;&gt;{{ question.question_text }}&lt;/a&gt;&lt;/li&gt;
</code></pre>
<p>href的值是名为detail的view对应的url，url路径参数的值是question.id。</p>
<p>这样一来，更改view对应的url时，只需要在urls.py中修改，不需要改变页面模版文件。</p>
<h2 id="为url设置namespace"><a class="header" href="#为url设置namespace">为url设置namespace</a></h2>
<p>Django项目中可能有多个Django应用，每个应用都会定义自己的views，以及对应的urls，不同Django应用的view可能重名，那么要怎样在页面对重名的views进行区分？</p>
<p>答案是在每个应用的urls.py中，定义一个名为app_name的变量，这个变量为urls中添加了一个命名空间，例如polls/urls.py：</p>
<pre><code class="language-python">from django.urls import path

from . import views

app_name = 'polls'
urlpatterns = [
    path('', views.index, name='index'),
    path('&lt;int:question_id&gt;/', views.detail, name='detail'),
    path('&lt;int:question_id&gt;/results/', views.results, name='results'),
    path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),
]

</code></pre>
<p>上面的代码定义了url的命名空间polls，在页面模版中引用对应的views时需要加上<code>poll:</code>前缀：</p>
<pre><code class="language-django">&lt;li&gt;&lt;a href=&quot;{% url 'polls:detail' question.id %}&quot;&gt;{{ question.question_text }}&lt;/a&gt;&lt;/li&gt;
</code></pre>
<h2 id="在views中实现form表单"><a class="header" href="#在views中实现form表单">在views中实现form表单</a></h2>
<p>更改detail.html模版，在其中插入一个表单，注意表单中有一个csrf_token，这是django内置支持的CSRF防御机制:</p>
<pre><code class="language-django">&lt;h1&gt;{{ question.question_text }}&lt;/h1&gt;

{% if error_message %}&lt;p&gt;&lt;strong&gt;{{ error_message }}&lt;/strong&gt;&lt;/p&gt;{% endif %}

&lt;form action=&quot;{% url 'polls:vote' question.id %}&quot; method=&quot;post&quot;&gt;
{% csrf_token %}
{% for choice in question.choice_set.all %}
    &lt;input type=&quot;radio&quot; name=&quot;choice&quot; id=&quot;choice{{ forloop.counter }}&quot; value=&quot;{{ choice.id }}&quot;&gt;
    &lt;label for=&quot;choice{{ forloop.counter }}&quot;&gt;{{ choice.choice_text }}&lt;/label&gt;&lt;br&gt;
{% endfor %}
&lt;input type=&quot;submit&quot; value=&quot;Vote&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>在接收表单请求的views中处理表单数据：</p>
<pre><code class="language-python">from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse

from .models import Choice, Question
# ...
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': &quot;You didn't select a choice.&quot;,
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django-generic-view的使用"><a class="header" href="#django-generic-view的使用">Django Generic View的使用</a></h1>
<p>使用Django Generic Views可以减少大量代码。</p>
<h2 id="generic-views方式中url定义"><a class="header" href="#generic-views方式中url定义">Generic Views方式中url定义</a></h2>
<pre><code class="language-python">from django.urls import path

from . import views

app_name = 'polls'
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('&lt;int:pk&gt;/', views.DetailView.as_view(), name='detail'),
    path('&lt;int:pk&gt;/results/', views.ResultsView.as_view(), name='results'),
    path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),
]
</code></pre>
<p>注意前三个path的第二个参数和以前不同，它们是继承了generic中的类的对象，在应用的views.py中定义。</p>
<h2 id="generic-views方式中view的定义"><a class="header" href="#generic-views方式中view的定义">Generic Views方式中view的定义</a></h2>
<pre><code class="language-python">from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.views import generic

from .models import Choice, Question


class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        &quot;&quot;&quot;Return the last five published questions.&quot;&quot;&quot;
        return Question.objects.order_by('-pub_date')[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'


class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'


def vote(request, question_id):
    ... # same as above, no changes needed.
</code></pre>
<p>这里用到的<a href="https://docs.djangoproject.com/en/2.2/ref/class-based-views/generic-display/#django.views.generic.list.ListView">generic.ListView</a>和<a href="https://docs.djangoproject.com/en/2.2/ref/class-based-views/generic-display/#django.views.generic.detail.DetailView">generic.DetailView</a>是两个通用的view，分别用来渲染列表和Python对象。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django应用的测试代码编写"><a class="header" href="#django应用的测试代码编写">Django应用的测试代码编写</a></h1>
<p>测试代码在Django应用的tests.py文件中编写，Django提供一个名为TestCase的类。</p>
<h2 id="测试用例1刷入错误数据检查输出"><a class="header" href="#测试用例1刷入错误数据检查输出">测试用例1：刷入错误数据，检查输出</a></h2>
<pre><code class="language-python">from django.test import TestCase

# Create your tests here.

import datetime
from django.utils import timezone
from .models import Question

class QuestionModelTests(TestCase):
    def test_was_published_recently_with_future_question(self):
        &quot;&quot;&quot;
        was_published_recently() returns False for questions whose pub_date
        is in the future.
        &quot;&quot;&quot;
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertIs(future_question.was_published_recently(), False)
</code></pre>
<p>运行下面的命令进行测试：</p>
<pre><code class="language-sh">python ./manage.py test polls
</code></pre>
<p>如果测试不通过，输出内容如下：</p>
<pre><code class="language-python">Creating test database for alias 'default'...
System check identified no issues (0 silenced).
F
======================================================================
FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;/Users/lijiao/Work/workspace/studys/study-python/django/django-py3/mysite/polls/tests.py&quot;, line 17, in test_was_published_recently_with_future_question
    self.assertIs(future_question.was_published_recently(), False)
AssertionError: True is not False

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
Destroying test database for alias 'default'...
</code></pre>
<p>测试通过时输出内容如下：</p>
<pre><code class="language-python">(env) 192:mysite lijiao$ python ./manage.py test polls
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
</code></pre>
<h2 id="测试用例2测试view"><a class="header" href="#测试用例2测试view">测试用例2：测试view</a></h2>
<p>Django提供了一个测试用的client，可以模拟用户发起请求，可以在test.py中或者shell中使用这个client。</p>
<h3 id="在命令行使用测试用的client"><a class="header" href="#在命令行使用测试用的client">在命令行使用测试用的Client</a></h3>
<pre><code class="language-shell">(env) 192:mysite lijiao$ python manage.py shell
Python 3.7.2 (default, Feb 12 2019, 08:15:36)
[Clang 10.0.0 (clang-1000.11.45.5)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
(InteractiveConsole)
&gt;&gt;&gt; from django.test.utils import setup_test_environment
&gt;&gt;&gt; setup_test_environment()
&gt;&gt;&gt; from django.test import Client
&gt;&gt;&gt; client = Client()
&gt;&gt;&gt; response = client.get('/')
Not Found: /
&gt;&gt;&gt; response.status_code
404
&gt;&gt;&gt; from django.urls import reverse
&gt;&gt;&gt;
&gt;&gt;&gt; response = client.get(reverse('polls:index'))
&gt;&gt;&gt; response.status_code
200
&gt;&gt;&gt; response.content
b'\n    &lt;ul&gt;\n    \n        &lt;li&gt;&lt;a href=&quot;/polls/1/&quot;&gt;What&amp;#39;s up?&lt;/a&gt;&lt;/li&gt;\n    \n    &lt;/ul&gt;\n\n'
&gt;&gt;&gt; response.context['latest_question_list']
&lt;QuerySet [&lt;Question: What's up?&gt;]&gt;
&gt;&gt;&gt;
</code></pre>
<h3 id="在testspy中使用测试用的client"><a class="header" href="#在testspy中使用测试用的client">在tests.py中使用测试用的Client</a></h3>
<p>在tests.py中写入数据后，再用Client请求查看返回的数据是否正确：</p>
<pre><code class="language-python">def create_question(question_text, days):
    &quot;&quot;&quot;
    Create a question with the given `question_text` and published the
    given number of `days` offset to now (negative for questions published
    in the past, positive for questions that have yet to be published).
    &quot;&quot;&quot;
    time = timezone.now() + datetime.timedelta(days=days)
    return Question.objects.create(question_text=question_text, pub_date=time)


class QuestionIndexViewTests(TestCase):
    def test_no_questions(self):
        &quot;&quot;&quot;
        If no questions exist, an appropriate message is displayed.
        &quot;&quot;&quot;
        response = self.client.get(reverse('polls:index'))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, &quot;No polls are available.&quot;)
        self.assertQuerysetEqual(response.context['latest_question_list'], [])

    def test_past_question(self):
        &quot;&quot;&quot;
        Questions with a pub_date in the past are displayed on the
        index page.
        &quot;&quot;&quot;
        create_question(question_text=&quot;Past question.&quot;, days=-30)
        response = self.client.get(reverse('polls:index'))
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['&lt;Question: Past question.&gt;']
        )

    def test_future_question(self):
        &quot;&quot;&quot;
        Questions with a pub_date in the future aren't displayed on
        the index page.
        &quot;&quot;&quot;
        create_question(question_text=&quot;Future question.&quot;, days=30)
        response = self.client.get(reverse('polls:index'))
        self.assertContains(response, &quot;No polls are available.&quot;)
        self.assertQuerysetEqual(response.context['latest_question_list'], [])

    def test_future_question_and_past_question(self):
        &quot;&quot;&quot;
        Even if both past and future questions exist, only past questions
        are displayed.
        &quot;&quot;&quot;
        create_question(question_text=&quot;Past question.&quot;, days=-30)
        create_question(question_text=&quot;Future question.&quot;, days=30)
        response = self.client.get(reverse('polls:index'))
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['&lt;Question: Past question.&gt;']
        )

    def test_two_past_questions(self):
        &quot;&quot;&quot;
        The questions index page may display multiple questions.
        &quot;&quot;&quot;
        create_question(question_text=&quot;Past question 1.&quot;, days=-30)
        create_question(question_text=&quot;Past question 2.&quot;, days=-5)
        response = self.client.get(reverse('polls:index'))
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['&lt;Question: Past question 2.&gt;', '&lt;Question: Past question 1.&gt;']
        )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="在django页面模版中引入静态资源"><a class="header" href="#在django页面模版中引入静态资源">在Django页面模版中引入静态资源</a></h1>
<p>Django默认到应用的static子目录中查找静态资源。</p>
<pre><code>mkdir polls/static
</code></pre>
<h2 id="创建一个静态的css文件"><a class="header" href="#创建一个静态的css文件">创建一个静态的css文件</a></h2>
<p>创建一个css文件，polls/static/polls/style.css：</p>
<pre><code class="language-css">li a {
    color: green;
}
</code></pre>
<p>在页面模版中用load命令引用：</p>
<pre><code class="language-django">{% load static %}

&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{% static 'polls/style.css' %}&quot;&gt;
</code></pre>
<p>需要注意的是，这时候要重启Django server，否则会找不到静态文件：</p>
<pre><code class="language-sh">python manage.py runserver
</code></pre>
<h2 id="引用静态图片"><a class="header" href="#引用静态图片">引用静态图片</a></h2>
<p>引用其它静态文件时用的都是相对当前文件所在目录的路径，例如对于polls/static/polls/images/backgroud.gif，在polls/static/polls/style.css中引用时，用的路径是:images/background.gif。</p>
<pre><code class="language-css">body {
    background: white url(&quot;images/background.gif&quot;) no-repeat;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django传入参数的获取"><a class="header" href="#django传入参数的获取">Django传入参数的获取</a></h1>
<p>在views的开发一节中讲过，url路径参数可以django直接解析，并作为参数传入views的处理函数。但只有路径参数是不够的，http发起的GET请求是有参数的，以及POST请求提交的body数据都需要解析。</p>
<h2 id="请求参数"><a class="header" href="#请求参数">请求参数</a></h2>
<p>views函数中第一个参数类型是<a href="https://docs.djangoproject.com/en/2.2/ref/request-response/" title="Django Request and response objects">HttpRequest</a>，可以从这个参数中解析所有的请求信息。</p>
<p><strong>HttpRequest.GET</strong>就是GET请求中的所有参数，它的类型是<a href="https://docs.djangoproject.com/en/2.2/ref/request-response/#querydict-objects" title="QueryDict objects">QueryDict objects</a>。</p>
<p>可以用下面的方式读取参数值，如果参数不存在使用default值：</p>
<pre><code class="language-python">signature = request.GET.get('signature', default='')
timestamp = request.GET.get('timestamp',default='')
nonce = request.GET.get('nonce',default='')
echostr = request.GET.get('echostr',default='')
</code></pre>
<p>也可以用map的形式获取，如果参数不存在，会抛出异常：</p>
<pre><code class="language-python">try:
    signature = request.GET['signature']
    timestamp = request.GET['timestamp']
    nonce = request.GET['nonce']
    echostr = request.GET['echostr']
except Exception as err:
    raise Http404(&quot;parameter error&quot;)
</code></pre>
<p>异常的具体类型是django.utils.datastructures.MultiValueDictKeyError，它是Python标准异常KeyError的子类。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django的日志管理"><a class="header" href="#django的日志管理">Django的日志管理</a></h1>
<p>Django的日志在项目的settings.py中配置[LOGGING][1]。</p>
<h2 id="django中使用logging"><a class="header" href="#django中使用logging">Django中使用logging</a></h2>
<p>在项目的settings.py中进行如下配置：</p>
<pre><code class="language-python">LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': '/path/to/django/debug.log',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
}
</code></pre>
<p>然后就可以在Django应用中直接使用logging：</p>
<pre><code class="language-python">import logging

logger = logging.getLogger(__name__)

def auth(request):
    logger.info(&quot;this is log&quot;)
</code></pre>
<p>这时候只能打印出django模块的日志，上面的“this is log”不会出现日志中，这是因为上面的settings.py中只配置了django，还需要加上我们自己的django应用:</p>
<pre><code>'loggers': {
    'django': {
        'handlers': ['file'],
        'level': 'DEBUG',
        'propagate': True,
    },
    'polls': {
        'handlers': ['file'],
        'level': 'DEBUG',
        'propagate': True,
    }
</code></pre>
<h2 id="更复杂的logging配置"><a class="header" href="#更复杂的logging配置">更复杂的logging配置</a></h2>
<p>logging的灵活，下面是一个比较复杂的logging配置：</p>
<pre><code class="language-python">LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'filters': {
        'special': {
            '()': 'project.logging.SpecialFilter',
            'foo': 'bar',
        },
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {
        'console': {
            'level': 'INFO',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler',
            'filters': ['special']
        }
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'propagate': True,
        },
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': False,
        },
        'myproject.custom': {
            'handlers': ['console', 'mail_admins'],
            'level': 'INFO',
            'filters': ['special']
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="使用django项目的settingspy中的全局变量"><a class="header" href="#使用django项目的settingspy中的全局变量">使用Django项目的settings.py中的全局变量</a></h1>
<pre><code class="language-python">from django.conf import settings

print(settings.WECHAT_TOKEN)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django使用过程遇到的问题"><a class="header" href="#django使用过程遇到的问题">Django使用过程遇到的问题</a></h1>
<h2 id="lookuperror-no-installed-app-with-label-admin"><a class="header" href="#lookuperror-no-installed-app-with-label-admin">LookupError: No installed app with label 'admin'.</a></h2>
<p>一个空的Django项目运行时直接报错：<code>LookupError: No installed app with label 'admin'.</code>。</p>
<p>Django版本是2.2，出现这个错误原因是系统上的sqlite版本太低，低于django2.2的要求：</p>
<pre><code>  File &quot;/root/discount/env/lib/python3.6/site-packages/django/db/backends/sqlite3/base.py&quot;, line 66, in &lt;module&gt;
    check_sqlite_version()
  File &quot;/root/discount/env/lib/python3.6/site-packages/django/db/backends/sqlite3/base.py&quot;, line 63, in check_sqlite_version
    raise ImproperlyConfigured('SQLite 3.8.3 or later is required (found %s).' % Database.sqlite_version)
django.core.exceptions.ImproperlyConfigured: SQLite 3.8.3 or later is required (found 3.7.17).
</code></pre>
<p>在settings.py配置配置其它数据库，比如mysql，不要使用sqlite，或者将本地的sqlite升级。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="idea远程调试python"><a class="header" href="#idea远程调试python">IDEA远程调试python</a></h1>
<p>Tools-&gt;Deployment-&gt;Configuration，在弹出的窗口中添加远程Server，根据需要选择FTP或者SFTP协议，这里使用SFTP。</p>
<p>添加远程server之后，先不要关闭窗口，到<code>Mapping</code>选项卡中，设置一下远程路径，代码将被上传到远程服务器的指定目录中。</p>
<p>远程机器上需要设置SFTP，sshd默认就启用了sftp，可以用下面的命令验证以下：</p>
<pre><code>sftp root@SERVER_ADDR
</code></pre>
<p>如果在IntellJ Ideal中Test SFTP Connection总是失败，在shell中执行下面的命令（认证方式选择OpenSSH config and authentication agent的时候）：</p>
<pre><code>ssh-add ~/.ssh/id_rsa
</code></pre>
<p><a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000808830-SFTP-Connection-Failed">SFTP Connection Failed</a></p>
<p>Test SFTP Connection成功之后，点进Tools-&gt;Deployment-&gt;Upload to XXX，将代码上传到指定的服务器。</p>
<p>也可以在左侧的目录中选择要上传的目录，然后点击右键，选择Deployment-&gt;Upload to XXX。</p>
<p>鼠标在编辑窗口中是，按下shift+alt+command+x，会弹出服务器列表，选中之后就直接将当前文件上传了。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="在django项目自定义package"><a class="header" href="#在django项目自定义package">在Django项目自定义Package</a></h1>
<p>一些常用的代码可以做成Package，从而可以在多个地方复用，在Django项目代码中可以直接应用自定义的Package。</p>
<h2 id="在django项目中创建pakcage"><a class="header" href="#在django项目中创建pakcage">在Django项目中创建Pakcage</a></h2>
<p>在Django项目的目录如下，子目录mysite是django项目的配置package，wechat是Django应用。</p>
<pre><code>▾ mysite/
  ▸ mysite/
  ▸ wechat/
    __init__.py
    manage.py*
</code></pre>
<p>在Django的目录中创建一个wechatsdk的package，wechatsdk目录中要有<code>__init__.py</code>文件：</p>
<pre><code>▾ mysite/
  ▸ mysite/
  ▸ wechat/
  ▸ wechatsdk/
      __init__.py
      auth.py
      msgtype.py
    __init__.py
    manage.py*
</code></pre>
<p>然后就可以在Django应用引用wechatsdk里，例如在Django应用wechat/views.py中引用wechatsdk：</p>
<pre><code class="language-python">from wechatsdk import msgtype
from wechatsdk import auth
</code></pre>
<p>在用“python ./manager.py runserver”启动Django服务的时候，会从当前目录中查找package，因此wechatsdk能够被找到。如果IDE IntellJ Idea要正确地找到wechatsdk，项目的根目录需要是wechatsdk的父目录mysite，可以在File-&gt;Project Structure -&gt; Modules中修改Content Root。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="用wsgi方式部署django服务"><a class="header" href="#用wsgi方式部署django服务">用WSGI方式部署Django服务</a></h1>
<p>Django的主要部署平台是WSGI，WSGI是python的web服务和应用标准，文档<a href="https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/" title="How to deploy with WSGI">How to deploy with WSGI</a>中介绍了四种方式：使用mod_swgi模块的Apache，Gunicorn、uWSGI。</p>
<h2 id="指定配置文件"><a class="header" href="#指定配置文件">指定配置文件</a></h2>
<p>Django项目中的wsgi.py就是支持WSGI的web server要加载的应用入口文件。wsgi.py中要设置环境变量<code>DJANGO_SETTINGS_MODULE</code>，指向Django应用的配置模块，默认是项目目录中mysite/settings.py：</p>
<pre><code class="language-python">os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;mysite.settings&quot;)
</code></pre>
<p><code>DJANGO_SETTINGS_MODULE</code>的值可以灵活设置，因此可以为生产环境、测试开发环境可以使用不同的settings.py文件。</p>
<h2 id="添加wsgi中间件"><a class="header" href="#添加wsgi中间件">添加wsgi中间件</a></h2>
<p>WSGI的一个主要卖点是可以很方便的添加中间处理环节，这个功能叫做<a href="https://www.python.org/dev/peps/pep-3333/#middleware-components-that-play-both-sides" title="WSGI middleware">wsgi middleware</a>，可以将开发的中间价很方便的套在Django应用上，例如：</p>
<pre><code class="language-python">from helloworld.wsgi import HelloWorldApplication
application = get_wsgi_application()
application = HelloWorldApplication(application)
</code></pre>
<p>通过<code>get_wsgi_application()</code>返回的application是原始的Django应用。</p>
<h2 id="wsgi资料"><a class="header" href="#wsgi资料">wsgi资料</a></h2>
<p>wsgi的配置样例，<a href="https://modwsgi.readthedocs.io/en/develop/user-guides/quick-configuration-guide.html" title="Quick Configuration Guide">Quick Configuration Guide</a>：</p>
<pre><code class="language-conf">&lt;VirtualHost *:80&gt;

    ServerName www.example.com
    ServerAlias example.com
    ServerAdmin webmaster@example.com

    DocumentRoot /usr/local/www/documents

    &lt;Directory /usr/local/www/documents&gt;
    &lt;IfVersion &lt; 2.4&gt;
        Order allow,deny
        Allow from all
    &lt;/IfVersion&gt;
    &lt;IfVersion &gt;= 2.4&gt;
        Require all granted
    &lt;/IfVersion&gt;
    &lt;/Directory&gt;

    WSGIScriptAlias /myapp /usr/local/www/wsgi-scripts/myapp.wsgi

    &lt;Directory /usr/local/www/wsgi-scripts&gt;
    &lt;IfVersion &lt; 2.4&gt;
        Order allow,deny
        Allow from all
    &lt;/IfVersion&gt;
    &lt;IfVersion &gt;= 2.4&gt;
        Require all granted
    &lt;/IfVersion&gt;
    &lt;/Directory&gt;

&lt;/VirtualHost&gt;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="在apache中部署django应用"><a class="header" href="#在apache中部署django应用">在Apache中部署Django应用</a></h1>
<p>在apache中部署的时候，需要启用apache的<a href="https://modwsgi.readthedocs.io/en/develop/" title="mod_wsgi">mod_wsgi</a>模块，这个模块用来兼容python的wsgi应用，包括Django。<a href="https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/modwsgi/" title="How to use Django with Apache and mod_wsgi">How to use Django with Apache and mod_wsgi</a>中有详细介绍。</p>
<h2 id="安装apache和mod_wsgi"><a class="header" href="#安装apache和mod_wsgi">安装Apache和mod_wsgi</a></h2>
<p>建议使用第二种方式，安装ius源中python**wsgi。</p>
<h3 id="使用yum直接安装mod_wsgi"><a class="header" href="#使用yum直接安装mod_wsgi">使用yum直接安装mod_wsgi</a></h3>
<p>CentOS中提供了mod_wsgi的安装包，安装的时候会连同依赖的apache（在CentOS中名为httpd）一起安装：</p>
<pre><code class="language-bash">$ yum install -y mod_wsgi
Dependencies Resolved

================================================================================
 Package            Arch          Version                       Repository
                                                                           Size
================================================================================
Installing:
 mod_wsgi           x86_64        3.4-18.el7                    os         77 k
Installing for dependencies:
 apr                x86_64        1.4.8-3.el7_4.1               os        103 k
 apr-util           x86_64        1.5.2-6.el7                   os         92 k
 httpd              x86_64        2.4.6-88.el7.centos           os        2.7 M
 httpd-tools        x86_64        2.4.6-88.el7.centos           os         90 k
 mailcap            noarch        2.1.41-2.el7                  os         31 k
</code></pre>
<p>但是根据<a href="https://stackoverflow.com/questions/41005030/django-apache-and-virtualenv-importerror-no-module-named-site" title="Django Apache and Virtualenv ImportError: No module named site">Django Apache and Virtualenv ImportError: No module named site</a>中的说法，如果wsgi编译时使用的python版本和django应用使用python版本不一致，可能会出现找不到python package的情况：</p>
<pre><code class="language-sh">#日志文件 /var/log/httpd/error_log
ImportError: No module named site
ImportError: No module named site
ImportError: No module named site
ImportError: No module named site
ImportError: No module named site
ImportError: No module named site
</code></pre>
<p><a href="https://pypi.org/project/mod_wsgi/" title="mod_wsgi 4.6.5 ">mod_wsgi</a>中建议使用pip安装，看了一下还是挺麻烦的。<a href="https://stackoverflow.com/questions/41005030/django-apache-and-virtualenv-importerror-no-module-named-site" title="Django Apache and Virtualenv ImportError: No module named site">Django Apache and Virtualenv ImportError: No module named site</a>中的标题为<code>Solved in CentOS 7 with Apache 2.4.6</code>答案中给出的用ius源安装的方法比较方便。</p>
<h3 id="使用ius源中的python36u-mod_wsgi"><a class="header" href="#使用ius源中的python36u-mod_wsgi">使用ius源中的python36u-mod_wsgi</a></h3>
<p>首先安装<a href="https://ius.io/GettingStarted/">ius</a>源：</p>
<pre><code class="language-sh">$ curl https://setup.ius.io/ | bash
</code></pre>
<p>ius源中包含了不同python版本的mod_wsgi：</p>
<pre><code class="language-sh">$ yum search mod_wsgi
python35u-mod_wsgi-debuginfo.x86_64 : Debug information for package python35u-mod_wsgi
python36u-mod_wsgi-debuginfo.x86_64 : Debug information for package python36u-mod_wsgi
koschei-frontend.noarch : Web frontend for koschei using mod_wsgi
mod_wsgi.x86_64 : A WSGI interface for Python web applications in Apache
python35u-mod_wsgi.x86_64 : A WSGI interface for Python web applications in Apache
python36u-mod_wsgi.x86_64 : A WSGI interface for Python web applications in Apache
viewvc-httpd-wsgi.noarch : ViewVC configuration for Apache/mod_wsgi
</code></pre>
<p>我使用的是python3.6，直接安装python36u-mod_wsgi，如果ius里也没有你用的版本，那么就考虑自己编译安装<a href="https://pypi.org/project/mod_wsgi/" title="mod_wsgi 4.6.5 ">mod_wsgi</a>。</p>
<pre><code class="language-sh">yum erase mod_wsgi  # 卸载之前安装的mod_wsgi
yum install -y python36u-mod_wsgi
</code></pre>
<p>安装完成之后会生成文件 /etc/httpd/conf.modules.d/10-wsgi-python3.6.conf，这个就是新安装的apache模块的配置文件。</p>
<h2 id="在httpdconf配置wsgi应用"><a class="header" href="#在httpdconf配置wsgi应用">在httpd.conf配置wsgi应用</a></h2>
<p>Apache和mod_wsgi安装完成之后，在httpd.conf中添加下面的配置（路径根据实际情况配置），可以直接在<code> /etc/httpd/conf/httpd.conf</code>中添加，也可以在<code>/etc/httpd/conf.d/</code>单独创建一个包含下面配置的文件：</p>
<pre><code class="language-conf">WSGIScriptAlias / /path/to/mysite.com/mysite/wsgi.py
WSGIPythonHome /path/to/venv
WSGIPythonPath /path/to/mysite.com

&lt;Directory /path/to/mysite.com/mysite&gt;
&lt;Files wsgi.py&gt;
Require all granted
&lt;/Files&gt;
&lt;/Directory&gt;
</code></pre>
<p><code>WSGIScriptAlias</code>后面紧跟着的是应用的base URL路径，然后是应用的wsgi文件。</p>
<p>如果Django应用使用的是virtualenv创建的运行环境，用<code>WSGIPythonHome</code>指定virtuanenv的路径。</p>
<p><code>WSGIPythonPath</code>指定整个项目的文件目录，是import时的根路径，确保所有的项目文件都在这个目录中。</p>
<p><code>&lt;Directory&gt;</code>中的配置是允许apache读取wsgi.py文件。</p>
<p>Apache2.4以前的版本，需要把<code>Require all granted</code>换成<code>Allow from all</code>。</p>
<p>如果配置不生效，到<code>/var/log/httpd/error_log</code>中找线索。</p>
<h2 id="将mod_wsgi配置成daemon模式"><a class="header" href="#将mod_wsgi配置成daemon模式">将mod_wsgi配置成daemon模式</a></h2>
<p>在非windows平台上，mod_wsgi推荐使用daemon模式。使用daemon模式后，前面的配置的<code>WSGIPythonHome</code>和<code>WSGIPythonPath</code>要去掉，改为在<code>WSGIDaemonProcess</code>中用<code>python-home</code>和<code>python-path</code>指定，修改后的配置如下：</p>
<pre><code class="language-conf">WSGIProcessGroup example.com
WSGIDaemonProcess example.com python-home=/path/to/venv python-path=/path/to/mysite.com lang='en_US.UTF-8' locale='en_US.UTF-8'
WSGIScriptAlias / /path/to/mysite.com/mysite/wsgi.py process-group=example.com
</code></pre>
<p>注意WSGIDaemonProcess一行中的en_US.UTF-8，如果Django应用会打印utf-8编码的字符，需要将wsgilang和local设置为UTF-8，否则wsgi会报错：</p>
<pre><code>UnicodeEncodeError: 'ascii' codec can't encode characters in position 154-155: ordinal not in range(128)
</code></pre>
<p>如果在shell终端用<code>python ./manage.py runserver</code>运行时也报同样的错误，修改/etc/locale.conf文件后重新登录：</p>
<pre><code class="language-sh">$ cat /etc/locale.conf
LANG=en_US.utf8
LC_CTYPE=en_US.UTF-8
</code></pre>
<h2 id="一个配置wsgi配置样例"><a class="header" href="#一个配置wsgi配置样例">一个配置wsgi配置样例</a></h2>
<p>下面这个独立的（<a href="https://wiki.centos.org/TipsAndTricks/ApacheVhostDir" title="Apache Virtual Host Containers in Separate Files">Apache Virtual Host Containers in Separate Files</a>)配置文件中，将django的日志也拆分了出来：</p>
<pre><code class="language-sh"># cat /etc/httpd/conf.d/discount.conf
&lt;VirtualHost *:80&gt;
  ServerName 127.0.0.1    # 根据实际情况设置
  WSGIProcessGroup discount
  WSGIDaemonProcess discount python-home=/opt/discount/env  python-path=/opt/discount/mysite lang='en_US.UTF-8' locale='en_US.UTF-8'
  WSGIScriptAlias / /opt/discount/mysite/mysite/wsgi.py process-group=discount

  &lt;Directory /opt/discount/mysite/mysite/&gt;
  &lt;Files wsgi.py&gt;
  Require all granted
  &lt;/Files&gt;
  &lt;/Directory&gt;

  LogLevel info
  ErrorLog &quot;logs/discount_error_log&quot;
  CustomLog &quot;logs/discount_access_log&quot; combined
&lt;/VirtualHost&gt;
</code></pre>
<p>上面的logs目录是/etc/httpd/logs，它是符号链接，链接到了/var/log/httpd。</p>
<p>Django的日志和wsgi的日志是分开的，但是用mod_wsgi运行django应用的时候，Django的日志目录需要能够被apache用户读写，因为httpd进程的用户是apache。</p>
<p>最好创建一个单独的目录，并且目录所属修改为apache：</p>
<pre><code>mkdir -p /var/log/discount/
chwon apache:apache /var/log/discount/
</code></pre>
<p>注意Django日志文件不能在/tmp目录中，Django日志位于/tmp目录中时，wsgi虽然不报错，但是日志文件也不会创建，比较奇怪。</p>
<p>下面是Django的日志配置（在项目的settings.py中）:</p>
<pre><code class="language-python">LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'standard': {
            'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s',
        }
    },
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'formatter': 'standard',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/discount/discount.log',
            'maxBytes': 1024*1024*100,
            'backupCount': 10,
        },
        'console':{
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'standard',
        }
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'INFO',
            'propagate': True,
        },
        'wechat': {
            'handlers': ['file'],
            'level': 'INFO',
            'propagate': True,
        }
    },
}
</code></pre>
<h2 id="文件服务器"><a class="header" href="#文件服务器">文件服务器</a></h2>
<p>Django本身不提供文件服务，静态文件服务的需要用nginx、apache等软件实现。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="django中使用redis缓存"><a class="header" href="#django中使用redis缓存">Django中使用Redis缓存</a></h1>
<p><a href="http://niwinz.github.io/django-redis/latest/" title="django-redis documentation">django-redis documentation</a>是python库，将redis与Django无缝结合了起来。</p>
<h2 id="安装redis"><a class="header" href="#安装redis">安装Redis</a></h2>
<pre><code>yum install -y redis
</code></pre>
<p>redis的配置文件是/etc/redis.conf，</p>
<pre><code>maxmemory 30mb
maxmemory-policy volatile-lru
databases 1
</code></pre>
<p>启动，默认只监听地址是127.0.0.1:6739：</p>
<pre><code>systemctl start redis
</code></pre>
<p>验证：</p>
<pre><code># redis-cli  ping
PONG
</code></pre>
<h2 id="安装配置django-redis"><a class="header" href="#安装配置django-redis">安装配置django-redis</a></h2>
<p>安装：</p>
<pre><code class="language-sh">pip install django-redis
</code></pre>
<p>在settings.py中配置：</p>
<pre><code class="language-python">CACHES = {
    &quot;default&quot;: {
        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,
        &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/0&quot;,
        &quot;OPTIONS&quot;: {
            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,
        }
    }
}
</code></pre>
<h2 id="使用redis作为session-backend"><a class="header" href="#使用redis作为session-backend">使用redis作为session backend</a></h2>
<p>将redis作为session backend不需要额外设置，直接启用session backend即可：</p>
<pre><code>SESSION_ENGINE = &quot;django.contrib.sessions.backends.cache&quot;
SESSION_CACHE_ALIAS = &quot;default&quot;
</code></pre>
<h2 id="操作redis"><a class="header" href="#操作redis">操作redis</a></h2>
<pre><code class="language-python">(env) lijiaos-mbp:mysite lijiao$ python manage.py shell
Python 3.7.2 (default, Feb 12 2019, 08:15:36)
[Clang 10.0.0 (clang-1000.11.45.5)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
(InteractiveConsole)
&gt;&gt;&gt; from django.core.cache import cache
&gt;&gt;&gt; cache.set(&quot;foo&quot;, &quot;value&quot;, timeout=25)
True
&gt;&gt;&gt; cache.ttl(&quot;foo&quot;)
20
&gt;&gt;&gt; cache.get(&quot;foo&quot;)
'value'
&gt;&gt;&gt;
</code></pre>
<p>在redis中看到的数据这样的：</p>
<pre><code class="language-sh">127.0.0.1:6379&gt; keys *
1) &quot;:1:foo&quot;
127.0.0.1:6379&gt; get &quot;:1:foo&quot;
&quot;\x80\x04\x95\t\x00\x00\x00\x00\x00\x00\x00\x8c\x05value\x94.&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="独立文件导入-django-环境"><a class="header" href="#独立文件导入-django-环境">独立文件导入 Django 环境</a></h1>
<p>创建文件 bin/movie-spider.py，导入 django 环境：</p>
<pre><code class="language-python">import os
import sys
import django
# load django environment
sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))
os.environ['DJANGO_SETTINGS_MODULE'] = 'spider3.settings'
django.setup()
</code></pre>
<p>然后导入并使用 django 项目中的代码，譬如使用 model：</p>
<pre><code class="language-python">from movie.models import Movi
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="简单了解一下-android-应用的开发过程"><a class="header" href="#简单了解一下-android-应用的开发过程">简单了解一下 android 应用的开发过程</a></h1>
<h2 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h2>
<p>用 Intelli Idea 或者 Android Studio 创建一个 andorid 项目。</p>
<p>项目的主要代码位于 app/src/main 目录中：</p>
<pre><code class="language-sh">$ tree -L 2 android-quickstart/app/src/main
android-quickstart/app/src/main
├── AndroidManifest.xml   # 应用的特性配置
├── java
├   └── com
├       └── example
├           └── android_quickstart
├               ├── MainActivity.java  # 应用入口
├               └── ui
└── res
    ├── drawable
    ├── drawable-v24
    ├── layout              # activity 的 UI
    ├── menu
    ├── mipmap-anydpi-v26
    ├── mipmap-hdpi
    ├── mipmap-mdpi
    ├── mipmap-xhdpi
    ├── mipmap-xxhdpi
    ├── mipmap-xxxhdpi
    ├── navigation
    └── values
</code></pre>
<h2 id="apk-文件"><a class="header" href="#apk-文件">apk 文件</a></h2>
<p>安卓应用的代码、数据和资源文件一起大包成 apk 文件发布，安卓应用在安全沙盒中运行：</p>
<ul>
<li>每个 app 默认使用一个独立的 linux 用户，实现文件的隔离</li>
<li>进程在隔离的 vm 中运行</li>
<li>使用同一个证书签署的 app 可以共用用户、vm，从而可以访问彼此的文件</li>
<li>app 可以申请设备的访问权限</li>
</ul>
<h2 id="app-的组成"><a class="header" href="#app-的组成">app 的组成</a></h2>
<p><strong>Activities</strong>: </p>
<ul>
<li>每个交互界面对应一个 Activity</li>
<li>其它 app 可以唤起另一个 app 允许的 activity</li>
<li>父类：Activity</li>
</ul>
<p><strong>Services</strong>:</p>
<ul>
<li>后台运行的服务</li>
<li>activity 等组件可以启动、绑定 service</li>
<li>service 分为用户可感知（后台音乐）和用户无感知（服务调用）两种类型</li>
<li>父类：Service</li>
</ul>
<p><strong>Broadcast receivers</strong>:</p>
<ul>
<li>跨 app 的事件广播</li>
<li>事件是一个 Intent，BroadcastReceiver 的子类接收并响应事件</li>
</ul>
<p><strong>Content providers</strong>:</p>
<ul>
<li>写入文件系统的持久数据，其它 app 可以操作另一个 app 允许的数据</li>
<li>父类：ContentProvider</li>
</ul>
<p>以上组件通过 Intent 交互。</p>
<p>在 AndroidManifest.xml 中声明所有的组件，以及声明需要的权限。</p>
<h2 id="参考-48"><a class="header" href="#参考-48">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="vue-学习资料"><a class="header" href="#vue-学习资料">vue 学习资料</a></h1>
<p>官网教程： https://cn.vuejs.org/v2/guide/</p>
<p>创建项目的脚手架工具vue-cli： https://cli.vuejs.org/zh/guide/</p>
<p>入门视频课程：https://www.imooc.com/learn/980</p>
<h2 id="vue-开发环境"><a class="header" href="#vue-开发环境">vue 开发环境</a></h2>
<p>IDE 使用 Intelli Idea，在 Preference -&gt; Plugins -&gt; Marketplace 中搜索插件 &quot;vue.js&quot;，安装。</p>
<p>在 Preference -&gt; Editor -&gt; File Types -&gt; HTML 中，添加新的文件后缀 &quot;*.vue&quot;。</p>
<p>在 Preference -&gt; Languages &amp; Frameworks -&gt; JavaScript，选择 ECMAScript6</p>
<p>在 Preference -&gt; Editor -&gt; File and Code Templates 中，创建一个 vue 模版：</p>
<pre><code class="language-html">&lt;template&gt;

    &lt;div&gt; {{msg}}&lt;/div&gt;

&lt;/template&gt;

&lt;style&gt;&lt;/style&gt;

&lt;script&gt;

    export default{ data () { return {msg: 'vue模板页'} } }

&lt;/script&gt;
</code></pre>
<p>新建 vue 项目：Static Web -&gt; Vue.js</p>
<h2 id="vue-cli"><a class="header" href="#vue-cli">vue-cli</a></h2>
<p><a href="https://cli.vuejs.org/zh/guide/" title="vue-cli">vue-cli</a> 是搭建 vue 项目的脚手架。</p>
<p>安装、验证：</p>
<pre><code class="language-sh">$ npm install -g @vue/cli
$ npm --version
 vue --version
@vue/cli 4.1.2
</code></pre>
<p>创建项目:</p>
<pre><code class="language-sh">$ vue create hello-world
</code></pre>
<p>构建：</p>
<pre><code class="language-sh">$ cd hello-world
$ npm run serve
$ npm run lint
$ npm run build 
</code></pre>
<p>项目结构：</p>
<pre><code class="language-sh">$ tree -L 2 
public
├── favicon.ico
└── index.html     //入口
src
├── App.vue        //app
├── assets         //资源文件
│   └── logo.png
├── components     //vue 组件
│   └── HelloWorld.vue
└── main.js
</code></pre>
<h2 id="参考-49"><a class="header" href="#参考-49">参考</a></h2>
<ol>
<li><a href="https://www.lijiaocn.com" title="李佶澳的博客">李佶澳的博客</a></li>
<li><a href="https://www.cnblogs.com/wyq-web/p/9639274.html" title="Intellij IDEA搭建vue-cli项目">Intellij IDEA搭建vue-cli项目</a></li>
<li><a href="https://cli.vuejs.org/zh/guide/" title="vue-cli">vue-cli</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微信公众平台公众号api"><a class="header" href="#微信公众平台公众号api">微信公众平台（公众号）API</a></h1>
<p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084">公众号接口权限</a></p>
<p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5">入门指引</a></p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="微信公众号api回调设置"><a class="header" href="#微信公众号api回调设置">微信公众号API回调设置</a></h1>
<p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5">入门指引</a>中介绍的比较详细。</p>
<p>在微信公众号设置了服务的地址和Token之后，用户留言等信息会被微信公众平台以固定的格式转发到服务地址，提前部署好的服务可以按照程序中的逻辑对不同用户进行不同的回复。服务必须是可以从公网访问的，否则公众平台无法回调。</p>
<p>配置入口是公众号后台左下角的“基本配置”，详情见<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319" title="接入指南">接入指南</a>。</p>
<h2 id="验证微信服务器消息"><a class="header" href="#验证微信服务器消息">验证微信服务器消息</a></h2>
<p>设置完成之后，微信服务器会发送一个GET请求，带有四个参数：</p>
<p><strong>signature</strong>: 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数</p>
<p><strong>timestamp</strong>: 时间戳</p>
<p><strong>nonce</strong>: 随机数</p>
<p><strong>echostr</strong>: 随机字符串</p>
<p>signature的生成规则是：将token、timesstamp和nonce三个参数尽心字典排序，然后拼接称一个字符串，用sha1加密。</p>
<p>如果生成的签名与传入的signature参数相同，证明请求确实来自于微信服务器，将echostrc参数原样返回给微信服务器，接入即生效。</p>
<h2 id="设置开发者密钥"><a class="header" href="#设置开发者密钥">设置开发者密钥</a></h2>
<p>在调用微信公众平台的接口时，需要带有access_token，它是用开发者ID和开发者密码获取的。</p>
<p>在“基本配置”可以看到开发者ID，开发者密码是平台生成的，直接点击设置或者重置获取。平台本身不存储开发者密码，如果密码丢失了，只能重置，获取一个新的密码。</p>
<p>获取了开发者密码后，还要在“IP白名单”中添加用来访问公众平台的服务器IP，只有加入了百名单的IP才能调用平台的access_token获取接口。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微信公众平台回传的消息格式"><a class="header" href="#微信公众平台回传的消息格式">微信公众平台回传的消息格式</a></h1>
<p>普通消息分为：文本、图片、语音、视频、小视频、地理位置、链接，7种类型。</p>
<p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140453">普通消息格式</a></p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="微信公众平台接口调试"><a class="header" href="#微信公众平台接口调试">微信公众平台接口调试</a></h1>
<p>微信公众平台提供了一个<a href="https://mp.weixin.qq.com/debug/" title="微信公众平台接口调试工具">接口调试工具</a>工具，选择不同的接口类型，可以向微信公众平台发送消息，或者让微信公众平台给开发者的应用发送消息。</p>
<h2 id="消息接口调试"><a class="header" href="#消息接口调试">消息接口调试</a></h2>
<p>消息接口调试中，微信公众平台可以向开发者指定的url中发送开发者自定义的消息。</p>
<p>如果使用Django实现，需要豁免该接口的CSRF检查，否则Django会报错：</p>
<pre><code>Forbidden (CSRF cookie not set.): /wechat/
</code></pre>
<p>豁免方法是为Django的views函数添加一个豁免修饰：</p>
<pre><code class="language-python">from django.views.decorators.csrf import csrf_exempt
...
@csrf_exempt
def index(request):
  ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="淘宝客api的使用"><a class="header" href="#淘宝客api的使用">淘宝客API的使用</a></h1>
<p><a href="https://tbk.bbs.taobao.com/detail.html?postId=8576944">史上最详细淘宝联盟API使用教程</a></p>
<p><a href="https://open.taobao.com/doc.htm?docId=103232&amp;docType=1">淘宝开放平台技术文档</a></p>
<p><a href="https://open.taobao.com/api.htm?docId=24515&amp;docType=2&amp;scopeId=11655">淘宝客基础API</a></p>
<p><a href="http://open.alimama.com/api/doc.php?spm=a219t.7900221/1.1998910419.d8546b700.6c6975a5C3VViY">淘宝客API（旧版文档）</a></p>
<p><a href="https://open.taobao.com/api.htm?docId=120&amp;docType=2&amp;scopeId=381">系统工具API</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="淘宝客api开通方法"><a class="header" href="#淘宝客api开通方法">淘宝客API开通方法</a></h1>
<p>淘宝客的开通要到<a href="https://pub.alimama.com/" title="淘宝联盟-阿里妈妈旗下产品">淘宝联盟</a>中申请，开通方法与<a href="https://tbk.bbs.taobao.com/detail.html?postId=8576944">史上最详细淘宝联盟API使用教程</a>中的介绍一致。</p>
<p>在淘宝联盟中：进入我的联盟-&gt;推广管理-&gt;媒体管理-&gt;网站管理，在每个网站条目中都有一个“查看权限”，点击后会出现“联盟合作网站API”信息，如果没有申请，就点击申请。</p>
<p>淘宝联盟审核通过后，回到<a href="https://open.taobao.com/" title="淘宝开放平台">淘宝开放平台</a>的控制台中，会发现多出了一个类型为”联盟合作网站”的应用，这个就是淘宝客API对应的应用。点击应用管理，可以看到APP Key和APP Secret，并在页面下方展示了该应用可以使用的API。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="淘宝客api的sdk下载"><a class="header" href="#淘宝客api的sdk下载">淘宝客API的SDK下载</a></h1>
<p>在淘宝开放平台中，进入应用以后，在左侧边栏中有一个“SDK下载”的菜单，进入后，可以选择下载各种编程语言的SDK，目前支持：Java、PHP、Python、.NET、Metadata、C、NodeJS。</p>
<p>具体用法参考<a href="https://open.taobao.com/doc.htm?docId=101618&amp;docType=1" title="淘宝客SDK的使用说明">淘宝客SDK的使用说明</a>。</p>
<h2 id="python-sdk使用前准备"><a class="header" href="#python-sdk使用前准备">python sdk使用前准备</a></h2>
<p>使用淘宝客的Python SDK的时候要注意，如果用的是Python3，直接使用会遇到错误：</p>
<pre><code>name 'long' is not defined
</code></pre>
<p>这是因为python3中用<a href="https://stackoverflow.com/questions/14904814/nameerror-global-name-long-is-not-defined">int取代了关键字long</a>，淘宝客的python sdk中top/api/base.py还在使用long：</p>
<pre><code>P_TIMESTAMP: str(long(time.time() * 1000)),
</code></pre>
<p>将long修改位int：</p>
<pre><code>P_TIMESTAMP: str(int(time.time() * 1000)),
</code></pre>
<p>但是淘宝客API中还有其它python2的用法，一个一个修改太麻烦了，可以用python提供的<a href="https://docs.python.org/2/library/2to3.html">2to3</a>命令，将整个目录中的python2代码转换成python3：</p>
<pre><code class="language-sh">$ 2to3 -w top
RefactoringTool: Skipping optional fixer: buffer
RefactoringTool: Skipping optional fixer: idioms
RefactoringTool: Skipping optional fixer: set_literal
RefactoringTool: Skipping optional fixer: ws_comma
RefactoringTool: No changes to top/__init__.py
...
</code></pre>
<p>转换之后还是会有一些错误，只能一个个修改：</p>
<h3 id="unicode-objects-must-be-encoded-before-hashing"><a class="header" href="#unicode-objects-must-be-encoded-before-hashing">Unicode-objects must be encoded before hashing</a></h3>
<pre><code>sign = hashlib.md5(parameters).hexdigest().upper()
</code></pre>
<p>修改为：</p>
<pre><code>sign = hashlib.md5(parameters.encode('utf-8')).hexdigest().upper()
</code></pre>
<h3 id="getsockaddrarg-af_inet-address-must-be-tuple-not-int"><a class="header" href="#getsockaddrarg-af_inet-address-must-be-tuple-not-int">getsockaddrarg: AF_INET address must be tuple, not int</a></h3>
<p>这是因为python3的http.client.HTTPConnection()的构造参数顺序发生了变化。</p>
<p>将代码：</p>
<pre><code class="language-python">if(self.__port == 443):
	connection = http.client.HTTPSConnection(self.__domain, self.__port, None, None, False, timeout)
else:
	connection = http.client.HTTPConnection(self.__domain, self.__port, False, timeout)

</code></pre>
<p>修改为：</p>
<pre><code class="language-python">if(self.__port == 443):
    connection = http.client.HTTPSConnection(host=self.__domain, port=self.__port, timeout=timeout)
else:
    connection = http.client.HTTPConnection(self.__domain, self.__port, timeout=timeout)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="淘宝客基础api梳理"><a class="header" href="#淘宝客基础api梳理">淘宝客基础API梳理</a></h1>
<p>详情见<a href="https://open.taobao.com/api.htm?docId=24515&amp;docType=2&amp;scopeId=11655" title="淘宝客基础API">淘宝客基础API</a>，这里整理几个主要API的用途。</p>
<h2 id="用关键字查找淘宝客商品和优惠券"><a class="header" href="#用关键字查找淘宝客商品和优惠券">用关键字查找淘宝客商品和优惠券</a></h2>
<p><a href="https://open.taobao.com/api.htm?docId=24515&amp;docType=2&amp;scopeId=11655">taobao.tbk.item.get</a>，用关键字同时从最多10个类目中查询淘宝客商品，可以设置地域、折扣、佣金比率等。</p>
<p><a href="https://open.taobao.com/api.htm?docId=29821&amp;docType=2&amp;scopeId=11655">taobao.tbk.dg.item.coupon.get</a>，用关键字同时从最多10个类目中查询优惠券。</p>
<h2 id="获取与指定商品相关联的淘宝客商品"><a class="header" href="#获取与指定商品相关联的淘宝客商品">获取与指定商品相关联的淘宝客商品</a></h2>
<p><a href="https://open.taobao.com/api.htm?docId=24517&amp;docType=2&amp;scopeId=11655">taobao.tbk.item.recommend.get</a>，传入一个商品ID，返回与之相关领导商品，最多40个。</p>
<h2 id="淘宝客商品详情批量查询"><a class="header" href="#淘宝客商品详情批量查询">淘宝客商品详情批量查询</a></h2>
<p><a href="https://open.taobao.com/api.htm?docId=24518&amp;docType=2&amp;scopeId=11655">taobao.tbk.item.info.get</a>，最多传入40个商品ID，返回这些商品的详细信息。</p>
<h2 id="获取拼团抢购的商品"><a class="header" href="#获取拼团抢购的商品">获取拼团抢购的商品</a></h2>
<p><a href="https://open.taobao.com/api.htm?docId=27543&amp;docType=2&amp;scopeId=11655">taobao.tbk.ju.tqg.get</a>，返回指定时间范围内的拼团抢购商品。</p>
<h2 id="淘口令生成接口"><a class="header" href="#淘口令生成接口">淘口令生成接口</a></h2>
<p><a href="https://open.taobao.com/api.htm?docId=31127&amp;docType=2&amp;scopeId=11655">taobao.tbk.tpwd.create</a>，设置淘口令的弹框内容、跳转目标页、弹框Logo、扩展字段等。</p>
<p><a href="https://jingyan.baidu.com/article/c33e3f48d57403ea15cbb507.html">如何找到自己的淘宝口令ID</a></p>
<h2 id="获取指定商品的商品和券二合一推广链接"><a class="header" href="#获取指定商品的商品和券二合一推广链接">获取指定商品的商品和券二合一推广链接</a></h2>
<p><a href="https://open.taobao.com/api.htm?docId=33947&amp;docType=2&amp;scopeId=11655">taobao.tbk.dg.optimus.material</a>，传入商品ID、物料ID，返回“链接-宝贝+券二合一页面链接”等多种促销信息。</p>
<p><a href="https://open.taobao.com/api.htm?docId=35896&amp;docType=2&amp;scopeId=11655">taobao.tbk.dg.material.optional</a>，传入关键字、物料ID，返回“链接-宝贝+券二合一页面链接”等多种促销信息。</p>
<p><a href="https://open.taobao.com/api.htm?docId=37884&amp;docType=2&amp;scopeId=11655">taobao.tbk.sc.optimus.material</a>，传入商品ID、物料ID，返回“链接-宝贝+券二合一页面链接”等多种促销信息。这个接口和这一节第一个接口的功能基本相同，区别是这个接口需要卖家授权，授权方式见<a href="https://open.taobao.com/doc.htm?docId=102635&amp;docType=1">用户授权介绍</a>。</p>
<p>“链接-宝贝+券二合一页面链接”非常重要，它是淘口令的跳转目标页地址。</p>
<p><a href="https://tbk.bbs.taobao.com/detail.html?appId=45301&amp;postId=8576096">官方推荐商品库大全</a>给出所有的物料ID，物料ID比较乱，分为好几类。</p>
<p><strong>好券直播</strong>，热门商品，按小时更新，每个material_id 同时产出200款商品。</p>
<p><strong>大额券</strong>,  折扣力度大的商品，小时更新，每个material_id 同时产出500款商品。</p>
<p><strong>高佣榜</strong>，高佣商品，最高达90%，按天更新，每个material_id 同时产出500款商品。</p>
<p><strong>品牌榜</strong>，优质品牌商品，每个material_id 同时产出200款商品。</p>
<p><strong>母婴主题</strong>，从备孕到儿童不同阶段商品，每个material_id 同时产出1000款商品。</p>
<p><strong>有好货</strong>，好货精选,每个material_id 同时产出1000款商品。</p>
<p><strong>潮流范</strong>，时尚流行商品，每个material_id 同时产出1000款商品。</p>
<p><strong>特惠</strong>，销量高, 评价高,点击转化好, 创意具有吸引力的优质低价宝，每个material_id 同时产出1000款商品 。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="淘宝客基础api调用方法"><a class="header" href="#淘宝客基础api调用方法">淘宝客基础API调用方法</a></h1>
<p>下面以Python API为例。</p>
<h2 id="获取app-key和app-secret"><a class="header" href="#获取app-key和app-secret">获取APP Key和APP Secret</a></h2>
<p>在淘开放平台的<a href="http://console.open.taobao.com">控制台</a>中，进入一个应用，就可以看到首页显示有这个应用的App Key和App Secret。</p>
<p>在使用Python API的时候，需要传入这个两个参数：</p>
<pre><code>appKey='XXX'
appSecret='XXX'
top.setDefaultAppInfo(appkey, appSecret)
</code></pre>
<h2 id="获取adzone_id"><a class="header" href="#获取adzone_id">获取adzone_id</a></h2>
<p>有些接口中需要传入adzone_id。adzone_id是推广位的ID，到淘宝联盟后台中查看：“推广管理”-&gt;“推广资源管理”-&gt;“推广位管理”。支持四种类型的推广位：网站推广位、APP推广位、导购推广位、软件推广位。</p>
<p>注意后台中没有推广位的创建连接，需要<a href="http://pub.alimama.com/promo/search/index.htm?q=%E9%9E%8B%E5%AD%90&amp;_t=1554643902198">商品页</a>中随便找一个商品，点击立即推广，在弹出的对话框中，创建推广位。创建之后，回到“推广位管理”页面，就可以看到新建的推广位。</p>
<p>推广位的Pid样式是“mm_33963329_6520758_144842297”，adzone_id是第三段数字。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
                <div style="text-align:center;width:100%">
                    <!--h1>底部相关广告</h1-->
                    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8176866190626448"
                         crossorigin="anonymous"></script>
                    <ins class="adsbygoogle"
                         style="display:block"
                         data-ad-format="autorelaxed"
                         data-ad-client="ca-pub-8176866190626448"
                         data-ad-slot="6443696990"></ins>
                    <script>
                         (adsbygoogle = window.adsbygoogle || []).push({});
                    </script>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
